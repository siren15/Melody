{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":""},{"location":"#melody-is-a-multi-purpose-discord-bot-written-in-python-using-interactionspy-created-for-rgravityfalls-discord-server","title":"Melody is a multi-purpose Discord bot written in Python using interactions.py. Created for r/gravityfalls discord server","text":""},{"location":"#modules","title":"Modules","text":"<ul> <li>Automod - phishihing links detection, banned names detection</li> <li>Moderation - warning system, temp banning, muting</li> <li>Button Roles - manage button roles, 3 modes(give/take, 1 role per messsage, give - can't take away)</li> <li>Role Giving - give role, creating and managing giveyous</li> <li>Logging - logging of deleted and updated messages, roles given, mod actions</li> <li>Persistent Roles</li> <li>Leveling</li> <li>Tags</li> <li>Dashboard - work in progress, you can't really do anything substential on there rn - only leaderboard works (plus changing custm rank card BGs)</li> </ul>"},{"location":"#planned-features","title":"Planned features","text":"<ul> <li>Music support (this might be an addon or self hostable feature)</li> <li>Economy</li> </ul>"},{"location":"automod/","title":"Automod","text":"<p>         Bases: <code>Extension</code></p> Source code in <code>extentions/automod.py</code> <pre><code>class AutoMod(Extension):\n    def __init__(self, bot: Client):\n        self.bot = bot\n        self.phishing_links = list()\n        plinks = requests.get('https://raw.githubusercontent.com/Discord-AntiScam/scam-links/main/urls.json')\n        for link in json.loads(plinks.text):\n            self.phishing_links.append(link)\n\n    @listen()\n    async def discord_automod_log(self, event: AutoModExec):\n        if event.execution.action.type == 1:\n            trigger_type = event.execution.rule_trigger_type\n            content = event.execution.content\n            guild = event.guild\n            if trigger_type == 1:\n                trigger = \"BANNED WORD\"\n                reason = f\"Message contains a banned word set by this community: {content}\"\n            elif trigger_type == 3:\n                trigger = \"SPAM\"\n                reason = f\"Message contains spam: {content}\"\n            elif trigger_type == 4:\n                trigger = \"DISCORD BANNED WORD\"\n                reason = f\"Message contains a banned word set by discord: {content}\"\n            elif trigger_type == 5:\n                trigger = \"MENTION SPAM\"\n                reason = f\"Message exceeds the mention limit set by this community\"\n            audit_log_entry = await guild.fetch_audit_log(action_type=143, limit=1)\n            for user in audit_log_entry.users:\n                while True:\n                    avid = random_string_generator()\n                    strikes_db = await db.strikes.find_one({'guildid':guild.id, 'strikeid':avid})\n                    if strikes_db is None:\n                        break\n                    else:\n                        continue\n                daytime = f'&lt;t:{math.ceil(datetime.now().timestamp())}&gt;'\n                await db.strikes(strikeid=avid, guildid=guild.id, user=user.id, moderator=self.bot.user.id, action=f\"Automod Message Block ({trigger})\", day=daytime, reason=reason, automod=True).insert()\n\n                settings = await db.amConfig.find_one({'guild':guild.id})\n                channelid = await db.logs.find_one({\"guild_id\":guild.id})\n                log_channel = guild.get_channel(channelid.channel_id)\n\n                violation_entries = []\n                async for entry in db.strikes.find({'guildid':guild.id, 'user':user.id, 'action':f\"Automod Message Block ({trigger})\", 'automod':True}):\n                    violation_entries.append(entry.user)\n                if settings.phishing.violation_count is not None:\n                    if len(violation_entries) &gt; settings.phishing.violation_count:\n\n                        warnreason = f\"{reason}. You've done this {len(violation_entries)} times, which exceeds our violations limit for {trigger} of {settings.phishing.violation_count}\"\n\n                        if 'warn' in settings.phishing.violation_punishment:\n                            await automod_warn(event, log_channel, warnreason)\n\n                        if 'mute' in settings.phishing.violation_punishment:\n                            await automod_mute(event, settings, warnreason)\n\n                        if 'kick' in settings.phishing.violation_punishment:\n                            await guild.kick(user, warnreason)\n\n                        if 'ban' in settings.phishing.violation_punishment:\n                            await automod_ban(event, settings, warnreason)\n    @listen()\n    async def phishing_links_filter(self, event: MessageCreate):\n        message = event.message\n        user = message.author\n        member = user\n        guild = event.message.guild\n        channel = message.channel\n        if user.bot:\n            return\n        reason = f'[AUTOMOD]phishing link sent in {channel.name}'\n        if await is_automod_event_active(guild, 'phishing_filter'):\n            settings = await db.amConfig.find_one({'guild':guild.id})\n            if settings.ignored_users is not None:\n                if member.id in settings.ignored_users:\n                    return\n            if settings.ignored_roles is not None:\n                if any(role for role in member.roles if role.id in settings.ignored_roles):\n                    return\n            if member.has_permission(Permissions.ADMINISTRATOR) == True:\n                return\n            if settings.ignored_channels is not None:\n                if channel.id in settings.ignored_channels:\n                    return\n            urls = geturl(message.content)\n            if urls is not None:\n                for url in urls:\n                    for link in self.phishing_links:\n                        if link == url:\n                            await message.delete()\n                            await channel.send(f\"Hey {user.mention}! That link is banned here!\", delete_after=3)\n\n                            await automod_strike(self, event, \"Automod Log (Phishing Links)\", reason)\n\n                            channelid = await db.logs.find_one({\"guild_id\":guild.id})\n                            log_channel = guild.get_channel(channelid.channel_id)\n\n                            violation_entries = []\n                            async for entry in db.strikes.find({'guildid':guild.id, 'user':user.id, 'action':\"Automod Log (Phishing Links)\", 'automod':True}):\n                                violation_entries.append(entry.user)\n                            if settings.phishing.violation_count is not None:\n                                if len(violation_entries) &gt; settings.phishing.violation_count:\n                                    if 'warn' in settings.phishing.violation_punishment:\n                                        await automod_warn(event, log_channel, reason)\n\n                                    if 'mute' in settings.phishing.violation_punishment:\n                                        await automod_mute(event, settings, reason)\n\n                                    if 'kick' in settings.phishing.violation_punishment:\n                                        await guild.kick(user, reason)\n\n                                    if 'ban' in settings.phishing.violation_punishment:\n                                        await automod_ban(event, settings, reason)\n\n    psc = SlashCommand(name = 'phishing_links', description=\"Configure Melodys phishing links automod.\", default_member_permissions=Permissions.ADMINISTRATOR)\n\n    @psc.subcommand('violation_count', sub_cmd_description='How many violations before punishment.')\n    @slash_option('violations_count', 'Must be between 0-10.', OptionType.INTEGER)\n    async def phishing_links_violation_count(self, ctx: InteractionContext, violations_count:int=0):\n\"\"\"\n        /phishing_links violation_count\n        Description:\n            Configure how many violations are needed before Melody gives out a punishment.\n\n        Args:\n            violations_count: Must be between 0-10\n        \"\"\"\n        # violations_count = get_num(violations_count)\n        if (int(violations_count) &gt; 10) or (int(violations_count) &lt; 0):\n            await ctx.send(f\"{violations_count} is not a valid violation count. Violation count has to be between 0-10.\")\n        if violations_count is None:\n            violations_count = 0\n        settings = await db.automod_config.find_one({\"guildid\":ctx.guild_id})\n        settings.phishing.violation_count = int(violations_count)\n        await settings.save()\n        await ctx.send(f'Violation count set to: {violations_count}')\n\n    @psc.subcommand('punishments', sub_cmd_description='What punishments to use?')\n    async def phishing_links_punishments(self, ctx: InteractionContext):\n\"\"\"\n        /phishing_links punishments\n        Description:\n            Configure what punishments will Melody give out.\n        Usage:\n            There are no parameters in this command, you just have to use it, and it will send you a configuration selection menu. Selections are automatically saved. Config time limit is 2 minutes.\n        \"\"\"\n        settings = await db.amConfig.find_one({'guildid':ctx.guild_id})\n        if settings.phishing.violation_punishment is None:\n            events_log_list = ''\n        else:\n            events_log_list = settings.phishing.violation_punishment\n\n        if 'warn' in events_log_list:\n            warn_status = True\n        else:\n            warn_status = False\n\n        if 'mute' in events_log_list:\n            mute_status = True\n        else:\n            mute_status = False\n\n        if 'kick' in events_log_list:\n            kick_status = True\n        else:\n            kick_status = False\n\n        if 'ban' in events_log_list:\n            ban_status = True\n        else:\n            ban_status = False\n\n        select_options = [\n            StringSelectOption(label=\"Warn\", value=\"warn\", default=warn_status),\n            StringSelectOption(label=\"Mute\", value=\"mute\", default=mute_status),\n            StringSelectOption(label=\"Kick\", value=\"kick\", default=kick_status),\n            StringSelectOption(label=\"Ban\", value=\"ban\", default=ban_status)\n        ]\n\n        select_menu = StringSelectMenu(select_options, min_values=0, max_values=2)\n\n        message = await ctx.send('Configure to what automod reacts to:', components=select_menu)\n\n        while True:\n            try:\n                select = await self.bot.wait_for_component(components=select_menu, timeout=120)\n            except asyncio.TimeoutError:\n                await message.edit('Config closed due to 2 minutes of inactivity.', components=[])\n            else:\n                values = ','.join(select.ctx.values)\n                settings.phishing.violation_punishment = values\n                await settings.save()\n\n    @listen()\n    async def onNameChange_banned_name_exact(self, event: MemberUpdate):\n        member =  event.after\n        if await is_automod_event_active(event.guild, 'banned_names'):\n            old_name =  event.before.display_name\n            new_name = event.after.display_name\n            if old_name != new_name:\n                settings = await db.amConfig.find_one({'guild':event.guild.id})\n                if settings.ignored_users is not None:\n                    if member.id in settings.ignored_users:\n                        return\n                if settings.ignored_roles is not None:\n                    if any(role for role in member.roles if role.id in settings.ignored_roles):\n                        return\n                if member.has_permission(Permissions.ADMINISTRATOR) == True:\n                    return\n                bn = await db.bannedNames.find_one({'guild':event.guild.id})\n                if bn is None:\n                    await db.bannedNames(guild=event.guild.id).insert()\n                banned_names = bn.names\n                new_name_result = process.extract(new_name, banned_names, scorer=fuzz.token_sort_ratio, limit=1)\n                names = [t[0] for t in new_name_result if t[1] &gt;= 90]\n                username_result = process.extract(member.username, banned_names, scorer=fuzz.token_sort_ratio, limit=1)\n                usernames = [t[0] for t in username_result if t[1] &gt;= 90]\n                if names != []:\n                    name = ' '.join(names)\n                    reason = f'Automod detected a banned name {name} in {new_name} for {member}({member.id})'\n                    if usernames == []:\n                        await member.edit_nickname(member.username, reason)\n                    else:\n                        await member.edit_nickname(bn.default_name, reason)\n                    embed = Embed(description=reason,\n                                            color=0xffcc50)\n                    embed.set_thumbnail(url=member.avatar.url)\n                    embed.add_field(name=\"Old Name\", value=old_name)\n                    embed.add_field(name=\"New Name\", value=new_name)\n\n                    channelid = await db.logs.find_one({\"guild_id\":member.guild.id})\n                    log_channel = member.guild.get_channel(channelid.channel_id)\n                    try:\n                        await member.send(f\"Your name or part of your name were flagged in banned names in `{event.guild.name}` server.\\nI've flagged `{name}` in `{new_name}`\")\n                        await log_channel.send(f'I DMed {member}', embed=embed)\n                    except Exception:\n                        await log_channel.send(f\"Couldn't DM {member}\", embed=embed)\n\n                    violation_count = await db.strikes.find({'guildid':event.guild.id, 'user':member.id, 'action':\"Automod Log (Banned Name)\", 'automod':True}).count()\n                    if settings.banned_names.violation_count is not None:\n                        if violation_count &gt; settings.banned_names.violation_count:\n                            if 'warn' in settings.banned_names.violation_punishment:\n                                await automod_warn(event, log_channel, reason)\n\n                            if 'mute' in settings.banned_names.violation_punishment:\n                                await automod_mute(event, settings, reason)\n\n                            if 'kick' in settings.banned_names.violation_punishment:\n                                await event.guild.kick(member, reason)\n\n                            if 'ban' in settings.banned_names.violation_punishment:\n                                await automod_ban(event, settings, reason)\n\n    @listen()\n    async def onMemAdd_banned_name_exact(self, event: MemberAdd):\n        member =  event.member\n        if await is_automod_event_active(event.guild, 'banned_names'):\n            new_name = member.display_name\n            settings = await db.amConfig.find_one({'guild':event.guild.id})\n            if settings.ignored_users is not None:\n                if member.id in settings.ignored_users:\n                    return\n            if settings.ignored_roles is not None:\n                if any(role for role in member.roles if role.id in settings.ignored_roles):\n                    return\n            if member.has_permission(Permissions.ADMINISTRATOR) == True:\n                return\n            bn = await db.bannedNames.find_one({'guild':event.guild.id})\n            if bn is None:\n                await db.bannedNames(guild=event.guild.id).insert()\n            banned_names = bn.names\n            new_name_result = process.extract(new_name, banned_names, scorer=fuzz.token_sort_ratio, limit=1)\n            names = [t[0] for t in new_name_result if t[1] &gt;= 90]\n            if names != []:\n                name = ' '.join(names)\n                reason = f'Automod detected a banned name {name} in {new_name} for {member}({member.id})'\n                await member.edit_nickname(bn.default_name, reason)\n                embed = Embed(description=reason,\n                                        color=0xffcc50)\n                embed.set_thumbnail(url=member.avatar.url)\n\n                channelid = await db.logs.find_one({\"guild_id\":member.guild.id})\n                log_channel = member.guild.get_channel(channelid.channel_id)\n                try:\n                    await member.send(f\"Your name or part of your name were flagged in banned names in `{event.guild.name}` server.\\nI've flagged `{name}` in `{new_name}`\")\n                    await log_channel.send(f'I DMed {member}', embed=embed)\n                except Exception:\n                    await log_channel.send(f\"Couldn't DM {member}\", embed=embed)\n\n                violation_count = await db.strikes.find({'guildid':event.guild.id, 'user':member.id, 'action':\"Automod Log (Banned Name)\", 'automod':True}).count()\n                if settings.banned_names.violation_count is not None:\n                    if violation_count &gt; settings.banned_names.violation_count:\n                        if 'warn' in settings.banned_names.violation_punishment:\n                            await automod_warn(event, log_channel, reason)\n\n                        if 'mute' in settings.banned_names.violation_punishment:\n                            await automod_mute(event, settings, reason)\n\n                        if 'kick' in settings.banned_names.violation_punishment:\n                            await event.guild.kick(member, reason)\n\n                        if 'ban' in settings.banned_names.violation_punishment:\n                            await automod_ban(event, settings, reason)\n\n    BannedNames = SlashCommand(name='banned_names', default_member_permissions=Permissions.ADMINISTRATOR, description='Manage banned names.')\n\n    @BannedNames.subcommand(sub_cmd_name='manage', sub_cmd_description='Manage banned names')\n    async def banned_names_manage(self, ctx:InteractionContext):\n\"\"\"\n        /banned_names manage\n        Description:\n            Manage banned names.\n        Usage:\n            Use the command to get a muodal menu for configuration. Config will be saved on modal submit. Config time limit is 10 minutes.\n        \"\"\"\n        bn = await db.bannedNames.find_one({'guild':ctx.guild.id})\n        settings = await db.amConfig.find_one({\"guild\":ctx.guild_id})\n        if settings.banned_names.violation_count is None:\n            bw_vc_pf = MISSING\n        else:\n            bw_vc_pf = settings.banned_names.violation_count\n\n        if bn is None:\n            exact_prefill = MISSING\n            defname_prefill = MISSING\n        else:\n            if bn.names is None:\n                exact_prefill = MISSING\n            else:\n                exact_prefill = ','.join(bn.names)\n            if bn.default_name is None:\n                defname_prefill = MISSING\n            else:\n                defname_prefill = bn.default_name\n        m = Modal(title='Configure the automatic moderation', components=[\n            InputText(\n                label=\"Banned Names\",\n                style=TextStyles.PARAGRAPH,\n                custom_id=f'exact_match',\n                placeholder='Words, seperated by a comma(,). They should have minimum 3 characters.',\n                value=exact_prefill,\n                required=False\n            ),\n            InputText(\n                label=\"Fallback Name\",\n                style=TextStyles.SHORT,\n                custom_id=f'defname',\n                placeholder=\"One name that will be act as a fallback\",\n                value=defname_prefill,\n                required=True,\n                max_length=32,\n                min_length=2\n            ),\n            InputText(\n                label=\"Violation Count\",\n                style=TextStyles.SHORT,\n                custom_id=f'bw_vc',\n                placeholder=\"Must be between 0-10.\",\n                value=bw_vc_pf,\n                required=False\n            )\n        ],custom_id=f'{ctx.author.id}_automod_config_modal')\n\n        await ctx.send_modal(modal=m)\n        try:\n            modal_recived: ModalContext = await self.bot.wait_for_modal(modal=m, author=ctx.author.id, timeout=600)\n        except asyncio.TimeoutError:\n            return await modal_recived.send(f\":x: Uh oh, {ctx.author.mention}! You took longer than 10 minutes to respond to this \", ephemeral=True)\n\n        em_words = modal_recived.responses.get('exact_match')\n        defName = modal_recived.responses.get('defname')\n\n        bw_vc_response = modal_recived.responses.get('bw_vc')\n        if (bw_vc_response == '') or (bw_vc_response is None):\n            bw_vc_response = None\n        elif (get_num(bw_vc_response) &gt; 10) or (get_num(bw_vc_response) &lt; 0):\n            await modal_recived.send(f\"{bw_vc_response} is not a valid violation count. Violation count has to be between 0-10.\")\n\n        settings.banned_names.violation_count = get_num(bw_vc_response)\n        await settings.save()\n\n        if bn is None:\n            await db.bannedNames(guild=ctx.guild_id, names=em_words.split(','), default_name=defName).insert()\n        else:\n            bn.default_name = defName\n            bn.names = em_words.split(',')\n            await bn.save()\n\n        embed=Embed(color=0xffcc50,\n        description=f'**Current banned names:**\\n{em_words}\\n**Violation count:** {bw_vc_response}')\n        await modal_recived.send(embed=embed)\n\n    @BannedNames.subcommand('punishments', sub_cmd_description='What punishments to use?')\n    async def banned_names_punishments(self, ctx: InteractionContext):\n\"\"\"\n        /banned_names punishments\n        Description:\n            Configure what punishments will Melody give out.\n        Usage:\n            There are no parameters in this command, you just have to use it, and it will send you a configuration selection menu. Selections are automatically saved. Config time limit is 2 minutes.\n        \"\"\"\n        settings = await db.amConfig.find_one({'guildid':ctx.guild_id})\n        if settings.banned_names.violation_punishment is None:\n            events_log_list = ''\n        else:\n            events_log_list = settings.banned_names.violation_punishment\n\n        if 'warn' in events_log_list:\n            warn_status = True\n        else:\n            warn_status = False\n\n        if 'mute' in events_log_list:\n            mute_status = True\n        else:\n            mute_status = False\n\n        if 'kick' in events_log_list:\n            kick_status = True\n        else:\n            kick_status = False\n\n        if 'ban' in events_log_list:\n            ban_status = True\n        else:\n            ban_status = False\n\n        select_options = [\n            StringSelectOption(label=\"Warn\", value=\"warn\", default=warn_status),\n            StringSelectOption(label=\"Mute\", value=\"mute\", default=mute_status),\n            StringSelectOption(label=\"Kick\", value=\"kick\", default=kick_status),\n            StringSelectOption(label=\"Ban\", value=\"ban\", default=ban_status)\n        ]\n\n        select_menu = StringSelectMenu(select_options, min_values=0, max_values=2)\n\n        message = await ctx.send('Configure to what automod reacts to:', components=select_menu)\n\n        while True:\n            try:\n                select = await self.bot.wait_for_component(components=select_menu, timeout=120)\n            except asyncio.TimeoutError:\n                await message.edit('Config closed due to 2 minutes of inactivity.', components=[])\n            else:\n                values = ','.join(select.ctx.values)\n                settings.banned_names.violation_punishment = values\n                await settings.save()\n\n    AutoModSettings = SlashCommand(name='automod', default_member_permissions=Permissions.ADMINISTRATOR, description='Manage the automod.')\n\n    @AutoModSettings.subcommand(sub_cmd_name='listen_to_events', sub_cmd_description='Activate parts of the automod')\n    async def automod_events(self, ctx: InteractionContext):\n\"\"\"\n        /automod listen_to_events\n        Description:\n            Configure what AutoMod events will Melody listen to in the server.\n        Usage:\n            There are no parameters in this command, you just have to use it, and it will send you a configuration selection menu. Selections are automatically saved. Config time limit is 2 minutes.\n        \"\"\"\n        await ctx.defer(ephemeral=True)\n        events = await db.amConfig.find_one({'guildid':ctx.guild_id})\n        if events.active_events is None:\n            events_log_list = []\n        else:\n            events_log_list = events.active_events\n        if 'banned_names' in events_log_list:\n            bn_status = True\n        else:\n            bn_status = False\n\n        if 'phishing_filter' in events_log_list:\n            pf_status = True\n        else:\n            pf_status = False\n\n        select_options = [\n            StringSelectOption(label=\"Banned Names\", value=\"banned_names\", default=bn_status),\n            StringSelectOption(label=\"phishing_filter\", value=\"phishing_filter\", default=pf_status),\n        ]\n\n        select_menu = StringSelectMenu(select_options, min_values=0, max_values=2)\n\n        message = await ctx.send('Configure to what automod reacts to:', components=select_menu)\n\n        while True:\n            try:\n                select = await self.bot.wait_for_component(components=select_menu, timeout=120)\n            except asyncio.TimeoutError:\n                await message.edit('Config closed due to 2 minutes of inactivity.', components=[])\n            else:\n                events.active_events = select.ctx.values\n                await events.save()\n\n    @AutoModSettings.subcommand(sub_cmd_name='ban_mute_times', sub_cmd_description='Define a ban and mute times.')\n    @slash_option(name=\"bantime\", description=\"tempban time, examples: 10 S, 10 M, 10 H, 10 D\", opt_type=OptionType.INTEGER, required=False)\n    @slash_option(name=\"mutetime\", description=\"mute time, examples: 10 S, 10 M, 10 H, 10 D\", opt_type=OptionType.INTEGER, required=False)\n    async def automod_ban_mute_times(self, ctx:InteractionContext, bantime:int=0, mutetime:int=0):\n\"\"\"\n        /automod ban_mute_times\n        Description:\n            Configure the temp ban and mute times Melody will use in automod.\n\n        Args:\n            bantime (int, optional): tempban time, examples: 10 S, 10 M, 10 H, 10 D\" Defaults to 0.\n            mutetime (int, optional): mute time, examples: 10 S, 10 M, 10 H, 10 D Defaults to 0.\n        \"\"\"\n        if bantime is not None:\n            bt = await bm_time_to_sec(ctx, bantime)\n        else:\n            bt = bantime\n        if mutetime is not None:\n            mt = await bm_time_to_sec(ctx, mutetime)\n        else:\n            mt = mutetime\n        settings = await db.automod_config.find_one({\"guildid\":ctx.guild_id})\n        settings.ban_time = bt\n        settings.mute_time = mt\n        await settings.save()\n        await ctx.send(f'Ban time: {bantime}\\nMute time: {mutetime}')\n\n    @AutoModSettings.subcommand('ignored_channel', 'add', 'Add a channel to ignored channels.')\n    @channel()\n    async def AutomodAddIgnoredChannels(self, ctx:InteractionContext, channel: OptionType.CHANNEL=None):\n\"\"\"\n        /automod ignored_channel add\n        Description:\n            Add a channel to channels ignored by AutoMod.\n\n        Args:\n            channel (OptionType.CHANNEL, optional): The channel you want to add. Defaults to channel you're executing the command from.\n        \"\"\"\n        await ctx.defer(ephemeral=True)\n        if channel is None:\n            channel = ctx.channel\n        settings = await db.amConfig.find_one({\"guild\":ctx.guild.id})\n        if settings is None:\n            await db.amConfig(guild=ctx.guild.id, phishing=violation_settings, banned_words=violation_settings, banned_names=violation_settings).insert()\n        ignored_channels = settings.ignored_channels\n        if ignored_channels is None:\n            ignored_channels = list()\n        if channel.id in ignored_channels:\n            await ctx.send(f'{channel.mention} is already ignored.', ephemeral=True)\n        ignored_channels.append(channel.id)\n        await settings.save()\n        channel_mentions = [ctx.guild.get_channel(id) for id in ignored_channels]\n        channel_mentions = [ch.mention for ch in channel_mentions if ch is not None]\n        channel_mentions = ' '.join(channel_mentions)\n        embed = Embed(description=f\"Channel {channel.mention} set to be ignored.\")\n        embed.add_field('Ignored Channels', channel_mentions)\n        await ctx.send(embed=embed, ephemeral=True)\n\n    @AutoModSettings.subcommand('ignored_channel', 'remove', 'Remove a channel from ignored channels.')\n    @channel()\n    async def AutomodRemoveIgnoredChannels(self, ctx:InteractionContext, channel: OptionType.CHANNEL=None):\n\"\"\"\n        /automod ignored_channel remove\n        Description:\n            Remove a channel from channels ignored by AutoMod.\n\n        Args:\n            channel (OptionType.CHANNEL, optional): The channel you want to remove. Defaults to channel you're executing the command from.\n        \"\"\"\n        await ctx.defer(ephemeral=True)\n        if channel is None:\n            channel = ctx.channel\n        settings = await db.amConfig.find_one({\"guild\":ctx.guild.id})\n        if settings is None:\n            await db.amConfig(guild=ctx.guild.id, phishing=violation_settings, banned_words=violation_settings, banned_names=violation_settings).insert()\n        ignored_channels = settings.ignored_channels\n        if ignored_channels is None:\n            ignored_channels = list()\n        if channel.id not in ignored_channels:\n            await ctx.send(f'{channel.mention} is not being ignored by automod.', ephemeral=True)\n        ignored_channels.remove(channel.id)\n        await settings.save()\n        channel_mentions = [ctx.guild.get_channel(id) for id in ignored_channels]\n        channel_mentions = [ch.mention for ch in channel_mentions if ch is not None]\n        channel_mentions = ' '.join(channel_mentions)\n        embed = Embed(description=f\"Channel {channel.mention} removed from ignored channels.\")\n        embed.add_field('Ignored Channels', channel_mentions)\n        await ctx.send(embed=embed, ephemeral=True)\n\n    @AutoModSettings.subcommand('ignored_role', 'add', 'Make a role to be ignored by automod.')\n    @role()\n    async def AutomodAddIgnoredRoles(self, ctx:InteractionContext, role: OptionType.ROLE):\n\"\"\"\n        /automod ignored_role add\n        Description:\n            Add a role to roles ignored by AutoMod.\n\n        Args:\n            role (OptionType.ROLE): The role you want to add.\n        \"\"\"\n        await ctx.defer(ephemeral=True)\n        settings = await db.amConfig.find_one({\"guild\":ctx.guild.id})\n        if settings is None:\n            await db.amConfig(guild=ctx.guild.id, phishing=violation_settings, banned_words=violation_settings, banned_names=violation_settings).insert()\n        ignored_roles = settings.ignored_roles\n        if ignored_roles is None:\n            ignored_roles = list()\n        if role.id in ignored_roles:\n            await ctx.send(f'{role.mention} is already ignored.', ephemeral=True)\n        ignored_roles.append(role.id)\n        await settings.save()\n        role_mentions = [ctx.guild.get_role(id) for id in ignored_roles]\n        role_mentions = [r.mention for r in role_mentions if r is not None]\n        role_mentions = ' '.join(role_mentions)\n        embed = Embed(description=f\"Role {role.mention} was added to roles ignored by automod.\")\n        embed.add_field('Ignored Roles', role_mentions)\n        await ctx.send(embed=embed, ephemeral=True)\n\n    @AutoModSettings.subcommand('ignored_role', 'remove', 'Remove a role from ignored roles.')\n    @role()\n    async def AutomodRemoveIgnoredRoles(self, ctx:InteractionContext, role: OptionType.ROLE):\n\"\"\"\n        /automod ignored_role remove\n        Description:\n            Remove a role from roles ignored by AutoMod.\n\n        Args:\n            role (OptionType.ROLE): The role you want to remove.\n        \"\"\"\n        await ctx.defer(ephemeral=True)\n        settings = await db.amConfig.find_one({\"guild\":ctx.guild.id})\n        if settings is None:\n            await db.amConfig(guild=ctx.guild.id, phishing=violation_settings, banned_words=violation_settings, banned_names=violation_settings).insert()\n        ignored_roles = settings.ignored_roles\n        if ignored_roles is None:\n            ignored_roles = list()\n        if role.id not in ignored_roles:\n            await ctx.send(f'{role.mention} is not being ignored by automod.', ephemeral=True)\n        ignored_roles.remove(role.id)\n        await settings.save()\n        role_mentions = [ctx.guild.get_role(id) for id in ignored_roles]\n        role_mentions = [r.mention for r in role_mentions if r is not None]\n        role_mentions = ' '.join(role_mentions)\n        embed = Embed(description=f\"Role {role.mention} was removed from roles ignored by automod.\")\n        embed.add_field('Ignored Roles', role_mentions)\n        await ctx.send(embed=embed, ephemeral=True)\n\n    @AutoModSettings.subcommand('ignored_member', 'add', 'Make a member to be ignored by automod.')\n    @user()\n    async def AutomodAddIgnoredMember(self, ctx:InteractionContext, user: OptionType.USER):\n\"\"\"\n        /automod ignored_member add\n        Description:\n            Add a member to members ignored by AutoMod.\n\n        Args:\n            user (OptionType.USER): member to be ignored by automod\n        \"\"\"\n        await ctx.defer(ephemeral=True)\n        settings = await db.amConfig.find_one({\"guild\":ctx.guild.id})\n        if settings is None:\n            await db.amConfig(guild=ctx.guild.id, phishing=violation_settings, banned_words=violation_settings, banned_names=violation_settings).insert()\n        ignored_users = settings.ignored_users\n        if ignored_users is None:\n            ignored_users = list()\n        if user.id in ignored_users:\n            await ctx.send(f'{user}|{user.id} is already ignored.', ephemeral=True)\n        ignored_users.append(user.id)\n        await settings.save()\n        users = [ctx.guild.get_member(id) for id in ignored_users]\n        users = [f'{r}({r.id})' for r in users if r is not None]\n        users = ' '.join(users)\n        embed = Embed(description=f\"Member {user}({user.id}) was added to members ignored by automod.\")\n        embed.add_field('Ignored Members', users)\n        await ctx.send(embed=embed, ephemeral=True)\n\n    @AutoModSettings.subcommand('ignored_member', 'remove', 'Remove a member from ignored members.')\n    @user()\n    async def AutomodRemoveIgnoredMember(self, ctx:InteractionContext, user: OptionType.USER):\n\"\"\"\n        /automod ignored_member remove\n        Description:\n            Remove a member from members ignored by AutoMod.\n\n        Args:\n            user (OptionType.USER): member to be removed from ignored members by automod\n        \"\"\"\n        await ctx.defer(ephemeral=True)\n        settings = await db.amConfig.find_one({\"guild\":ctx.guild.id})\n        if settings is None:\n           await db.amConfig(guild=ctx.guild.id, phishing=violation_settings, banned_words=violation_settings, banned_names=violation_settings).insert()\n        ignored_users = settings.ignored_users\n        if ignored_users is None:\n            ignored_users = list()\n        if user.id not in ignored_users:\n            await ctx.send(f'{user}|{user.id} is not being ignored by automod.', ephemeral=True)\n        ignored_users.remove(user.id)\n        await settings.save()\n        users = [ctx.guild.get_member(id) for id in ignored_users]\n        users = [f'{r}({r.id})' for r in users if r is not None]\n        users = ' '.join(users)\n        embed = Embed(description=f\"Member {user}({user.id}) was removed from members ignored by automod.\")\n        embed.add_field('Ignored Members', users)\n        await ctx.send(embed=embed, ephemeral=True)\n</code></pre> <p>Ignored chanels, ignored roles, and ban/mute times are global across the automod system.</p>"},{"location":"automod/#extentions.automod.AutoMod.phishing_links_violation_count","title":"<code>phishing_links_violation_count(ctx, violations_count=0)</code>  <code>async</code>","text":"<p>/phishing_links violation_count</p> Description <p>Configure how many violations are needed before Melody gives out a punishment.</p> <p>Parameters:</p> Name Type Description Default <code>violations_count</code> <code>int</code> <p>Must be between 0-10</p> <code>0</code> Source code in <code>extentions/automod.py</code> <pre><code>@psc.subcommand('violation_count', sub_cmd_description='How many violations before punishment.')\n@slash_option('violations_count', 'Must be between 0-10.', OptionType.INTEGER)\nasync def phishing_links_violation_count(self, ctx: InteractionContext, violations_count:int=0):\n\"\"\"\n    /phishing_links violation_count\n    Description:\n        Configure how many violations are needed before Melody gives out a punishment.\n\n    Args:\n        violations_count: Must be between 0-10\n    \"\"\"\n    # violations_count = get_num(violations_count)\n    if (int(violations_count) &gt; 10) or (int(violations_count) &lt; 0):\n        await ctx.send(f\"{violations_count} is not a valid violation count. Violation count has to be between 0-10.\")\n    if violations_count is None:\n        violations_count = 0\n    settings = await db.automod_config.find_one({\"guildid\":ctx.guild_id})\n    settings.phishing.violation_count = int(violations_count)\n    await settings.save()\n    await ctx.send(f'Violation count set to: {violations_count}')\n</code></pre>"},{"location":"automod/#extentions.automod.AutoMod.phishing_links_punishments","title":"<code>phishing_links_punishments(ctx)</code>  <code>async</code>","text":"<p>/phishing_links punishments</p> Description <p>Configure what punishments will Melody give out.</p> Usage <p>There are no parameters in this command, you just have to use it, and it will send you a configuration selection menu. Selections are automatically saved. Config time limit is 2 minutes.</p> Source code in <code>extentions/automod.py</code> <pre><code>@psc.subcommand('punishments', sub_cmd_description='What punishments to use?')\nasync def phishing_links_punishments(self, ctx: InteractionContext):\n\"\"\"\n    /phishing_links punishments\n    Description:\n        Configure what punishments will Melody give out.\n    Usage:\n        There are no parameters in this command, you just have to use it, and it will send you a configuration selection menu. Selections are automatically saved. Config time limit is 2 minutes.\n    \"\"\"\n    settings = await db.amConfig.find_one({'guildid':ctx.guild_id})\n    if settings.phishing.violation_punishment is None:\n        events_log_list = ''\n    else:\n        events_log_list = settings.phishing.violation_punishment\n\n    if 'warn' in events_log_list:\n        warn_status = True\n    else:\n        warn_status = False\n\n    if 'mute' in events_log_list:\n        mute_status = True\n    else:\n        mute_status = False\n\n    if 'kick' in events_log_list:\n        kick_status = True\n    else:\n        kick_status = False\n\n    if 'ban' in events_log_list:\n        ban_status = True\n    else:\n        ban_status = False\n\n    select_options = [\n        StringSelectOption(label=\"Warn\", value=\"warn\", default=warn_status),\n        StringSelectOption(label=\"Mute\", value=\"mute\", default=mute_status),\n        StringSelectOption(label=\"Kick\", value=\"kick\", default=kick_status),\n        StringSelectOption(label=\"Ban\", value=\"ban\", default=ban_status)\n    ]\n\n    select_menu = StringSelectMenu(select_options, min_values=0, max_values=2)\n\n    message = await ctx.send('Configure to what automod reacts to:', components=select_menu)\n\n    while True:\n        try:\n            select = await self.bot.wait_for_component(components=select_menu, timeout=120)\n        except asyncio.TimeoutError:\n            await message.edit('Config closed due to 2 minutes of inactivity.', components=[])\n        else:\n            values = ','.join(select.ctx.values)\n            settings.phishing.violation_punishment = values\n            await settings.save()\n</code></pre>"},{"location":"automod/#extentions.automod.AutoMod.banned_names_manage","title":"<code>banned_names_manage(ctx)</code>  <code>async</code>","text":"<p>/banned_names manage</p> Description <p>Manage banned names.</p> Usage <p>Use the command to get a muodal menu for configuration. Config will be saved on modal submit. Config time limit is 10 minutes.</p> Source code in <code>extentions/automod.py</code> <pre><code>@BannedNames.subcommand(sub_cmd_name='manage', sub_cmd_description='Manage banned names')\nasync def banned_names_manage(self, ctx:InteractionContext):\n\"\"\"\n    /banned_names manage\n    Description:\n        Manage banned names.\n    Usage:\n        Use the command to get a muodal menu for configuration. Config will be saved on modal submit. Config time limit is 10 minutes.\n    \"\"\"\n    bn = await db.bannedNames.find_one({'guild':ctx.guild.id})\n    settings = await db.amConfig.find_one({\"guild\":ctx.guild_id})\n    if settings.banned_names.violation_count is None:\n        bw_vc_pf = MISSING\n    else:\n        bw_vc_pf = settings.banned_names.violation_count\n\n    if bn is None:\n        exact_prefill = MISSING\n        defname_prefill = MISSING\n    else:\n        if bn.names is None:\n            exact_prefill = MISSING\n        else:\n            exact_prefill = ','.join(bn.names)\n        if bn.default_name is None:\n            defname_prefill = MISSING\n        else:\n            defname_prefill = bn.default_name\n    m = Modal(title='Configure the automatic moderation', components=[\n        InputText(\n            label=\"Banned Names\",\n            style=TextStyles.PARAGRAPH,\n            custom_id=f'exact_match',\n            placeholder='Words, seperated by a comma(,). They should have minimum 3 characters.',\n            value=exact_prefill,\n            required=False\n        ),\n        InputText(\n            label=\"Fallback Name\",\n            style=TextStyles.SHORT,\n            custom_id=f'defname',\n            placeholder=\"One name that will be act as a fallback\",\n            value=defname_prefill,\n            required=True,\n            max_length=32,\n            min_length=2\n        ),\n        InputText(\n            label=\"Violation Count\",\n            style=TextStyles.SHORT,\n            custom_id=f'bw_vc',\n            placeholder=\"Must be between 0-10.\",\n            value=bw_vc_pf,\n            required=False\n        )\n    ],custom_id=f'{ctx.author.id}_automod_config_modal')\n\n    await ctx.send_modal(modal=m)\n    try:\n        modal_recived: ModalContext = await self.bot.wait_for_modal(modal=m, author=ctx.author.id, timeout=600)\n    except asyncio.TimeoutError:\n        return await modal_recived.send(f\":x: Uh oh, {ctx.author.mention}! You took longer than 10 minutes to respond to this \", ephemeral=True)\n\n    em_words = modal_recived.responses.get('exact_match')\n    defName = modal_recived.responses.get('defname')\n\n    bw_vc_response = modal_recived.responses.get('bw_vc')\n    if (bw_vc_response == '') or (bw_vc_response is None):\n        bw_vc_response = None\n    elif (get_num(bw_vc_response) &gt; 10) or (get_num(bw_vc_response) &lt; 0):\n        await modal_recived.send(f\"{bw_vc_response} is not a valid violation count. Violation count has to be between 0-10.\")\n\n    settings.banned_names.violation_count = get_num(bw_vc_response)\n    await settings.save()\n\n    if bn is None:\n        await db.bannedNames(guild=ctx.guild_id, names=em_words.split(','), default_name=defName).insert()\n    else:\n        bn.default_name = defName\n        bn.names = em_words.split(',')\n        await bn.save()\n\n    embed=Embed(color=0xffcc50,\n    description=f'**Current banned names:**\\n{em_words}\\n**Violation count:** {bw_vc_response}')\n    await modal_recived.send(embed=embed)\n</code></pre>"},{"location":"automod/#extentions.automod.AutoMod.banned_names_punishments","title":"<code>banned_names_punishments(ctx)</code>  <code>async</code>","text":"<p>/banned_names punishments</p> Description <p>Configure what punishments will Melody give out.</p> Usage <p>There are no parameters in this command, you just have to use it, and it will send you a configuration selection menu. Selections are automatically saved. Config time limit is 2 minutes.</p> Source code in <code>extentions/automod.py</code> <pre><code>@BannedNames.subcommand('punishments', sub_cmd_description='What punishments to use?')\nasync def banned_names_punishments(self, ctx: InteractionContext):\n\"\"\"\n    /banned_names punishments\n    Description:\n        Configure what punishments will Melody give out.\n    Usage:\n        There are no parameters in this command, you just have to use it, and it will send you a configuration selection menu. Selections are automatically saved. Config time limit is 2 minutes.\n    \"\"\"\n    settings = await db.amConfig.find_one({'guildid':ctx.guild_id})\n    if settings.banned_names.violation_punishment is None:\n        events_log_list = ''\n    else:\n        events_log_list = settings.banned_names.violation_punishment\n\n    if 'warn' in events_log_list:\n        warn_status = True\n    else:\n        warn_status = False\n\n    if 'mute' in events_log_list:\n        mute_status = True\n    else:\n        mute_status = False\n\n    if 'kick' in events_log_list:\n        kick_status = True\n    else:\n        kick_status = False\n\n    if 'ban' in events_log_list:\n        ban_status = True\n    else:\n        ban_status = False\n\n    select_options = [\n        StringSelectOption(label=\"Warn\", value=\"warn\", default=warn_status),\n        StringSelectOption(label=\"Mute\", value=\"mute\", default=mute_status),\n        StringSelectOption(label=\"Kick\", value=\"kick\", default=kick_status),\n        StringSelectOption(label=\"Ban\", value=\"ban\", default=ban_status)\n    ]\n\n    select_menu = StringSelectMenu(select_options, min_values=0, max_values=2)\n\n    message = await ctx.send('Configure to what automod reacts to:', components=select_menu)\n\n    while True:\n        try:\n            select = await self.bot.wait_for_component(components=select_menu, timeout=120)\n        except asyncio.TimeoutError:\n            await message.edit('Config closed due to 2 minutes of inactivity.', components=[])\n        else:\n            values = ','.join(select.ctx.values)\n            settings.banned_names.violation_punishment = values\n            await settings.save()\n</code></pre>"},{"location":"automod/#extentions.automod.AutoMod.automod_events","title":"<code>automod_events(ctx)</code>  <code>async</code>","text":"<p>/automod listen_to_events</p> Description <p>Configure what AutoMod events will Melody listen to in the server.</p> Usage <p>There are no parameters in this command, you just have to use it, and it will send you a configuration selection menu. Selections are automatically saved. Config time limit is 2 minutes.</p> Source code in <code>extentions/automod.py</code> <pre><code>@AutoModSettings.subcommand(sub_cmd_name='listen_to_events', sub_cmd_description='Activate parts of the automod')\nasync def automod_events(self, ctx: InteractionContext):\n\"\"\"\n    /automod listen_to_events\n    Description:\n        Configure what AutoMod events will Melody listen to in the server.\n    Usage:\n        There are no parameters in this command, you just have to use it, and it will send you a configuration selection menu. Selections are automatically saved. Config time limit is 2 minutes.\n    \"\"\"\n    await ctx.defer(ephemeral=True)\n    events = await db.amConfig.find_one({'guildid':ctx.guild_id})\n    if events.active_events is None:\n        events_log_list = []\n    else:\n        events_log_list = events.active_events\n    if 'banned_names' in events_log_list:\n        bn_status = True\n    else:\n        bn_status = False\n\n    if 'phishing_filter' in events_log_list:\n        pf_status = True\n    else:\n        pf_status = False\n\n    select_options = [\n        StringSelectOption(label=\"Banned Names\", value=\"banned_names\", default=bn_status),\n        StringSelectOption(label=\"phishing_filter\", value=\"phishing_filter\", default=pf_status),\n    ]\n\n    select_menu = StringSelectMenu(select_options, min_values=0, max_values=2)\n\n    message = await ctx.send('Configure to what automod reacts to:', components=select_menu)\n\n    while True:\n        try:\n            select = await self.bot.wait_for_component(components=select_menu, timeout=120)\n        except asyncio.TimeoutError:\n            await message.edit('Config closed due to 2 minutes of inactivity.', components=[])\n        else:\n            events.active_events = select.ctx.values\n            await events.save()\n</code></pre>"},{"location":"automod/#extentions.automod.AutoMod.automod_ban_mute_times","title":"<code>automod_ban_mute_times(ctx, bantime=0, mutetime=0)</code>  <code>async</code>","text":"<p>/automod ban_mute_times</p> Description <p>Configure the temp ban and mute times Melody will use in automod.</p> <p>Parameters:</p> Name Type Description Default <code>bantime</code> <code>int</code> <p>tempban time, examples: 10 S, 10 M, 10 H, 10 D\" Defaults to 0.</p> <code>0</code> <code>mutetime</code> <code>int</code> <p>mute time, examples: 10 S, 10 M, 10 H, 10 D Defaults to 0.</p> <code>0</code> Source code in <code>extentions/automod.py</code> <pre><code>@AutoModSettings.subcommand(sub_cmd_name='ban_mute_times', sub_cmd_description='Define a ban and mute times.')\n@slash_option(name=\"bantime\", description=\"tempban time, examples: 10 S, 10 M, 10 H, 10 D\", opt_type=OptionType.INTEGER, required=False)\n@slash_option(name=\"mutetime\", description=\"mute time, examples: 10 S, 10 M, 10 H, 10 D\", opt_type=OptionType.INTEGER, required=False)\nasync def automod_ban_mute_times(self, ctx:InteractionContext, bantime:int=0, mutetime:int=0):\n\"\"\"\n    /automod ban_mute_times\n    Description:\n        Configure the temp ban and mute times Melody will use in automod.\n\n    Args:\n        bantime (int, optional): tempban time, examples: 10 S, 10 M, 10 H, 10 D\" Defaults to 0.\n        mutetime (int, optional): mute time, examples: 10 S, 10 M, 10 H, 10 D Defaults to 0.\n    \"\"\"\n    if bantime is not None:\n        bt = await bm_time_to_sec(ctx, bantime)\n    else:\n        bt = bantime\n    if mutetime is not None:\n        mt = await bm_time_to_sec(ctx, mutetime)\n    else:\n        mt = mutetime\n    settings = await db.automod_config.find_one({\"guildid\":ctx.guild_id})\n    settings.ban_time = bt\n    settings.mute_time = mt\n    await settings.save()\n    await ctx.send(f'Ban time: {bantime}\\nMute time: {mutetime}')\n</code></pre>"},{"location":"automod/#extentions.automod.AutoMod.AutomodAddIgnoredChannels","title":"<code>AutomodAddIgnoredChannels(ctx, channel=None)</code>  <code>async</code>","text":"<p>/automod ignored_channel add</p> Description <p>Add a channel to channels ignored by AutoMod.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>OptionType.CHANNEL</code> <p>The channel you want to add. Defaults to channel you're executing the command from.</p> <code>None</code> Source code in <code>extentions/automod.py</code> <pre><code>@AutoModSettings.subcommand('ignored_channel', 'add', 'Add a channel to ignored channels.')\n@channel()\nasync def AutomodAddIgnoredChannels(self, ctx:InteractionContext, channel: OptionType.CHANNEL=None):\n\"\"\"\n    /automod ignored_channel add\n    Description:\n        Add a channel to channels ignored by AutoMod.\n\n    Args:\n        channel (OptionType.CHANNEL, optional): The channel you want to add. Defaults to channel you're executing the command from.\n    \"\"\"\n    await ctx.defer(ephemeral=True)\n    if channel is None:\n        channel = ctx.channel\n    settings = await db.amConfig.find_one({\"guild\":ctx.guild.id})\n    if settings is None:\n        await db.amConfig(guild=ctx.guild.id, phishing=violation_settings, banned_words=violation_settings, banned_names=violation_settings).insert()\n    ignored_channels = settings.ignored_channels\n    if ignored_channels is None:\n        ignored_channels = list()\n    if channel.id in ignored_channels:\n        await ctx.send(f'{channel.mention} is already ignored.', ephemeral=True)\n    ignored_channels.append(channel.id)\n    await settings.save()\n    channel_mentions = [ctx.guild.get_channel(id) for id in ignored_channels]\n    channel_mentions = [ch.mention for ch in channel_mentions if ch is not None]\n    channel_mentions = ' '.join(channel_mentions)\n    embed = Embed(description=f\"Channel {channel.mention} set to be ignored.\")\n    embed.add_field('Ignored Channels', channel_mentions)\n    await ctx.send(embed=embed, ephemeral=True)\n</code></pre>"},{"location":"automod/#extentions.automod.AutoMod.AutomodRemoveIgnoredChannels","title":"<code>AutomodRemoveIgnoredChannels(ctx, channel=None)</code>  <code>async</code>","text":"<p>/automod ignored_channel remove</p> Description <p>Remove a channel from channels ignored by AutoMod.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>OptionType.CHANNEL</code> <p>The channel you want to remove. Defaults to channel you're executing the command from.</p> <code>None</code> Source code in <code>extentions/automod.py</code> <pre><code>@AutoModSettings.subcommand('ignored_channel', 'remove', 'Remove a channel from ignored channels.')\n@channel()\nasync def AutomodRemoveIgnoredChannels(self, ctx:InteractionContext, channel: OptionType.CHANNEL=None):\n\"\"\"\n    /automod ignored_channel remove\n    Description:\n        Remove a channel from channels ignored by AutoMod.\n\n    Args:\n        channel (OptionType.CHANNEL, optional): The channel you want to remove. Defaults to channel you're executing the command from.\n    \"\"\"\n    await ctx.defer(ephemeral=True)\n    if channel is None:\n        channel = ctx.channel\n    settings = await db.amConfig.find_one({\"guild\":ctx.guild.id})\n    if settings is None:\n        await db.amConfig(guild=ctx.guild.id, phishing=violation_settings, banned_words=violation_settings, banned_names=violation_settings).insert()\n    ignored_channels = settings.ignored_channels\n    if ignored_channels is None:\n        ignored_channels = list()\n    if channel.id not in ignored_channels:\n        await ctx.send(f'{channel.mention} is not being ignored by automod.', ephemeral=True)\n    ignored_channels.remove(channel.id)\n    await settings.save()\n    channel_mentions = [ctx.guild.get_channel(id) for id in ignored_channels]\n    channel_mentions = [ch.mention for ch in channel_mentions if ch is not None]\n    channel_mentions = ' '.join(channel_mentions)\n    embed = Embed(description=f\"Channel {channel.mention} removed from ignored channels.\")\n    embed.add_field('Ignored Channels', channel_mentions)\n    await ctx.send(embed=embed, ephemeral=True)\n</code></pre>"},{"location":"automod/#extentions.automod.AutoMod.AutomodAddIgnoredRoles","title":"<code>AutomodAddIgnoredRoles(ctx, role)</code>  <code>async</code>","text":"<p>/automod ignored_role add</p> Description <p>Add a role to roles ignored by AutoMod.</p> <p>Parameters:</p> Name Type Description Default <code>role</code> <code>OptionType.ROLE</code> <p>The role you want to add.</p> required Source code in <code>extentions/automod.py</code> <pre><code>@AutoModSettings.subcommand('ignored_role', 'add', 'Make a role to be ignored by automod.')\n@role()\nasync def AutomodAddIgnoredRoles(self, ctx:InteractionContext, role: OptionType.ROLE):\n\"\"\"\n    /automod ignored_role add\n    Description:\n        Add a role to roles ignored by AutoMod.\n\n    Args:\n        role (OptionType.ROLE): The role you want to add.\n    \"\"\"\n    await ctx.defer(ephemeral=True)\n    settings = await db.amConfig.find_one({\"guild\":ctx.guild.id})\n    if settings is None:\n        await db.amConfig(guild=ctx.guild.id, phishing=violation_settings, banned_words=violation_settings, banned_names=violation_settings).insert()\n    ignored_roles = settings.ignored_roles\n    if ignored_roles is None:\n        ignored_roles = list()\n    if role.id in ignored_roles:\n        await ctx.send(f'{role.mention} is already ignored.', ephemeral=True)\n    ignored_roles.append(role.id)\n    await settings.save()\n    role_mentions = [ctx.guild.get_role(id) for id in ignored_roles]\n    role_mentions = [r.mention for r in role_mentions if r is not None]\n    role_mentions = ' '.join(role_mentions)\n    embed = Embed(description=f\"Role {role.mention} was added to roles ignored by automod.\")\n    embed.add_field('Ignored Roles', role_mentions)\n    await ctx.send(embed=embed, ephemeral=True)\n</code></pre>"},{"location":"automod/#extentions.automod.AutoMod.AutomodRemoveIgnoredRoles","title":"<code>AutomodRemoveIgnoredRoles(ctx, role)</code>  <code>async</code>","text":"<p>/automod ignored_role remove</p> Description <p>Remove a role from roles ignored by AutoMod.</p> <p>Parameters:</p> Name Type Description Default <code>role</code> <code>OptionType.ROLE</code> <p>The role you want to remove.</p> required Source code in <code>extentions/automod.py</code> <pre><code>@AutoModSettings.subcommand('ignored_role', 'remove', 'Remove a role from ignored roles.')\n@role()\nasync def AutomodRemoveIgnoredRoles(self, ctx:InteractionContext, role: OptionType.ROLE):\n\"\"\"\n    /automod ignored_role remove\n    Description:\n        Remove a role from roles ignored by AutoMod.\n\n    Args:\n        role (OptionType.ROLE): The role you want to remove.\n    \"\"\"\n    await ctx.defer(ephemeral=True)\n    settings = await db.amConfig.find_one({\"guild\":ctx.guild.id})\n    if settings is None:\n        await db.amConfig(guild=ctx.guild.id, phishing=violation_settings, banned_words=violation_settings, banned_names=violation_settings).insert()\n    ignored_roles = settings.ignored_roles\n    if ignored_roles is None:\n        ignored_roles = list()\n    if role.id not in ignored_roles:\n        await ctx.send(f'{role.mention} is not being ignored by automod.', ephemeral=True)\n    ignored_roles.remove(role.id)\n    await settings.save()\n    role_mentions = [ctx.guild.get_role(id) for id in ignored_roles]\n    role_mentions = [r.mention for r in role_mentions if r is not None]\n    role_mentions = ' '.join(role_mentions)\n    embed = Embed(description=f\"Role {role.mention} was removed from roles ignored by automod.\")\n    embed.add_field('Ignored Roles', role_mentions)\n    await ctx.send(embed=embed, ephemeral=True)\n</code></pre>"},{"location":"automod/#extentions.automod.AutoMod.AutomodAddIgnoredMember","title":"<code>AutomodAddIgnoredMember(ctx, user)</code>  <code>async</code>","text":"<p>/automod ignored_member add</p> Description <p>Add a member to members ignored by AutoMod.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>OptionType.USER</code> <p>member to be ignored by automod</p> required Source code in <code>extentions/automod.py</code> <pre><code>@AutoModSettings.subcommand('ignored_member', 'add', 'Make a member to be ignored by automod.')\n@user()\nasync def AutomodAddIgnoredMember(self, ctx:InteractionContext, user: OptionType.USER):\n\"\"\"\n    /automod ignored_member add\n    Description:\n        Add a member to members ignored by AutoMod.\n\n    Args:\n        user (OptionType.USER): member to be ignored by automod\n    \"\"\"\n    await ctx.defer(ephemeral=True)\n    settings = await db.amConfig.find_one({\"guild\":ctx.guild.id})\n    if settings is None:\n        await db.amConfig(guild=ctx.guild.id, phishing=violation_settings, banned_words=violation_settings, banned_names=violation_settings).insert()\n    ignored_users = settings.ignored_users\n    if ignored_users is None:\n        ignored_users = list()\n    if user.id in ignored_users:\n        await ctx.send(f'{user}|{user.id} is already ignored.', ephemeral=True)\n    ignored_users.append(user.id)\n    await settings.save()\n    users = [ctx.guild.get_member(id) for id in ignored_users]\n    users = [f'{r}({r.id})' for r in users if r is not None]\n    users = ' '.join(users)\n    embed = Embed(description=f\"Member {user}({user.id}) was added to members ignored by automod.\")\n    embed.add_field('Ignored Members', users)\n    await ctx.send(embed=embed, ephemeral=True)\n</code></pre>"},{"location":"automod/#extentions.automod.AutoMod.AutomodRemoveIgnoredMember","title":"<code>AutomodRemoveIgnoredMember(ctx, user)</code>  <code>async</code>","text":"<p>/automod ignored_member remove</p> Description <p>Remove a member from members ignored by AutoMod.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>OptionType.USER</code> <p>member to be removed from ignored members by automod</p> required Source code in <code>extentions/automod.py</code> <pre><code>@AutoModSettings.subcommand('ignored_member', 'remove', 'Remove a member from ignored members.')\n@user()\nasync def AutomodRemoveIgnoredMember(self, ctx:InteractionContext, user: OptionType.USER):\n\"\"\"\n    /automod ignored_member remove\n    Description:\n        Remove a member from members ignored by AutoMod.\n\n    Args:\n        user (OptionType.USER): member to be removed from ignored members by automod\n    \"\"\"\n    await ctx.defer(ephemeral=True)\n    settings = await db.amConfig.find_one({\"guild\":ctx.guild.id})\n    if settings is None:\n       await db.amConfig(guild=ctx.guild.id, phishing=violation_settings, banned_words=violation_settings, banned_names=violation_settings).insert()\n    ignored_users = settings.ignored_users\n    if ignored_users is None:\n        ignored_users = list()\n    if user.id not in ignored_users:\n        await ctx.send(f'{user}|{user.id} is not being ignored by automod.', ephemeral=True)\n    ignored_users.remove(user.id)\n    await settings.save()\n    users = [ctx.guild.get_member(id) for id in ignored_users]\n    users = [f'{r}({r.id})' for r in users if r is not None]\n    users = ' '.join(users)\n    embed = Embed(description=f\"Member {user}({user.id}) was removed from members ignored by automod.\")\n    embed.add_field('Ignored Members', users)\n    await ctx.send(embed=embed, ephemeral=True)\n</code></pre>"},{"location":"basic/","title":"Basic","text":"<p>         Bases: <code>Extension</code></p> Source code in <code>extentions/basic.py</code> <pre><code>class Basic(Extension):\n    def __init__(self, bot: Client):\n        self.bot = bot\n\n    @slash_command(\"echo\", description=\"Echo your messages\")\n    @text()\n    @channel()\n    @check(member_permissions(Permissions.ADMINISTRATOR))\n    async def echo(self, ctx: SlashContext, text: str, channel:OptionType.CHANNEL=None):\n\"\"\"\n        /echo\n        Description:\n            Echo your messages.\n\n        Args:\n            text (str): Text to echo.\n            channel (OptionType.CHANNEL, optional): Channel to echo in, defaults to channel you're executing the command from.\n        \"\"\"\n        if (channel is None):\n            channel = ctx.channel\n        await channel.send(text)\n        message = await ctx.send(f'{ctx.author.mention} message `{text}` in {channel.mention} echoed!', ephemeral=True)\n        #await channel.delete_message(message, 'message for echo command')\n\n    @slash_command(name='userinfo', description=\"Lets you see info about server members\")\n    @member()\n    async def userinfo(self, ctx:SlashContext, member:OptionType.USER=None):\n\"\"\"\n        /userinfo\n        Description:\n            Lets you see info about server members.\n\n        Args:\n            member (OptionType.USER, optional): Member to fetch info about. Defaults to the member executing the command.\n        \"\"\"\n        if member is None:\n            member = ctx.author\n\n        if member.top_role.name != '@everyone':\n            toprole = member.top_role.mention\n        else:\n            toprole = 'None'\n\n        roles = [role.mention for role in member.roles if role.name != '@everyone']\n        rolecount = len(roles)\n        if rolecount == 0:\n            roles = 'None'\n        else:\n            roles = ' '.join(roles)\n\n        if member.top_role.color.value == 0:\n            color = 0xffcc50\n        else:\n            color = member.top_role.color\n\n        cdiff = relativedelta(datetime.now(tz=timezone.utc), member.created_at.replace(tzinfo=timezone.utc))\n        creation_time = f\"{cdiff.years} Y, {cdiff.months} M, {cdiff.days} D\"\n\n        jdiff = relativedelta(datetime.now(tz=timezone.utc), member.joined_at.replace(tzinfo=timezone.utc))\n        join_time = f\"{jdiff.years} Y, {jdiff.months} M, {jdiff.days} D\"\n\n        if member.guild_avatar is not None:\n            avatarurl = f'{member.guild_avatar.url}.png'\n        else:\n            avatarurl = f'{member.avatar.url}.png'\n\n        embed = Embed(color=color,\n                      title=f\"User Info - {member}\")\n        embed.set_thumbnail(url=avatarurl)\n        embed.add_field(name=\"ID(snowflake):\", value=member.id, inline=False)\n        embed.add_field(name=\"Nickname:\", value=member.display_name, inline=False)\n        embed.add_field(name=\"Created account on:\", value=f\"&lt;t:{math.ceil(member.created_at.timestamp())}&gt; `{creation_time} ago`\", inline=False)\n        embed.add_field(name=\"Joined server on:\", value=f\"&lt;t:{math.ceil(member.joined_at.timestamp())}&gt; `{join_time} ago`\", inline=False)\n        embed.add_field(name=f\"Roles: [{rolecount}]\", value=roles, inline=False)\n        embed.add_field(name=\"Highest role:\", value=toprole, inline=False)\n        await ctx.send(embed=embed)\n\n    @slash_command(name='serverinfo', description=\"Lets you see info about the server\")\n    async def serverinfo(self, ctx:SlashContext):\n\"\"\"\n        /serverinfo\n        Description:\n            Lets you see info about the server\n        \"\"\"\n        cdiff = relativedelta(datetime.now(tz=timezone.utc), ctx.guild.created_at.replace(tzinfo=timezone.utc))\n        creation_time = f\"{cdiff.years} Y, {cdiff.months} M, {cdiff.days} D\"\n        owner = await guild_owner(ctx)\n        embed = Embed(title=f\"Server Info\", color=0xffcc50)\n        embed.set_author(name=f'{ctx.guild.name}', icon_url=f'{ctx.guild.icon.url}')\n        embed.set_thumbnail(url=f'{ctx.guild.icon.url}')\n        embed.add_field(name='Server owner', value=f'{owner.mention}', inline=False)\n        embed.add_field(name='Members', value=f'{ctx.guild.member_count}', inline=False)\n        embed.add_field(name=\"Channels:\", value=len(ctx.guild.channels), inline=False)\n        embed.add_field(name=\"Roles:\", value=len(ctx.guild.roles), inline=False)\n        embed.add_field(name='Boost level', value=f'{ctx.guild.premium_tier}[{ctx.guild.premium_subscription_count} boosts]', inline=False)\n        embed.add_field(name='Created at', value=f'&lt;t:{math.ceil(ctx.guild.created_at.timestamp())}&gt; `{creation_time} ago`', inline=False)\n        embed.add_field(name='Region', value=f'{ctx.guild.preferred_locale}', inline=False)\n        embed.add_field(name='ID', value=f'{ctx.guild_id}', inline=True)\n        await ctx.send(embed=embed)\n\n    @slash_command(name='botinfo', description=\"Lets you see info about the bot\")\n    async def botinfo(self, ctx: SlashContext):\n\"\"\"\n        /botinfo\n        Description:\n            Lets you see info about the bot\n        \"\"\"\n        member = ctx.guild.get_member(self.bot.user.id)\n\n        if member.top_role.name != '@everyone':\n            toprole = member.top_role.mention\n        else:\n            toprole = 'None'\n\n        roles = [role.mention for role in member.roles if role.name != '@everyone']\n        rolecount = len(roles)\n        if rolecount == 0:\n            roles = 'None'\n        else:\n            roles = ' '.join(roles)\n\n        if member.top_role.color.value == 0:\n            color = 0xffcc50\n        else:\n            color = member.top_role.color\n\n        cdiff = relativedelta(datetime.now(tz=timezone.utc), member.created_at.replace(tzinfo=timezone.utc))\n        creation_time = f\"{cdiff.years} Y, {cdiff.months} M, {cdiff.days} D\"\n\n        jdiff = relativedelta(datetime.now(tz=timezone.utc), member.joined_at.replace(tzinfo=timezone.utc))\n        join_time = f\"{jdiff.years} Y, {jdiff.months} M, {jdiff.days} D\"\n\n        if member.guild_avatar is not None:\n            avatarurl = f'{member.guild_avatar.url}.png'\n        else:\n            avatarurl = f'{member.avatar.url}.png'\n\n        embed = Embed(color=color,\n                      title=f\"Bot Info - {member}\")\n        embed.set_thumbnail(url=avatarurl)\n        #embed.set_author(name=member, icon_url=member.avatar.url)\n        embed.add_field(name=\"ID(snowflake):\", value=member.id, inline=False)\n        embed.add_field(name=\"Nickname:\", value=member.display_name, inline=False)\n        embed.add_field(name=\"Created account on:\", value=f\"&lt;t:{math.ceil(member.created_at.timestamp())}&gt; `{creation_time} ago`\", inline=False)\n        embed.add_field(name=\"Joined server on:\", value=f\"&lt;t:{math.ceil(member.joined_at.timestamp())}&gt; `{join_time} ago`\", inline=False)\n        embed.add_field(name=f\"Roles: [{rolecount}]\", value=roles, inline=False)\n        embed.add_field(name=\"Highest role:\", value=toprole, inline=False)\n        embed.add_field(name=\"Library:\", value=\"[interactions.py](https://github.com/interactions-py/interactions.py)\")\n        embed.add_field(name=\"Servers:\", value=len(self.bot.user.guilds))\n        embed.add_field(name=\"Bot Latency:\", value=f\"{self.bot.latency * 1000:.0f} ms\")\n        embed.add_field(name='GitHub: https://github.com/siren15/melody', value='\u200e')\n        embed.set_footer(text=\"Melody | powered by i.py\")\n        await ctx.send(embed=embed)\n\n    @slash_command(name='avatar', description=\"Show's you your avatar, or members, if provided\")\n    @member()\n    async def avatar(self, ctx:SlashContext, member:OptionType.USER=None):\n\"\"\"/avatar\n        Description:\n            Show's you your avatar, or members, if provided\n\n        Args:\n            member (OptionType.USER, optional): Member to fetch avatar from. Defaults to member executing the command.\n        \"\"\"\n        if member is None:\n            member = ctx.author\n\n        if member.guild_avatar is not None:\n            avatarurl = member.guild_avatar.url\n        else:\n            avatarurl = member.avatar.url\n\n        embed = Embed(description=member.display_name, color=0xffcc50)\n        embed.set_image(url=avatarurl)\n        await ctx.send(embed=embed)\n\n    @slash_command(name='useravatar', description=\"Show's you your avatar, or users, if provided\")\n    @member()\n    async def useravatar(self, ctx:SlashContext, member:OptionType.USER=None):\n\n        if member is None:\n            member = ctx.author\n\n        avatarurl = member.avatar.url\n\n        embed = Embed(description=member.display_name, color=0xffcc50)\n        embed.set_image(url=avatarurl)\n        await ctx.send(embed=embed)\n\n    @slash_command(name='search', description=\"Search with DuckDuckGo, returns the first result.\")\n    @text()\n    async def duckduckgosearch(self, ctx:SlashContext, text: str):\n\"\"\"/search\n\n        Description:\n            Search with DuckDuckGo, returns the first result.\n\n        Args:\n            text (str): Search query\n        \"\"\"\n        await ctx.defer()\n        results = await duckduckgo.search(text)\n        embed = Embed(\n            title=results[0].title,\n            description=results[0].description,\n            color=0xdb4b26\n        )\n        embed.set_footer(text=results[0].url)\n        await ctx.send(embed=embed)\n\n    @slash_command(name='ping', description=\"Ping! Pong!\")\n    async def ping(self, ctx:SlashContext):\n\"\"\"/ping\n        Description:\n            Get the bot's latency\n        \"\"\"\n        await ctx.send(f\"Pong! \\nBot's latency: {self.bot.latency * 1000} ms\")\n\n    create_embed = SlashCommand(name='embed', description='Create and edit embeds.', default_member_permissions=Permissions.ADMINISTRATOR)\n\n    @create_embed.subcommand(sub_cmd_name='create', sub_cmd_description='Create embeds')\n    async def embed_create(self, ctx:SlashContext):\n\"\"\"/embed create\n        Description:\n            Create embeds. After execution it will show you a modal popup, where you can write your embed. Limit 10 minutes for creation.\n        \"\"\"\n        components=[\n            ShortText(\n                label=\"Embed Title\",\n                custom_id=f'embed_title',\n                required=False\n            ),\n            ParagraphText(\n                label=\"Embed Text\",\n                custom_id=f'embed_text',\n                required=False\n            ),\n            ShortText(\n                label=\"Embed Image\",\n                custom_id=f'embed_image',\n                required=False,\n                placeholder='Image URL'\n            ),\n            ShortText(\n                label=\"Embed Colour\",\n                custom_id=f'embed_colour',\n                required=False,\n                placeholder='Colour HEX code'\n            )\n        ]\n        m = Modal(title='Create an embed', custom_id=f'{ctx.author.id}_embed_modal')\n        m.add_components(components)\n        await ctx.send_modal(m)\n        try:\n            modal_recived: ModalContext = await self.bot.wait_for_modal(modal=m, author=ctx.author.id, timeout=600)\n        except asyncio.TimeoutError:\n            return await ctx.send(f\":x: Uh oh, {ctx.author.mention}! You took longer than 10 minutes to respond.\", ephemeral=True)\n\n        embed_title = modal_recived.responses.get('embed_title')\n        if embed_title is None:\n            embed_title = MISSING\n        embed_text = modal_recived.responses.get('embed_text')\n        if embed_text is None:\n            embed_text = MISSING\n        embed_image = modal_recived.responses.get('embed_image')\n        if embed_image is None:\n            embed_image = MISSING\n        if (embed_title is None) and (embed_text is None):\n            await ctx.send('You must include either embed title or text', ephemeral=True)\n            return\n        embed_colour = modal_recived.responses.get('embed_colour')\n        if embed_colour is None or embed_colour == '':\n            embed_colour = 0xffcc50\n        else:\n            from utils import utils\n            if not utils.is_hex_valid(embed_colour):\n                await modal_recived.send('Colour HEX not valid. Using default embed colour.', ephemeral=True)\n                embed_colour = 0xffcc50\n        embed=Embed(color=embed_colour,\n        description=embed_text,\n        title=embed_title)\n        embed.set_image(embed_image)\n        await modal_recived.send(embed=embed)\n\n    @create_embed.subcommand(sub_cmd_name='edit', sub_cmd_description='Edit embeds')\n    @embed_message_id()\n    @channel()\n    async def embed_edit(self, ctx:SlashContext, embed_message_id:str=None, channel:OptionType.CHANNEL=None):\n\"\"\"/embed edit\n\n        Description:\n            Edit embeds. After execution it will show you a modal popup, where you can write your embed. Limit 10 minutes for editing.\n\n        Args:\n            embed_message_id (str, optional): ID of the message the embed is on.\n            channel (OptionType.CHANNEL, optional): Channel the message is in. Defaults to the channel the command is executed in.\n        \"\"\"\n        if embed_message_id is None:\n            await ctx.send('You have to include the embed message ID, so that I can edit the embed', ephemeral=True)\n            return\n        elif channel is None:\n            channel = ctx.channel\n        m = Modal(title='Create an embed', components=[\n            InputText(\n                label=\"Embed Title\",\n                style=TextStyles.SHORT,\n                custom_id=f'embed_title',\n                required=False\n            ),\n            InputText(\n                label=\"Embed Text\",\n                style=TextStyles.PARAGRAPH,\n                custom_id=f'embed_text',\n                required=False\n            ),\n            InputText(\n                label=\"Embed Image\",\n                style=TextStyles.SHORT,\n                custom_id=f'embed_image',\n                required=False,\n                placeholder='Image URL'\n            ),\n            InputText(\n                label=\"Embed Colour\",\n                style=TextStyles.SHORT,\n                custom_id=f'embed_colour',\n                required=False,\n                placeholder='Colour HEX code'\n            )\n        ],\n        custom_id=f'{ctx.author.id}_embed_modal'\n        )\n\n        await ctx.send_modal(modal=m)\n\n        try:\n            modal_recived: ModalContext = await self.bot.wait_for_modal(modal=m, author=ctx.author.id, timeout=600)\n        except asyncio.TimeoutError:\n            return await ctx.send(f\":x: Uh oh, {ctx.author.mention}! You took longer than 10 minutes to respond.\", ephemeral=True)\n\n        embed_title = modal_recived.responses.get('embed_title')\n        if embed_title is None:\n            embed_title = MISSING\n        embed_text = modal_recived.responses.get('embed_text')\n        if embed_text is None:\n            embed_text = MISSING\n        embed_image = modal_recived.responses.get('embed_image')\n        if embed_image is None:\n            embed_image = MISSING\n        if (embed_title is None) and (embed_text is None):\n            await ctx.send('You must include either embed title or text', ephemeral=True)\n            return\n        embed_colour = modal_recived.responses.get('embed_colour')\n        if embed_colour is None:\n            embed_colour = 0xffcc50\n        else:\n            from utils import utils\n            if not utils.is_hex_valid(embed_colour):\n                await modal_recived.send('Colour HEX not valid. Using default embed colour.', ephemeral=True)\n                embed_colour = 0xffcc50\n        message_to_edit = await channel.fetch_message(embed_message_id)\n        embed=Embed(color=embed_colour,\n        description=embed_text,\n        title=embed_title)\n        embed.set_image(embed_image)\n        await message_to_edit.edit(embed=embed)\n        await modal_recived.send('Message edited', ephemeral=True)\n</code></pre>"},{"location":"basic/#extentions.basic.Basic.echo","title":"<code>echo(ctx, text, channel=None)</code>  <code>async</code>","text":"<p>/echo</p> Description <p>Echo your messages.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text to echo.</p> required <code>channel</code> <code>OptionType.CHANNEL</code> <p>Channel to echo in, defaults to channel you're executing the command from.</p> <code>None</code> Source code in <code>extentions/basic.py</code> <pre><code>@slash_command(\"echo\", description=\"Echo your messages\")\n@text()\n@channel()\n@check(member_permissions(Permissions.ADMINISTRATOR))\nasync def echo(self, ctx: SlashContext, text: str, channel:OptionType.CHANNEL=None):\n\"\"\"\n    /echo\n    Description:\n        Echo your messages.\n\n    Args:\n        text (str): Text to echo.\n        channel (OptionType.CHANNEL, optional): Channel to echo in, defaults to channel you're executing the command from.\n    \"\"\"\n    if (channel is None):\n        channel = ctx.channel\n    await channel.send(text)\n    message = await ctx.send(f'{ctx.author.mention} message `{text}` in {channel.mention} echoed!', ephemeral=True)\n</code></pre>"},{"location":"basic/#extentions.basic.Basic.userinfo","title":"<code>userinfo(ctx, member=None)</code>  <code>async</code>","text":"<p>/userinfo</p> Description <p>Lets you see info about server members.</p> <p>Parameters:</p> Name Type Description Default <code>member</code> <code>OptionType.USER</code> <p>Member to fetch info about. Defaults to the member executing the command.</p> <code>None</code> Source code in <code>extentions/basic.py</code> <pre><code>@slash_command(name='userinfo', description=\"Lets you see info about server members\")\n@member()\nasync def userinfo(self, ctx:SlashContext, member:OptionType.USER=None):\n\"\"\"\n    /userinfo\n    Description:\n        Lets you see info about server members.\n\n    Args:\n        member (OptionType.USER, optional): Member to fetch info about. Defaults to the member executing the command.\n    \"\"\"\n    if member is None:\n        member = ctx.author\n\n    if member.top_role.name != '@everyone':\n        toprole = member.top_role.mention\n    else:\n        toprole = 'None'\n\n    roles = [role.mention for role in member.roles if role.name != '@everyone']\n    rolecount = len(roles)\n    if rolecount == 0:\n        roles = 'None'\n    else:\n        roles = ' '.join(roles)\n\n    if member.top_role.color.value == 0:\n        color = 0xffcc50\n    else:\n        color = member.top_role.color\n\n    cdiff = relativedelta(datetime.now(tz=timezone.utc), member.created_at.replace(tzinfo=timezone.utc))\n    creation_time = f\"{cdiff.years} Y, {cdiff.months} M, {cdiff.days} D\"\n\n    jdiff = relativedelta(datetime.now(tz=timezone.utc), member.joined_at.replace(tzinfo=timezone.utc))\n    join_time = f\"{jdiff.years} Y, {jdiff.months} M, {jdiff.days} D\"\n\n    if member.guild_avatar is not None:\n        avatarurl = f'{member.guild_avatar.url}.png'\n    else:\n        avatarurl = f'{member.avatar.url}.png'\n\n    embed = Embed(color=color,\n                  title=f\"User Info - {member}\")\n    embed.set_thumbnail(url=avatarurl)\n    embed.add_field(name=\"ID(snowflake):\", value=member.id, inline=False)\n    embed.add_field(name=\"Nickname:\", value=member.display_name, inline=False)\n    embed.add_field(name=\"Created account on:\", value=f\"&lt;t:{math.ceil(member.created_at.timestamp())}&gt; `{creation_time} ago`\", inline=False)\n    embed.add_field(name=\"Joined server on:\", value=f\"&lt;t:{math.ceil(member.joined_at.timestamp())}&gt; `{join_time} ago`\", inline=False)\n    embed.add_field(name=f\"Roles: [{rolecount}]\", value=roles, inline=False)\n    embed.add_field(name=\"Highest role:\", value=toprole, inline=False)\n    await ctx.send(embed=embed)\n</code></pre>"},{"location":"basic/#extentions.basic.Basic.serverinfo","title":"<code>serverinfo(ctx)</code>  <code>async</code>","text":"<p>/serverinfo</p> Description <p>Lets you see info about the server</p> Source code in <code>extentions/basic.py</code> <pre><code>@slash_command(name='serverinfo', description=\"Lets you see info about the server\")\nasync def serverinfo(self, ctx:SlashContext):\n\"\"\"\n    /serverinfo\n    Description:\n        Lets you see info about the server\n    \"\"\"\n    cdiff = relativedelta(datetime.now(tz=timezone.utc), ctx.guild.created_at.replace(tzinfo=timezone.utc))\n    creation_time = f\"{cdiff.years} Y, {cdiff.months} M, {cdiff.days} D\"\n    owner = await guild_owner(ctx)\n    embed = Embed(title=f\"Server Info\", color=0xffcc50)\n    embed.set_author(name=f'{ctx.guild.name}', icon_url=f'{ctx.guild.icon.url}')\n    embed.set_thumbnail(url=f'{ctx.guild.icon.url}')\n    embed.add_field(name='Server owner', value=f'{owner.mention}', inline=False)\n    embed.add_field(name='Members', value=f'{ctx.guild.member_count}', inline=False)\n    embed.add_field(name=\"Channels:\", value=len(ctx.guild.channels), inline=False)\n    embed.add_field(name=\"Roles:\", value=len(ctx.guild.roles), inline=False)\n    embed.add_field(name='Boost level', value=f'{ctx.guild.premium_tier}[{ctx.guild.premium_subscription_count} boosts]', inline=False)\n    embed.add_field(name='Created at', value=f'&lt;t:{math.ceil(ctx.guild.created_at.timestamp())}&gt; `{creation_time} ago`', inline=False)\n    embed.add_field(name='Region', value=f'{ctx.guild.preferred_locale}', inline=False)\n    embed.add_field(name='ID', value=f'{ctx.guild_id}', inline=True)\n    await ctx.send(embed=embed)\n</code></pre>"},{"location":"basic/#extentions.basic.Basic.botinfo","title":"<code>botinfo(ctx)</code>  <code>async</code>","text":"<p>/botinfo</p> Description <p>Lets you see info about the bot</p> Source code in <code>extentions/basic.py</code> <pre><code>@slash_command(name='botinfo', description=\"Lets you see info about the bot\")\nasync def botinfo(self, ctx: SlashContext):\n\"\"\"\n    /botinfo\n    Description:\n        Lets you see info about the bot\n    \"\"\"\n    member = ctx.guild.get_member(self.bot.user.id)\n\n    if member.top_role.name != '@everyone':\n        toprole = member.top_role.mention\n    else:\n        toprole = 'None'\n\n    roles = [role.mention for role in member.roles if role.name != '@everyone']\n    rolecount = len(roles)\n    if rolecount == 0:\n        roles = 'None'\n    else:\n        roles = ' '.join(roles)\n\n    if member.top_role.color.value == 0:\n        color = 0xffcc50\n    else:\n        color = member.top_role.color\n\n    cdiff = relativedelta(datetime.now(tz=timezone.utc), member.created_at.replace(tzinfo=timezone.utc))\n    creation_time = f\"{cdiff.years} Y, {cdiff.months} M, {cdiff.days} D\"\n\n    jdiff = relativedelta(datetime.now(tz=timezone.utc), member.joined_at.replace(tzinfo=timezone.utc))\n    join_time = f\"{jdiff.years} Y, {jdiff.months} M, {jdiff.days} D\"\n\n    if member.guild_avatar is not None:\n        avatarurl = f'{member.guild_avatar.url}.png'\n    else:\n        avatarurl = f'{member.avatar.url}.png'\n\n    embed = Embed(color=color,\n                  title=f\"Bot Info - {member}\")\n    embed.set_thumbnail(url=avatarurl)\n    #embed.set_author(name=member, icon_url=member.avatar.url)\n    embed.add_field(name=\"ID(snowflake):\", value=member.id, inline=False)\n    embed.add_field(name=\"Nickname:\", value=member.display_name, inline=False)\n    embed.add_field(name=\"Created account on:\", value=f\"&lt;t:{math.ceil(member.created_at.timestamp())}&gt; `{creation_time} ago`\", inline=False)\n    embed.add_field(name=\"Joined server on:\", value=f\"&lt;t:{math.ceil(member.joined_at.timestamp())}&gt; `{join_time} ago`\", inline=False)\n    embed.add_field(name=f\"Roles: [{rolecount}]\", value=roles, inline=False)\n    embed.add_field(name=\"Highest role:\", value=toprole, inline=False)\n    embed.add_field(name=\"Library:\", value=\"[interactions.py](https://github.com/interactions-py/interactions.py)\")\n    embed.add_field(name=\"Servers:\", value=len(self.bot.user.guilds))\n    embed.add_field(name=\"Bot Latency:\", value=f\"{self.bot.latency * 1000:.0f} ms\")\n    embed.add_field(name='GitHub: https://github.com/siren15/melody', value='\u200e')\n    embed.set_footer(text=\"Melody | powered by i.py\")\n    await ctx.send(embed=embed)\n</code></pre>"},{"location":"basic/#extentions.basic.Basic.avatar","title":"<code>avatar(ctx, member=None)</code>  <code>async</code>","text":"<p>/avatar</p> Description <p>Show's you your avatar, or members, if provided</p> <p>Parameters:</p> Name Type Description Default <code>member</code> <code>OptionType.USER</code> <p>Member to fetch avatar from. Defaults to member executing the command.</p> <code>None</code> Source code in <code>extentions/basic.py</code> <pre><code>@slash_command(name='avatar', description=\"Show's you your avatar, or members, if provided\")\n@member()\nasync def avatar(self, ctx:SlashContext, member:OptionType.USER=None):\n\"\"\"/avatar\n    Description:\n        Show's you your avatar, or members, if provided\n\n    Args:\n        member (OptionType.USER, optional): Member to fetch avatar from. Defaults to member executing the command.\n    \"\"\"\n    if member is None:\n        member = ctx.author\n\n    if member.guild_avatar is not None:\n        avatarurl = member.guild_avatar.url\n    else:\n        avatarurl = member.avatar.url\n\n    embed = Embed(description=member.display_name, color=0xffcc50)\n    embed.set_image(url=avatarurl)\n    await ctx.send(embed=embed)\n</code></pre>"},{"location":"basic/#extentions.basic.Basic.duckduckgosearch","title":"<code>duckduckgosearch(ctx, text)</code>  <code>async</code>","text":"<p>/search</p> Description <p>Search with DuckDuckGo, returns the first result.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Search query</p> required Source code in <code>extentions/basic.py</code> <pre><code>@slash_command(name='search', description=\"Search with DuckDuckGo, returns the first result.\")\n@text()\nasync def duckduckgosearch(self, ctx:SlashContext, text: str):\n\"\"\"/search\n\n    Description:\n        Search with DuckDuckGo, returns the first result.\n\n    Args:\n        text (str): Search query\n    \"\"\"\n    await ctx.defer()\n    results = await duckduckgo.search(text)\n    embed = Embed(\n        title=results[0].title,\n        description=results[0].description,\n        color=0xdb4b26\n    )\n    embed.set_footer(text=results[0].url)\n    await ctx.send(embed=embed)\n</code></pre>"},{"location":"basic/#extentions.basic.Basic.ping","title":"<code>ping(ctx)</code>  <code>async</code>","text":"<p>/ping</p> Description <p>Get the bot's latency</p> Source code in <code>extentions/basic.py</code> <pre><code>@slash_command(name='ping', description=\"Ping! Pong!\")\nasync def ping(self, ctx:SlashContext):\n\"\"\"/ping\n    Description:\n        Get the bot's latency\n    \"\"\"\n    await ctx.send(f\"Pong! \\nBot's latency: {self.bot.latency * 1000} ms\")\n</code></pre>"},{"location":"basic/#extentions.basic.Basic.embed_create","title":"<code>embed_create(ctx)</code>  <code>async</code>","text":"<p>/embed create</p> Description <p>Create embeds. After execution it will show you a modal popup, where you can write your embed. Limit 10 minutes for creation.</p> Source code in <code>extentions/basic.py</code> <pre><code>@create_embed.subcommand(sub_cmd_name='create', sub_cmd_description='Create embeds')\nasync def embed_create(self, ctx:SlashContext):\n\"\"\"/embed create\n    Description:\n        Create embeds. After execution it will show you a modal popup, where you can write your embed. Limit 10 minutes for creation.\n    \"\"\"\n    components=[\n        ShortText(\n            label=\"Embed Title\",\n            custom_id=f'embed_title',\n            required=False\n        ),\n        ParagraphText(\n            label=\"Embed Text\",\n            custom_id=f'embed_text',\n            required=False\n        ),\n        ShortText(\n            label=\"Embed Image\",\n            custom_id=f'embed_image',\n            required=False,\n            placeholder='Image URL'\n        ),\n        ShortText(\n            label=\"Embed Colour\",\n            custom_id=f'embed_colour',\n            required=False,\n            placeholder='Colour HEX code'\n        )\n    ]\n    m = Modal(title='Create an embed', custom_id=f'{ctx.author.id}_embed_modal')\n    m.add_components(components)\n    await ctx.send_modal(m)\n    try:\n        modal_recived: ModalContext = await self.bot.wait_for_modal(modal=m, author=ctx.author.id, timeout=600)\n    except asyncio.TimeoutError:\n        return await ctx.send(f\":x: Uh oh, {ctx.author.mention}! You took longer than 10 minutes to respond.\", ephemeral=True)\n\n    embed_title = modal_recived.responses.get('embed_title')\n    if embed_title is None:\n        embed_title = MISSING\n    embed_text = modal_recived.responses.get('embed_text')\n    if embed_text is None:\n        embed_text = MISSING\n    embed_image = modal_recived.responses.get('embed_image')\n    if embed_image is None:\n        embed_image = MISSING\n    if (embed_title is None) and (embed_text is None):\n        await ctx.send('You must include either embed title or text', ephemeral=True)\n        return\n    embed_colour = modal_recived.responses.get('embed_colour')\n    if embed_colour is None or embed_colour == '':\n        embed_colour = 0xffcc50\n    else:\n        from utils import utils\n        if not utils.is_hex_valid(embed_colour):\n            await modal_recived.send('Colour HEX not valid. Using default embed colour.', ephemeral=True)\n            embed_colour = 0xffcc50\n    embed=Embed(color=embed_colour,\n    description=embed_text,\n    title=embed_title)\n    embed.set_image(embed_image)\n    await modal_recived.send(embed=embed)\n</code></pre>"},{"location":"basic/#extentions.basic.Basic.embed_edit","title":"<code>embed_edit(ctx, embed_message_id=None, channel=None)</code>  <code>async</code>","text":"<p>/embed edit</p> Description <p>Edit embeds. After execution it will show you a modal popup, where you can write your embed. Limit 10 minutes for editing.</p> <p>Parameters:</p> Name Type Description Default <code>embed_message_id</code> <code>str</code> <p>ID of the message the embed is on.</p> <code>None</code> <code>channel</code> <code>OptionType.CHANNEL</code> <p>Channel the message is in. Defaults to the channel the command is executed in.</p> <code>None</code> Source code in <code>extentions/basic.py</code> <pre><code>@create_embed.subcommand(sub_cmd_name='edit', sub_cmd_description='Edit embeds')\n@embed_message_id()\n@channel()\nasync def embed_edit(self, ctx:SlashContext, embed_message_id:str=None, channel:OptionType.CHANNEL=None):\n\"\"\"/embed edit\n\n    Description:\n        Edit embeds. After execution it will show you a modal popup, where you can write your embed. Limit 10 minutes for editing.\n\n    Args:\n        embed_message_id (str, optional): ID of the message the embed is on.\n        channel (OptionType.CHANNEL, optional): Channel the message is in. Defaults to the channel the command is executed in.\n    \"\"\"\n    if embed_message_id is None:\n        await ctx.send('You have to include the embed message ID, so that I can edit the embed', ephemeral=True)\n        return\n    elif channel is None:\n        channel = ctx.channel\n    m = Modal(title='Create an embed', components=[\n        InputText(\n            label=\"Embed Title\",\n            style=TextStyles.SHORT,\n            custom_id=f'embed_title',\n            required=False\n        ),\n        InputText(\n            label=\"Embed Text\",\n            style=TextStyles.PARAGRAPH,\n            custom_id=f'embed_text',\n            required=False\n        ),\n        InputText(\n            label=\"Embed Image\",\n            style=TextStyles.SHORT,\n            custom_id=f'embed_image',\n            required=False,\n            placeholder='Image URL'\n        ),\n        InputText(\n            label=\"Embed Colour\",\n            style=TextStyles.SHORT,\n            custom_id=f'embed_colour',\n            required=False,\n            placeholder='Colour HEX code'\n        )\n    ],\n    custom_id=f'{ctx.author.id}_embed_modal'\n    )\n\n    await ctx.send_modal(modal=m)\n\n    try:\n        modal_recived: ModalContext = await self.bot.wait_for_modal(modal=m, author=ctx.author.id, timeout=600)\n    except asyncio.TimeoutError:\n        return await ctx.send(f\":x: Uh oh, {ctx.author.mention}! You took longer than 10 minutes to respond.\", ephemeral=True)\n\n    embed_title = modal_recived.responses.get('embed_title')\n    if embed_title is None:\n        embed_title = MISSING\n    embed_text = modal_recived.responses.get('embed_text')\n    if embed_text is None:\n        embed_text = MISSING\n    embed_image = modal_recived.responses.get('embed_image')\n    if embed_image is None:\n        embed_image = MISSING\n    if (embed_title is None) and (embed_text is None):\n        await ctx.send('You must include either embed title or text', ephemeral=True)\n        return\n    embed_colour = modal_recived.responses.get('embed_colour')\n    if embed_colour is None:\n        embed_colour = 0xffcc50\n    else:\n        from utils import utils\n        if not utils.is_hex_valid(embed_colour):\n            await modal_recived.send('Colour HEX not valid. Using default embed colour.', ephemeral=True)\n            embed_colour = 0xffcc50\n    message_to_edit = await channel.fetch_message(embed_message_id)\n    embed=Embed(color=embed_colour,\n    description=embed_text,\n    title=embed_title)\n    embed.set_image(embed_image)\n    await message_to_edit.edit(embed=embed)\n    await modal_recived.send('Message edited', ephemeral=True)\n</code></pre>"},{"location":"buttonroles/","title":"Buttonroles","text":"<p>         Bases: <code>Extension</code></p> Source code in <code>extentions/buttonroles.py</code> <pre><code>class ButtonRoles(Extension):\n    def __init__(self, bot: Client):\n        self.bot = bot\n\n    role_buttons = SlashCommand(name='rolebuttons', description='Manage role buttons.', default_member_permissions=Permissions.ADMINISTRATOR)\n\n    @role_buttons.subcommand(sub_cmd_name='create', sub_cmd_description=\"Add role buttons to a message\")\n    @slash_option(name='roles', description='Roles, seperated by a comma(,)', opt_type=OptionType.STRING, required=True)\n    @slash_option(name='message_id', description='Paste in a message ID', opt_type=OptionType.STRING, required=True)\n    @slash_option(name='channel', description='Select a channel', opt_type=OptionType.CHANNEL, channel_types=[ChannelType.GUILD_TEXT], required=False)\n    @slash_option(name=\"button_colours\", description=\"Choose what colour the button will be. Default: Blurple\", required=False, opt_type=OptionType.INTEGER,\n    choices=[SlashCommandChoice(name=\"Blurple\", value=1), SlashCommandChoice(name=\"Green\", value=3), SlashCommandChoice(name=\"Red\", value=4), SlashCommandChoice(name=\"Gray\", value=2)])\n    @slash_option(name=\"mode\", description=\"Choose the mode this set of buttons will be in. Default: Click to get/remove a role\", required=False, opt_type=OptionType.INTEGER,\n    choices=[SlashCommandChoice(name=\"Get or remove a role\", value=1),SlashCommandChoice(name=\"Get a role, no removing\", value=2),SlashCommandChoice(name=\"Only one role allowed\", value=3)])\n    async def role_buttons_add(self, ctx: SlashContext, roles: str, message_id: OptionType.STRING, channel: ChannelType.GUILD_TEXT=None, button_colours: OptionType.INTEGER = 1, mode: OptionType.INTEGER=1):\n\"\"\"/rolebuttons create\n        Description:\n            Add role buttons to a message.\n\n        Args:\n            roles (str): Role IDs or @roles, sperated by comma `,` | the roles you want to create role buttons from. There can't be more than 25 roles/buttons on one message.\n            message_id (OptionType.STRING): Message ID you want the role buttons on, it has to be a message sent by Melody.\n            channel (ChannelType.GUILD_TEXT, optional): Channel the message is in. Defaults to channel command is executed in.\n            button_colours (OptionType.INTEGER, optional): The colour you want the buttons to be. Defaults to Blurple.\n            mode (OptionType.INTEGER, optional): Mode you want buttons to be in. Defaults to 1. Modes: 1 = get or remove the role, 2 = get a role - not possible to remove the role, 3 = only one role allowed from the message\n        \"\"\"\n        await ctx.defer()\n        # modes: 1 = get or remove the role, 2 = get a role - not possible to remove the role, 3 = only one role allowed from the message\n        if channel is None:\n            channel = ctx.channel\n        message: Message = await channel.fetch_message(message_id)\n        if message is not None:\n            components = []\n            if message.components != []:\n                for ob in message.components:\n                    components = components + ob.components\n            documents = []\n            messages = []\n\n            if button_colours == 1:\n                button_colour = ButtonStyle.BLURPLE\n            elif button_colours == 3:\n                button_colour = ButtonStyle.GREEN\n            elif button_colours == 4:\n                button_colour = ButtonStyle.RED\n            elif button_colours == 2:\n                button_colour = ButtonStyle.GRAY\n\n            raw_roles_list = roles.split(',')\n            roles_ids = []\n            for r in raw_roles_list:\n                r = r.replace('&lt;', '')\n                r = r.replace('@', '')\n                r = r.replace('!', '')\n                r = r.replace('&amp;', '')\n                r = r.replace('&gt;', '')\n                roles_ids.append(r)\n            for role_id in roles_ids:\n                role = ctx.guild.get_role(role_id)\n                if role is not None:\n                    button_id = await button_id_generator(ctx, channel, message)\n                    components.append(Button(style=button_colour,label=f\"{role.name}\",custom_id=button_id))\n                    messages.append(f\"Button for role {role.mention} was added.\\nButton ID: `{button_id}`\\nMode: {mode}\")\n                    documents.append(db.button_roles(guildid=ctx.guild_id, button_id=button_id, channelid=channel.id, msg_id=message.id, roleid=role.id, mode=mode))\n\n            if len(components) &gt; 25:\n                return await ctx.send(\"There can't be more than 25 components on one message\")\n\n            rows = spread_to_rows(*components)\n\n            await db.button_roles.insert_many(documents)\n            await message.edit(components=rows)\n            for m in messages:\n                await ctx.send(embed=Embed(color=0xffcc50, description=m))\n        else:\n            return await ctx.send(\"Message not found.\")\n\n    @role_buttons.subcommand(sub_cmd_name='edit', sub_cmd_description=\"Edit the behaviour of a role button\")\n    @message_id()\n    @button_id()\n    @channel()\n    @slash_option(name=\"mode\",description=\"Choose the mode this set of buttons will be in. Default: Click to get/remove a role\",required=False,opt_type=OptionType.INTEGER,\n    choices=[SlashCommandChoice(name=\"Get or remove a role\", value=1),SlashCommandChoice(name=\"Get a role, no removing\", value=2),SlashCommandChoice(name=\"Only one role allowed\", value=3)])\n    @new_role()\n    @slash_option(name=\"button_colours\",description=\"Choose what colour the button will be. Default: Blurple\",required=False,opt_type=OptionType.INTEGER,\n    choices=[SlashCommandChoice(name=\"Blurple\", value=1),SlashCommandChoice(name=\"Green\", value=3),SlashCommandChoice(name=\"Red\", value=4),SlashCommandChoice(name=\"Gray\", value=2)])\n    @slash_option(name=\"requirement_role\",description=\"Choose a role. Members will be required to have this role to use the button.\",required=False,opt_type=OptionType.ROLE)\n    @slash_option(name=\"ignore_role\",description=\"Choose a role. Members with this role will be ignored.\",required=False,opt_type=OptionType.ROLE)\n    @slash_option(name='name', description='Give the button a custom name', opt_type=OptionType.STRING, required=False)\n    async def role_buttons_edit(self, ctx: InteractionContext, message_id:OptionType.STRING, button_id:OptionType.STRING, channel:OptionType.CHANNEL=None, mode:OptionType.INTEGER=None,\n    button_colours:OptionType.INTEGER=None, new_role: OptionType.ROLE = None, requirement_role: OptionType.ROLE = None, ignore_role: OptionType.ROLE = None, name: OptionType.STRING=None):\n\"\"\"/rolebuttons edit\n        Description:\n            Edit the behaviour of a role button. `Name`, `Button colour` and `New Role` can't be edited together.\n\n        Args:\n            message_id (OptionType.STRING): Message ID the role button is on.\n            button_id (OptionType.STRING): Button ID of the button you want to modify.\n            channel (OptionType.CHANNEL, optional): Channel the message is in. Defaults to channel command is executed in.\n            mode (OptionType.INTEGER, optional): Mode you want buttons to be in. Modes: 1 = get or remove the role, 2 = get a role - not possible to remove the role, 3 = only one role allowed from the message\n            button_colours (OptionType.INTEGER, optional): _description_. The colour you want the buttons to be.\n            new_role (OptionType.ROLE, optional): The new role you want on the button.\n            requirement_role (OptionType.ROLE, optional): Choose a role. Members will be required to have this role to use the button.\n            ignore_role (OptionType.ROLE, optional): Choose a role. Members with this role will be ignored.\n            name (OptionType.STRING, optional): Change the button name.\n        \"\"\"\n        await ctx.defer()\n        if button_colours == 1:\n            button_colour = ButtonStyle.BLURPLE\n            colour = 'Blurple'\n        elif button_colours == 3:\n            button_colour = ButtonStyle.GREEN\n            colour = 'Green'\n        elif button_colours == 4:\n            button_colour = ButtonStyle.RED\n            colour = 'Red'\n        elif button_colours == 2:\n            button_colour = ButtonStyle.GRAY\n            colour = 'Gray'\n        if (mode is None) and (button_colours is None) and (new_role is None) and (requirement_role is None) and (ignore_role is None) and (name is None):\n            return await ctx.send('You have to change at least one option to change')\n        if channel is None:\n            channel = ctx.channel\n        edits = ''\n        message = await channel.fetch_message(message_id)\n        if message is not None:\n            if (button_colours is not None) and (new_role is not None) and (name is not None):\n                return await ctx.send(\"`Name`, `Button colour` and `New Role` can't be edited together\")\n            if button_colours is not None:\n                    if message.components != []:\n                        components = []\n                        for ob in message.components:\n                            components.append(ob.components)\n\n                        for l in components:\n                            for b in l:\n                                if b.custom_id == button_id:\n                                    for p in [(i, l.index(b)) for i, l in enumerate(components) if b in l]:\n                                        p1, p2 = p\n\n                        message.components[p1].components[p2].style = button_colour\n                        await message.edit(components=message.components)    \n                        edits = edits + f\"New colour: {colour}\\n\"\n            button = await db.button_roles.find_one({'guildid':ctx.guild_id, 'channelid':channel.id, 'msg_id':message.id, 'button_id':button_id})\n            if mode is not None:\n                button.mode = mode\n                await button.save()\n                if mode == 1:\n                    button_mode = 'Get or remove a role'\n                elif mode == 2:\n                    button_mode = 'Get a role, no removing'\n                elif mode == 3:\n                    button_mode = 'Only one role allowed'\n                edits = edits + f\"New Mode: {button_mode}\\n\"\n            if name is not None:\n                if message.components != []:\n                    components = []\n                    for ob in message.components:\n                        components.append(ob.components)\n\n                    for l in components:\n                        for b in l:\n                            if b.custom_id == button_id:\n                                for p in [(i, l.index(b)) for i, l in enumerate(components) if b in l]:\n                                    p1, p2 = p\n                    message.components[p1].components[p2].label = name\n                    await message.edit(components=message.components)\n                edits = edits + f\"New Name: {name}\\n\"\n            if new_role is not None:\n                button.roleid = new_role.id\n                await button.save()\n                if message.components != []:\n                    components = []\n                    for ob in message.components:\n                        components.append(ob.components)\n\n                    for l in components:\n                        for b in l:\n                            if b.custom_id == button_id:\n                                for p in [(i, l.index(b)) for i, l in enumerate(components) if b in l]:\n                                    p1, p2 = p\n                    if name is not None:\n                        bname = name\n                    elif name is None:\n                        bname = new_role.name\n                    message.components[p1].components[p2].label = bname\n                    await message.edit(components=message.components)\n                edits = edits + f\"New Role: {new_role.mention}\\n\"\n            if requirement_role is not None:\n                if button.requirement_roles is not None:\n                    button.requirement_roles.append(requirement_role.id)\n                    await button.save()\n                else:\n                    button.requirement_roles = [requirement_role.id]\n                    await button.save()\n                edits = edits + f\"Requirement Role: {requirement_role.mention}\\n\"\n            if ignore_role is not None:\n                if button.ignored_roles is not None:\n                    button.ignored_roles.append(ignore_role.id)\n                    await button.save()\n                else:\n                    button.ignored_roles = [ignore_role.id]\n                    button.save()\n                edits = edits + f\"Ignore Role: {ignore_role.mention}\\n\"\n            await ctx.send(embed=Embed(color=0xffcc50,description=f\"Button `{button_id}` succesfully edited\\n{edits}\"))\n        else:\n            await ctx.send('Message not found')\n\n    @role_buttons.subcommand(sub_cmd_name='remove', sub_cmd_description=\"Remove a role button\")\n    @button_id()\n    @message_id()\n    @channel()\n    async def role_buttons_remove(self, ctx: InteractionContext, message_id:OptionType.STRING, button_id:OptionType.STRING, channel:OptionType.CHANNEL=None):\n\"\"\"/rolebuttons remove\n        Description:\n            Delete a role button from a message.\n\n        Args:\n            message_id (OptionType.STRING): Message ID the button is on.\n            button_id (OptionType.STRING): The button ID, of the button you want to delete.\n            channel (OptionType.CHANNEL, optional): Channel the message is in. Defaults to channel command is executed in.\n        \"\"\"\n        await ctx.defer()\n        if channel is None:\n            channel = ctx.channel\n        message: Message = await channel.fetch_message(message_id)\n        if message is None:\n            return await ctx.send(f\"Can't find a message with that id\", ephemeral=True)\n        components = []\n        if message.components != []:\n            for ob in message.components:\n                components = components + ob.components\n\n        for b in components:\n            if b.custom_id == button_id:\n                components.remove(b)\n\n        rows = spread_to_rows(*components)\n\n        await message.edit(components=rows)\n\n        button = await db.button_roles.find_one({'guildid':ctx.guild_id, 'channelid':channel.id, 'msg_id':message.id, 'button_id':button_id})\n        await button.delete()\n        await ctx.send(f\"Button `{button_id}` successfully deleted\")\n\n    @role_buttons.subcommand(sub_cmd_name='list', sub_cmd_description=\"List all role buttons on this server\")\n    async def role_buttons_list(self, ctx: InteractionContext):\n\"\"\"/rolebuttons list\n\n        Description:\n            List all the role buttons, and their info.\n        \"\"\"\n        await ctx.defer()\n        from interactions.ext.paginators import Paginator\n        def chunks(l, n):\n            n = max(1, n)\n            return (l[i:i+n] for i in range(0, len(l), n))\n\n        def mlis(lst, s, e):\n            nc = list(chunks(lst, 10))\n            mc = ''\n            for testlist in nc[s:e]:\n                for m in testlist:\n                    mc = mc + m\n            return mc\n\n        def newpage(title, buttoninfo):\n            embed = Embed(title=title,\n            description=buttoninfo,\n            color=0xffcc50)\n            return embed\n\n        role_buttons = db.button_roles.find({'guildid':ctx.guild_id})\n\n        buttons = []\n        async for button in role_buttons:\n            role = ctx.guild.get_role(button.roleid)\n            if role is None:\n                role = 'Role missing'\n            elif role is not None:\n                role = role.mention\n            if button.requirement_roles is not None:\n                req_role = ' '.join([ctx.guild.get_role(id).mention for id in button.requirement_roles])\n                if req_role == '':\n                    reqrole = 'Req. role missing'\n            else:\n                reqrole = 'No req. role'\n            if button.ignored_roles is not None:\n                ign_role = ' '.join([ctx.guild.get_role(id).mention for id in button.ignored_roles])\n                if ign_role == '':\n                    ignrole = 'Ign. role missing'\n            else:\n                ignrole = 'No ign. role'\n            channel = ctx.guild.get_channel(button.channelid)\n            if channel is None:\n                chnl = 'Channel missing'\n            elif channel is not None:\n                chnl = channel.mention\n            msg = await channel.fetch_message(button.msg_id)\n            if msg is None:\n                msg = 'Message missing'\n            elif msg is not None:\n                msg = f'[[Jump to message]]({msg.jump_url})'\n            buttons.append(f\"**Button ID:** {button.button_id} | **Role:** {role} | **Req. role:** {reqrole} | **Ign. role:** {ignrole} |** Channel:** {chnl} | **Message:** {msg}\\n\\n\")\n\n        if buttons == []:\n            await ctx.send('There are no role buttons for this server yet')\n            return            \n\n        s = -1\n        e = 0\n        embedcount = 1\n        nc = list(chunks(buttons, 10))\n\n        embeds = []\n        while embedcount &lt;= len(nc):\n            s = s+1\n            e = e+1\n            embeds.append(newpage(f'Role buttons for {ctx.guild.name}', mlis(buttons, s, e)))\n            embedcount = embedcount+1\n\n        paginator = Paginator(\n            client=self.bot, \n            pages=embeds,\n            timeout_interval=80,\n            show_select_menu=False)\n        await paginator.send(ctx)\n\n    @listen()\n    async def on_button_press_role_add_mode_1(self, event: ButtonPressed):\n        ctx = event.ctx\n        user = ctx.author\n        rolebutton = await db.button_roles.find_one({'guildid':ctx.guild_id, 'channelid':ctx.channel.id, 'msg_id':ctx.message.id, 'button_id':ctx.custom_id, 'mode':1})\n        if rolebutton is not None:\n            role_to_add = ctx.guild.get_role(rolebutton.roleid)\n            if role_to_add is not None:\n                if not user.has_permission(Permissions.ADMINISTRATOR):\n                    if (rolebutton.ignored_users is not None) and (rolebutton.ignored_users != []):\n                        if user.id in rolebutton.ignored_users:\n                            return await ctx.author.send('You are not allowed to use that role button.')\n\n                    if (rolebutton.ignored_roles is not None) and (rolebutton.ignored_roles != []):\n                        ign_roles = [role.name for role in user.roles if role.id in rolebutton.ignored_roles]\n                        if ign_roles != []:\n                            ign_roles_str = ','.join(ign_roles)\n                            return await ctx.author.send(f\"I can't give members with **`{ign_roles_str}`** role the **`{role_to_add.name}`** role in `{ctx.guild.name}`\", ephemeral=True)\n\n                    if (rolebutton.requirement_roles is not None) and (rolebutton.requirement_roles != []):\n                        usr_roles = [role.id for role in user.roles]\n                        req_roles = [ctx.guild.get_role(roleid).name for roleid in rolebutton.requirement_roles if roleid not in usr_roles]\n                        if req_roles != []:\n                            req_roles_str = ','.join(ign_roles)\n                            return await ctx.author.send(f\"You don't have **`{req_roles_str}`**, which you need to have for me to give you **`{role_to_add.name}`** in `{ctx.guild.name}`\", ephemeral=True)           \n\n                if role_to_add not in ctx.author.roles:\n                    await ctx.author.add_role(role_to_add)\n                    await ctx.author.send(embed=Embed(color=0xffcc50, description=f\"I gave you role `{role_to_add.name}` in `{ctx.guild.name}`\"), ephemeral=True)\n\n    @listen()\n    async def on_button_press_role_add_mode_2(self, event: Component):\n        ctx = event.ctx\n        user = ctx.author\n        rolebutton = await db.button_roles.find_one({'guildid':ctx.guild_id, 'channelid':ctx.channel.id, 'msg_id':ctx.message.id, 'button_id':ctx.custom_id, 'mode':2})\n        if rolebutton is not None:\n            role_to_add = ctx.guild.get_role(rolebutton.roleid)\n            if role_to_add is not None:\n                if not user.has_permission(Permissions.ADMINISTRATOR):\n                    if (rolebutton.ignored_users is not None) and (rolebutton.ignored_users != []):\n                        if user.id in rolebutton.ignored_users:\n                            return await ctx.author.send('You are not allowed to use that role button.')\n\n                    if (rolebutton.ignored_roles is not None) and (rolebutton.ignored_roles != []):\n                        ign_roles = [role.name for role in user.roles if role.id in rolebutton.ignored_roles]\n                        if ign_roles != []:\n                            ign_roles_str = ','.join(ign_roles)\n                            return await ctx.author.send(f\"I can't give members with **`{ign_roles_str}`** role the **`{role_to_add.name}`** role in `{ctx.guild.name}`\", ephemeral=True)\n\n                    if (rolebutton.requirement_roles is not None) and (rolebutton.requirement_roles != []):\n                        usr_roles = [role.id for role in user.roles]\n                        req_roles = [ctx.guild.get_role(roleid).name for roleid in rolebutton.requirement_roles if roleid not in usr_roles]\n                        if req_roles != []:\n                            req_roles_str = ','.join(ign_roles)\n                            return await ctx.author.send(f\"You don't have **`{req_roles_str}`**, which you need to have for me to give you **`{role_to_add.name}`** in `{ctx.guild.name}`\", ephemeral=True)\n\n                if role_to_add not in ctx.author.roles:\n                    await ctx.author.add_role(role_to_add)\n                    await ctx.author.send(embed=Embed(color=0xffcc50, description=f\"I gave you role `{role_to_add.name}`\"), ephemeral=True)\n                elif role_to_add in ctx.author.roles:\n                    await ctx.author.send(embed=Embed(color=0xffcc50, description=f\"This role `{role_to_add.name}` can't be taken away from you in `{ctx.guild.name}` in `{ctx.guild.name}`\"), ephemeral=True)\n\n    @listen()\n    async def on_button_press_role_add_mode_3(self, event: Component):\n        ctx = event.ctx\n        user = ctx.author\n        rolebutton = await db.button_roles.find_one({'guildid':ctx.guild_id, 'channelid':ctx.channel.id, 'msg_id':ctx.message.id, 'button_id':ctx.custom_id, 'mode':3})\n        if rolebutton is not None:\n            role_to_add = ctx.guild.get_role(rolebutton.roleid)                 \n            if role_to_add is not None:\n                if not user.has_permission(Permissions.ADMINISTRATOR):\n                    if (rolebutton.ignored_users is not None) and (rolebutton.ignored_users != []):\n                        if user.id in rolebutton.ignored_users:\n                            return await ctx.author.send('You are not allowed to use that role button.')\n\n                    if (rolebutton.ignored_roles is not None) and (rolebutton.ignored_roles != []):\n                        ign_roles = [role.name for role in user.roles if role.id in rolebutton.ignored_roles]\n                        if ign_roles != []:\n                            ign_roles_str = ','.join(ign_roles)\n                            return await ctx.author.send(f\"I can't give members with **`{ign_roles_str}`** role the **`{role_to_add.name}`** role in `{ctx.guild.name}`\", ephemeral=True)\n\n                    if (rolebutton.requirement_roles is not None) and (rolebutton.requirement_roles != []):\n                        usr_roles = [role.id for role in user.roles]\n                        req_roles = [ctx.guild.get_role(roleid).name for roleid in rolebutton.requirement_roles if roleid not in usr_roles]\n                        if req_roles != []:\n                            req_roles_str = ','.join(ign_roles)\n                            return await ctx.author.send(f\"You don't have **`{req_roles_str}`**, which you need to have for me to give you **`{role_to_add.name}`** in `{ctx.guild.name}`\", ephemeral=True)\n\n                old_roles = 'and took away '\n                buttons = []\n                async for b in db.button_roles.find({'guildid':ctx.guild_id, 'channelid':ctx.channel.id, 'msg_id':ctx.message.id, 'mode':3}):\n                    buttons.append(b.roleid)\n                if buttons != []:\n                    for button_role_id in buttons:\n                        if button_role_id != rolebutton.roleid:\n                            old_role = ctx.guild.get_role(button_role_id)\n                            if old_role is not None:\n                                if old_role in ctx.author.roles:\n                                    await ctx.author.remove_role(old_role)\n                                    old_roles = old_roles + f'`{old_role.name}` '\n\n                if old_roles == 'and took away ':\n                    old_roles = ''\n\n                if role_to_add not in ctx.author.roles:\n                    await ctx.author.add_role(role_to_add)\n                    await ctx.author.send(embed=Embed(color=0xffcc50, description=f\"I gave you role `{role_to_add.name}` {old_roles} in `{ctx.guild.name}`\"), ephemeral=True)\n\n    @listen()\n    async def on_button_press_role_remove_mode_1(self, event: Component):\n        ctx = event.ctx\n        rolebutton = await db.button_roles.find_one({'guildid':ctx.guild_id, 'channelid':ctx.channel.id, 'msg_id':ctx.message.id, 'button_id':ctx.custom_id, 'mode':1})\n        if rolebutton is not None:\n            role_to_remove = ctx.guild.get_role(rolebutton.roleid)\n            if role_to_remove is not None:\n                if role_to_remove in ctx.author.roles:\n                    await ctx.author.remove_role(role_to_remove)\n                    await ctx.author.send(embed=Embed(color=0xffcc50, description=f\"I took away a role `{role_to_remove.name}` from you in `{ctx.guild.name}`\"), ephemeral=True)\n\n    @listen()\n    async def on_button_press_role_remove_mode_3(self, event: Component):\n        ctx = event.ctx\n        rolebutton = await db.button_roles.find_one({'guildid':ctx.guild_id, 'channelid':ctx.channel.id, 'msg_id':ctx.message.id, 'button_id':ctx.custom_id, 'mode':3})\n        if rolebutton is not None:\n            old_roles = ''\n            buttons = []\n            async for b in db.button_roles.find({'guildid':ctx.guild_id, 'channelid':ctx.channel.id, 'msg_id':ctx.message.id, 'mode':3}):\n                buttons.append(b.roleid)\n            if buttons != []:\n                for button_role_id in buttons:\n                    if button_role_id != rolebutton.roleid:\n                        old_role = ctx.guild.get_role(button_role_id)\n                        if old_role is not None:\n                            if old_role in ctx.author.roles:\n                                await ctx.author.remove_role(old_role)\n                                old_roles = old_roles + f'`{old_role.name}` '\n\n            role_to_remove = ctx.guild.get_role(rolebutton.roleid)                 \n            if role_to_remove is not None:\n                if role_to_remove in ctx.author.roles:\n                    await ctx.author.remove_role(role_to_remove)\n                    old_roles = old_roles + f'`{role_to_remove.name}` '\n                    await ctx.author.send(embed=Embed(color=0xffcc50, description=f\"I took away {old_roles} in `{ctx.guild.name}`\"), ephemeral=True)\n</code></pre>"},{"location":"buttonroles/#extentions.buttonroles.ButtonRoles.role_buttons_add","title":"<code>role_buttons_add(ctx, roles, message_id, channel=None, button_colours=1, mode=1)</code>  <code>async</code>","text":"<p>/rolebuttons create</p> Description <p>Add role buttons to a message.</p> <p>Parameters:</p> Name Type Description Default <code>roles</code> <code>str</code> <p>Role IDs or @roles, sperated by comma <code>,</code> | the roles you want to create role buttons from. There can't be more than 25 roles/buttons on one message.</p> required <code>message_id</code> <code>OptionType.STRING</code> <p>Message ID you want the role buttons on, it has to be a message sent by Melody.</p> required <code>channel</code> <code>ChannelType.GUILD_TEXT</code> <p>Channel the message is in. Defaults to channel command is executed in.</p> <code>None</code> <code>button_colours</code> <code>OptionType.INTEGER</code> <p>The colour you want the buttons to be. Defaults to Blurple.</p> <code>1</code> <code>mode</code> <code>OptionType.INTEGER</code> <p>Mode you want buttons to be in. Defaults to 1. Modes: 1 = get or remove the role, 2 = get a role - not possible to remove the role, 3 = only one role allowed from the message</p> <code>1</code> Source code in <code>extentions/buttonroles.py</code> <pre><code>@role_buttons.subcommand(sub_cmd_name='create', sub_cmd_description=\"Add role buttons to a message\")\n@slash_option(name='roles', description='Roles, seperated by a comma(,)', opt_type=OptionType.STRING, required=True)\n@slash_option(name='message_id', description='Paste in a message ID', opt_type=OptionType.STRING, required=True)\n@slash_option(name='channel', description='Select a channel', opt_type=OptionType.CHANNEL, channel_types=[ChannelType.GUILD_TEXT], required=False)\n@slash_option(name=\"button_colours\", description=\"Choose what colour the button will be. Default: Blurple\", required=False, opt_type=OptionType.INTEGER,\nchoices=[SlashCommandChoice(name=\"Blurple\", value=1), SlashCommandChoice(name=\"Green\", value=3), SlashCommandChoice(name=\"Red\", value=4), SlashCommandChoice(name=\"Gray\", value=2)])\n@slash_option(name=\"mode\", description=\"Choose the mode this set of buttons will be in. Default: Click to get/remove a role\", required=False, opt_type=OptionType.INTEGER,\nchoices=[SlashCommandChoice(name=\"Get or remove a role\", value=1),SlashCommandChoice(name=\"Get a role, no removing\", value=2),SlashCommandChoice(name=\"Only one role allowed\", value=3)])\nasync def role_buttons_add(self, ctx: SlashContext, roles: str, message_id: OptionType.STRING, channel: ChannelType.GUILD_TEXT=None, button_colours: OptionType.INTEGER = 1, mode: OptionType.INTEGER=1):\n\"\"\"/rolebuttons create\n    Description:\n        Add role buttons to a message.\n\n    Args:\n        roles (str): Role IDs or @roles, sperated by comma `,` | the roles you want to create role buttons from. There can't be more than 25 roles/buttons on one message.\n        message_id (OptionType.STRING): Message ID you want the role buttons on, it has to be a message sent by Melody.\n        channel (ChannelType.GUILD_TEXT, optional): Channel the message is in. Defaults to channel command is executed in.\n        button_colours (OptionType.INTEGER, optional): The colour you want the buttons to be. Defaults to Blurple.\n        mode (OptionType.INTEGER, optional): Mode you want buttons to be in. Defaults to 1. Modes: 1 = get or remove the role, 2 = get a role - not possible to remove the role, 3 = only one role allowed from the message\n    \"\"\"\n    await ctx.defer()\n    # modes: 1 = get or remove the role, 2 = get a role - not possible to remove the role, 3 = only one role allowed from the message\n    if channel is None:\n        channel = ctx.channel\n    message: Message = await channel.fetch_message(message_id)\n    if message is not None:\n        components = []\n        if message.components != []:\n            for ob in message.components:\n                components = components + ob.components\n        documents = []\n        messages = []\n\n        if button_colours == 1:\n            button_colour = ButtonStyle.BLURPLE\n        elif button_colours == 3:\n            button_colour = ButtonStyle.GREEN\n        elif button_colours == 4:\n            button_colour = ButtonStyle.RED\n        elif button_colours == 2:\n            button_colour = ButtonStyle.GRAY\n\n        raw_roles_list = roles.split(',')\n        roles_ids = []\n        for r in raw_roles_list:\n            r = r.replace('&lt;', '')\n            r = r.replace('@', '')\n            r = r.replace('!', '')\n            r = r.replace('&amp;', '')\n            r = r.replace('&gt;', '')\n            roles_ids.append(r)\n        for role_id in roles_ids:\n            role = ctx.guild.get_role(role_id)\n            if role is not None:\n                button_id = await button_id_generator(ctx, channel, message)\n                components.append(Button(style=button_colour,label=f\"{role.name}\",custom_id=button_id))\n                messages.append(f\"Button for role {role.mention} was added.\\nButton ID: `{button_id}`\\nMode: {mode}\")\n                documents.append(db.button_roles(guildid=ctx.guild_id, button_id=button_id, channelid=channel.id, msg_id=message.id, roleid=role.id, mode=mode))\n\n        if len(components) &gt; 25:\n            return await ctx.send(\"There can't be more than 25 components on one message\")\n\n        rows = spread_to_rows(*components)\n\n        await db.button_roles.insert_many(documents)\n        await message.edit(components=rows)\n        for m in messages:\n            await ctx.send(embed=Embed(color=0xffcc50, description=m))\n    else:\n        return await ctx.send(\"Message not found.\")\n</code></pre>"},{"location":"buttonroles/#extentions.buttonroles.ButtonRoles.role_buttons_edit","title":"<code>role_buttons_edit(ctx, message_id, button_id, channel=None, mode=None, button_colours=None, new_role=None, requirement_role=None, ignore_role=None, name=None)</code>  <code>async</code>","text":"<p>/rolebuttons edit</p> Description <p>Edit the behaviour of a role button. <code>Name</code>, <code>Button colour</code> and <code>New Role</code> can't be edited together.</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>OptionType.STRING</code> <p>Message ID the role button is on.</p> required <code>button_id</code> <code>OptionType.STRING</code> <p>Button ID of the button you want to modify.</p> required <code>channel</code> <code>OptionType.CHANNEL</code> <p>Channel the message is in. Defaults to channel command is executed in.</p> <code>None</code> <code>mode</code> <code>OptionType.INTEGER</code> <p>Mode you want buttons to be in. Modes: 1 = get or remove the role, 2 = get a role - not possible to remove the role, 3 = only one role allowed from the message</p> <code>None</code> <code>button_colours</code> <code>OptionType.INTEGER</code> <p>description. The colour you want the buttons to be.</p> <code>None</code> <code>new_role</code> <code>OptionType.ROLE</code> <p>The new role you want on the button.</p> <code>None</code> <code>requirement_role</code> <code>OptionType.ROLE</code> <p>Choose a role. Members will be required to have this role to use the button.</p> <code>None</code> <code>ignore_role</code> <code>OptionType.ROLE</code> <p>Choose a role. Members with this role will be ignored.</p> <code>None</code> <code>name</code> <code>OptionType.STRING</code> <p>Change the button name.</p> <code>None</code> Source code in <code>extentions/buttonroles.py</code> <pre><code>@role_buttons.subcommand(sub_cmd_name='edit', sub_cmd_description=\"Edit the behaviour of a role button\")\n@message_id()\n@button_id()\n@channel()\n@slash_option(name=\"mode\",description=\"Choose the mode this set of buttons will be in. Default: Click to get/remove a role\",required=False,opt_type=OptionType.INTEGER,\nchoices=[SlashCommandChoice(name=\"Get or remove a role\", value=1),SlashCommandChoice(name=\"Get a role, no removing\", value=2),SlashCommandChoice(name=\"Only one role allowed\", value=3)])\n@new_role()\n@slash_option(name=\"button_colours\",description=\"Choose what colour the button will be. Default: Blurple\",required=False,opt_type=OptionType.INTEGER,\nchoices=[SlashCommandChoice(name=\"Blurple\", value=1),SlashCommandChoice(name=\"Green\", value=3),SlashCommandChoice(name=\"Red\", value=4),SlashCommandChoice(name=\"Gray\", value=2)])\n@slash_option(name=\"requirement_role\",description=\"Choose a role. Members will be required to have this role to use the button.\",required=False,opt_type=OptionType.ROLE)\n@slash_option(name=\"ignore_role\",description=\"Choose a role. Members with this role will be ignored.\",required=False,opt_type=OptionType.ROLE)\n@slash_option(name='name', description='Give the button a custom name', opt_type=OptionType.STRING, required=False)\nasync def role_buttons_edit(self, ctx: InteractionContext, message_id:OptionType.STRING, button_id:OptionType.STRING, channel:OptionType.CHANNEL=None, mode:OptionType.INTEGER=None,\nbutton_colours:OptionType.INTEGER=None, new_role: OptionType.ROLE = None, requirement_role: OptionType.ROLE = None, ignore_role: OptionType.ROLE = None, name: OptionType.STRING=None):\n\"\"\"/rolebuttons edit\n    Description:\n        Edit the behaviour of a role button. `Name`, `Button colour` and `New Role` can't be edited together.\n\n    Args:\n        message_id (OptionType.STRING): Message ID the role button is on.\n        button_id (OptionType.STRING): Button ID of the button you want to modify.\n        channel (OptionType.CHANNEL, optional): Channel the message is in. Defaults to channel command is executed in.\n        mode (OptionType.INTEGER, optional): Mode you want buttons to be in. Modes: 1 = get or remove the role, 2 = get a role - not possible to remove the role, 3 = only one role allowed from the message\n        button_colours (OptionType.INTEGER, optional): _description_. The colour you want the buttons to be.\n        new_role (OptionType.ROLE, optional): The new role you want on the button.\n        requirement_role (OptionType.ROLE, optional): Choose a role. Members will be required to have this role to use the button.\n        ignore_role (OptionType.ROLE, optional): Choose a role. Members with this role will be ignored.\n        name (OptionType.STRING, optional): Change the button name.\n    \"\"\"\n    await ctx.defer()\n    if button_colours == 1:\n        button_colour = ButtonStyle.BLURPLE\n        colour = 'Blurple'\n    elif button_colours == 3:\n        button_colour = ButtonStyle.GREEN\n        colour = 'Green'\n    elif button_colours == 4:\n        button_colour = ButtonStyle.RED\n        colour = 'Red'\n    elif button_colours == 2:\n        button_colour = ButtonStyle.GRAY\n        colour = 'Gray'\n    if (mode is None) and (button_colours is None) and (new_role is None) and (requirement_role is None) and (ignore_role is None) and (name is None):\n        return await ctx.send('You have to change at least one option to change')\n    if channel is None:\n        channel = ctx.channel\n    edits = ''\n    message = await channel.fetch_message(message_id)\n    if message is not None:\n        if (button_colours is not None) and (new_role is not None) and (name is not None):\n            return await ctx.send(\"`Name`, `Button colour` and `New Role` can't be edited together\")\n        if button_colours is not None:\n                if message.components != []:\n                    components = []\n                    for ob in message.components:\n                        components.append(ob.components)\n\n                    for l in components:\n                        for b in l:\n                            if b.custom_id == button_id:\n                                for p in [(i, l.index(b)) for i, l in enumerate(components) if b in l]:\n                                    p1, p2 = p\n\n                    message.components[p1].components[p2].style = button_colour\n                    await message.edit(components=message.components)    \n                    edits = edits + f\"New colour: {colour}\\n\"\n        button = await db.button_roles.find_one({'guildid':ctx.guild_id, 'channelid':channel.id, 'msg_id':message.id, 'button_id':button_id})\n        if mode is not None:\n            button.mode = mode\n            await button.save()\n            if mode == 1:\n                button_mode = 'Get or remove a role'\n            elif mode == 2:\n                button_mode = 'Get a role, no removing'\n            elif mode == 3:\n                button_mode = 'Only one role allowed'\n            edits = edits + f\"New Mode: {button_mode}\\n\"\n        if name is not None:\n            if message.components != []:\n                components = []\n                for ob in message.components:\n                    components.append(ob.components)\n\n                for l in components:\n                    for b in l:\n                        if b.custom_id == button_id:\n                            for p in [(i, l.index(b)) for i, l in enumerate(components) if b in l]:\n                                p1, p2 = p\n                message.components[p1].components[p2].label = name\n                await message.edit(components=message.components)\n            edits = edits + f\"New Name: {name}\\n\"\n        if new_role is not None:\n            button.roleid = new_role.id\n            await button.save()\n            if message.components != []:\n                components = []\n                for ob in message.components:\n                    components.append(ob.components)\n\n                for l in components:\n                    for b in l:\n                        if b.custom_id == button_id:\n                            for p in [(i, l.index(b)) for i, l in enumerate(components) if b in l]:\n                                p1, p2 = p\n                if name is not None:\n                    bname = name\n                elif name is None:\n                    bname = new_role.name\n                message.components[p1].components[p2].label = bname\n                await message.edit(components=message.components)\n            edits = edits + f\"New Role: {new_role.mention}\\n\"\n        if requirement_role is not None:\n            if button.requirement_roles is not None:\n                button.requirement_roles.append(requirement_role.id)\n                await button.save()\n            else:\n                button.requirement_roles = [requirement_role.id]\n                await button.save()\n            edits = edits + f\"Requirement Role: {requirement_role.mention}\\n\"\n        if ignore_role is not None:\n            if button.ignored_roles is not None:\n                button.ignored_roles.append(ignore_role.id)\n                await button.save()\n            else:\n                button.ignored_roles = [ignore_role.id]\n                button.save()\n            edits = edits + f\"Ignore Role: {ignore_role.mention}\\n\"\n        await ctx.send(embed=Embed(color=0xffcc50,description=f\"Button `{button_id}` succesfully edited\\n{edits}\"))\n    else:\n        await ctx.send('Message not found')\n</code></pre>"},{"location":"buttonroles/#extentions.buttonroles.ButtonRoles.role_buttons_remove","title":"<code>role_buttons_remove(ctx, message_id, button_id, channel=None)</code>  <code>async</code>","text":"<p>/rolebuttons remove</p> Description <p>Delete a role button from a message.</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>OptionType.STRING</code> <p>Message ID the button is on.</p> required <code>button_id</code> <code>OptionType.STRING</code> <p>The button ID, of the button you want to delete.</p> required <code>channel</code> <code>OptionType.CHANNEL</code> <p>Channel the message is in. Defaults to channel command is executed in.</p> <code>None</code> Source code in <code>extentions/buttonroles.py</code> <pre><code>@role_buttons.subcommand(sub_cmd_name='remove', sub_cmd_description=\"Remove a role button\")\n@button_id()\n@message_id()\n@channel()\nasync def role_buttons_remove(self, ctx: InteractionContext, message_id:OptionType.STRING, button_id:OptionType.STRING, channel:OptionType.CHANNEL=None):\n\"\"\"/rolebuttons remove\n    Description:\n        Delete a role button from a message.\n\n    Args:\n        message_id (OptionType.STRING): Message ID the button is on.\n        button_id (OptionType.STRING): The button ID, of the button you want to delete.\n        channel (OptionType.CHANNEL, optional): Channel the message is in. Defaults to channel command is executed in.\n    \"\"\"\n    await ctx.defer()\n    if channel is None:\n        channel = ctx.channel\n    message: Message = await channel.fetch_message(message_id)\n    if message is None:\n        return await ctx.send(f\"Can't find a message with that id\", ephemeral=True)\n    components = []\n    if message.components != []:\n        for ob in message.components:\n            components = components + ob.components\n\n    for b in components:\n        if b.custom_id == button_id:\n            components.remove(b)\n\n    rows = spread_to_rows(*components)\n\n    await message.edit(components=rows)\n\n    button = await db.button_roles.find_one({'guildid':ctx.guild_id, 'channelid':channel.id, 'msg_id':message.id, 'button_id':button_id})\n    await button.delete()\n    await ctx.send(f\"Button `{button_id}` successfully deleted\")\n</code></pre>"},{"location":"buttonroles/#extentions.buttonroles.ButtonRoles.role_buttons_list","title":"<code>role_buttons_list(ctx)</code>  <code>async</code>","text":"<p>/rolebuttons list</p> Description <p>List all the role buttons, and their info.</p> Source code in <code>extentions/buttonroles.py</code> <pre><code>@role_buttons.subcommand(sub_cmd_name='list', sub_cmd_description=\"List all role buttons on this server\")\nasync def role_buttons_list(self, ctx: InteractionContext):\n\"\"\"/rolebuttons list\n\n    Description:\n        List all the role buttons, and their info.\n    \"\"\"\n    await ctx.defer()\n    from interactions.ext.paginators import Paginator\n    def chunks(l, n):\n        n = max(1, n)\n        return (l[i:i+n] for i in range(0, len(l), n))\n\n    def mlis(lst, s, e):\n        nc = list(chunks(lst, 10))\n        mc = ''\n        for testlist in nc[s:e]:\n            for m in testlist:\n                mc = mc + m\n        return mc\n\n    def newpage(title, buttoninfo):\n        embed = Embed(title=title,\n        description=buttoninfo,\n        color=0xffcc50)\n        return embed\n\n    role_buttons = db.button_roles.find({'guildid':ctx.guild_id})\n\n    buttons = []\n    async for button in role_buttons:\n        role = ctx.guild.get_role(button.roleid)\n        if role is None:\n            role = 'Role missing'\n        elif role is not None:\n            role = role.mention\n        if button.requirement_roles is not None:\n            req_role = ' '.join([ctx.guild.get_role(id).mention for id in button.requirement_roles])\n            if req_role == '':\n                reqrole = 'Req. role missing'\n        else:\n            reqrole = 'No req. role'\n        if button.ignored_roles is not None:\n            ign_role = ' '.join([ctx.guild.get_role(id).mention for id in button.ignored_roles])\n            if ign_role == '':\n                ignrole = 'Ign. role missing'\n        else:\n            ignrole = 'No ign. role'\n        channel = ctx.guild.get_channel(button.channelid)\n        if channel is None:\n            chnl = 'Channel missing'\n        elif channel is not None:\n            chnl = channel.mention\n        msg = await channel.fetch_message(button.msg_id)\n        if msg is None:\n            msg = 'Message missing'\n        elif msg is not None:\n            msg = f'[[Jump to message]]({msg.jump_url})'\n        buttons.append(f\"**Button ID:** {button.button_id} | **Role:** {role} | **Req. role:** {reqrole} | **Ign. role:** {ignrole} |** Channel:** {chnl} | **Message:** {msg}\\n\\n\")\n\n    if buttons == []:\n        await ctx.send('There are no role buttons for this server yet')\n        return            \n\n    s = -1\n    e = 0\n    embedcount = 1\n    nc = list(chunks(buttons, 10))\n\n    embeds = []\n    while embedcount &lt;= len(nc):\n        s = s+1\n        e = e+1\n        embeds.append(newpage(f'Role buttons for {ctx.guild.name}', mlis(buttons, s, e)))\n        embedcount = embedcount+1\n\n    paginator = Paginator(\n        client=self.bot, \n        pages=embeds,\n        timeout_interval=80,\n        show_select_menu=False)\n    await paginator.send(ctx)\n</code></pre>"},{"location":"config_commands/","title":"Config commands","text":"<p>         Bases: <code>Extension</code></p> Source code in <code>extentions/config_commands.py</code> <pre><code>class BotConfiguration(Extension):\n    def __init__(self, bot: Client):\n        self.bot = bot\n\n    config_cmd = SlashCommand(name='config', description='Configure the bot', default_member_permissions=Permissions.ADMINISTRATOR)\n\n    @config_cmd.subcommand('logging', sub_cmd_description='Configure what the bot logs')\n    async def config_logging(self, ctx: InteractionContext):\n\"\"\"/config logging\n        Description:\n            Configure what the bot logs. On command execution it will send a select menu with options to choose from, automatically saves on selecting an option. Time limit 2 minutes.\n        \"\"\"\n        await ctx.defer(ephemeral=True)\n        events_logging = await db.prefixes.find_one({'guildid':ctx.guild_id})\n        if events_logging.activecommands is None:\n            events_log_list = ''\n        else:\n            events_log_list = events_logging.activecommands.lower()\n        if 'message_deleted' in events_log_list:\n            msg_del_status = True\n        else:\n            msg_del_status = False\n\n        if 'message_edited' in events_log_list:\n            msg_edit_status = True\n        else:\n            msg_edit_status = False\n\n        if 'member_join' in events_log_list:\n            mem_join_status = True\n        else:\n            mem_join_status = False\n\n        if 'member_leave' in events_log_list:\n            mem_leave_status = True\n        else:\n            mem_leave_status = False\n\n        if 'member_kick' in events_log_list:\n            mem_kick_status = True\n        else:\n            mem_kick_status = False\n\n        if 'member_ban' in events_log_list:\n            mem_ban_status = True\n        else:\n            mem_ban_status = False\n\n        if 'member_unban' in events_log_list:\n            mem_unban_status = True\n        else:\n            mem_unban_status = False\n\n        if 'member_timeout' in events_log_list:\n            mem_timeout_status = True\n        else:\n            mem_timeout_status = False\n\n        if 'member_roles' in events_log_list:\n            mem_roles_status = True\n        else:\n            mem_roles_status = False\n\n        if 'member_nick' in events_log_list:\n            mem_nick_status = True\n        else:\n            mem_nick_status = False\n\n        if 'welcome_msg' in events_log_list:\n            welcome_msg_status = True\n        else:\n            welcome_msg_status = False\n\n        if 'welcome_msg_card' in events_log_list:\n            welcome_msg_card_status = True\n        else:\n            welcome_msg_card_status = False\n\n        if 'leave_msg' in events_log_list:\n            leave_msg_status = True\n        else:\n            leave_msg_status = False\n\n        select_options = [\n            StringSelectOption(label=\"Deleted Messages\", value=\"message_deleted\", default=msg_del_status),\n            StringSelectOption(label=\"Edited Messages\", value=\"message_edited\", default=msg_edit_status),\n            StringSelectOption(label=\"Member Joined\", value=\"member_join\", default=mem_join_status),\n            StringSelectOption(label=\"Member Left\", value=\"member_leave\", default=mem_leave_status),\n            StringSelectOption(label=\"Member Kicked\", value=\"member_kick\", default=mem_kick_status),\n            StringSelectOption(label=\"Member Banned\", value=\"member_ban\", default=mem_ban_status),\n            StringSelectOption(label=\"Member Unbanned\", value=\"member_unban\", default=mem_unban_status),\n            StringSelectOption(label=\"Member Timeout\", value=\"member_timeout\", default=mem_timeout_status),\n            StringSelectOption(label=\"Member Roles\", value=\"member_roles\", default=mem_roles_status),\n            StringSelectOption(label=\"Member Nickname\", value=\"member_nick\", default=mem_nick_status),\n            StringSelectOption(label=\"Welcome Message\", value=\"welcome_msg\", default=welcome_msg_status),\n            StringSelectOption(label=\"Leave Message\", value=\"leave_msg\", default=leave_msg_status),\n            StringSelectOption(label=\"New Member Card\", value=\"welcome_msg_card\", default=welcome_msg_card_status),\n        ]\n\n        select_menu = StringSelectMenu(select_options, min_values=0, max_values=13)\n\n        message = await ctx.send('Configure logging.', components=select_menu)\n\n        while True:\n            try:\n                select = await self.bot.wait_for_component(components=select_menu, timeout=120)\n            except asyncio.TimeoutError:\n                await message.edit('Config closed due to 2 minutes of inactivity.', components=[])\n            else:\n                values = \",\".join(select.ctx.values)\n                events_logging.activecommands = values\n                await events_logging.save()\n</code></pre>"},{"location":"config_commands/#extentions.config_commands.BotConfiguration.config_logging","title":"<code>config_logging(ctx)</code>  <code>async</code>","text":"<p>/config logging</p> Description <p>Configure what the bot logs. On command execution it will send a select menu with options to choose from, automatically saves on selecting an option. Time limit 2 minutes.</p> Source code in <code>extentions/config_commands.py</code> <pre><code>@config_cmd.subcommand('logging', sub_cmd_description='Configure what the bot logs')\nasync def config_logging(self, ctx: InteractionContext):\n\"\"\"/config logging\n    Description:\n        Configure what the bot logs. On command execution it will send a select menu with options to choose from, automatically saves on selecting an option. Time limit 2 minutes.\n    \"\"\"\n    await ctx.defer(ephemeral=True)\n    events_logging = await db.prefixes.find_one({'guildid':ctx.guild_id})\n    if events_logging.activecommands is None:\n        events_log_list = ''\n    else:\n        events_log_list = events_logging.activecommands.lower()\n    if 'message_deleted' in events_log_list:\n        msg_del_status = True\n    else:\n        msg_del_status = False\n\n    if 'message_edited' in events_log_list:\n        msg_edit_status = True\n    else:\n        msg_edit_status = False\n\n    if 'member_join' in events_log_list:\n        mem_join_status = True\n    else:\n        mem_join_status = False\n\n    if 'member_leave' in events_log_list:\n        mem_leave_status = True\n    else:\n        mem_leave_status = False\n\n    if 'member_kick' in events_log_list:\n        mem_kick_status = True\n    else:\n        mem_kick_status = False\n\n    if 'member_ban' in events_log_list:\n        mem_ban_status = True\n    else:\n        mem_ban_status = False\n\n    if 'member_unban' in events_log_list:\n        mem_unban_status = True\n    else:\n        mem_unban_status = False\n\n    if 'member_timeout' in events_log_list:\n        mem_timeout_status = True\n    else:\n        mem_timeout_status = False\n\n    if 'member_roles' in events_log_list:\n        mem_roles_status = True\n    else:\n        mem_roles_status = False\n\n    if 'member_nick' in events_log_list:\n        mem_nick_status = True\n    else:\n        mem_nick_status = False\n\n    if 'welcome_msg' in events_log_list:\n        welcome_msg_status = True\n    else:\n        welcome_msg_status = False\n\n    if 'welcome_msg_card' in events_log_list:\n        welcome_msg_card_status = True\n    else:\n        welcome_msg_card_status = False\n\n    if 'leave_msg' in events_log_list:\n        leave_msg_status = True\n    else:\n        leave_msg_status = False\n\n    select_options = [\n        StringSelectOption(label=\"Deleted Messages\", value=\"message_deleted\", default=msg_del_status),\n        StringSelectOption(label=\"Edited Messages\", value=\"message_edited\", default=msg_edit_status),\n        StringSelectOption(label=\"Member Joined\", value=\"member_join\", default=mem_join_status),\n        StringSelectOption(label=\"Member Left\", value=\"member_leave\", default=mem_leave_status),\n        StringSelectOption(label=\"Member Kicked\", value=\"member_kick\", default=mem_kick_status),\n        StringSelectOption(label=\"Member Banned\", value=\"member_ban\", default=mem_ban_status),\n        StringSelectOption(label=\"Member Unbanned\", value=\"member_unban\", default=mem_unban_status),\n        StringSelectOption(label=\"Member Timeout\", value=\"member_timeout\", default=mem_timeout_status),\n        StringSelectOption(label=\"Member Roles\", value=\"member_roles\", default=mem_roles_status),\n        StringSelectOption(label=\"Member Nickname\", value=\"member_nick\", default=mem_nick_status),\n        StringSelectOption(label=\"Welcome Message\", value=\"welcome_msg\", default=welcome_msg_status),\n        StringSelectOption(label=\"Leave Message\", value=\"leave_msg\", default=leave_msg_status),\n        StringSelectOption(label=\"New Member Card\", value=\"welcome_msg_card\", default=welcome_msg_card_status),\n    ]\n\n    select_menu = StringSelectMenu(select_options, min_values=0, max_values=13)\n\n    message = await ctx.send('Configure logging.', components=select_menu)\n\n    while True:\n        try:\n            select = await self.bot.wait_for_component(components=select_menu, timeout=120)\n        except asyncio.TimeoutError:\n            await message.edit('Config closed due to 2 minutes of inactivity.', components=[])\n        else:\n            values = \",\".join(select.ctx.values)\n            events_logging.activecommands = values\n            await events_logging.save()\n</code></pre>"},{"location":"event_logs/","title":"Event logs","text":"<p>         Bases: <code>Extension</code></p> Source code in <code>extentions/event_logs.py</code> <pre><code>class EventLogs(Extension):\n    def __init__(self, bot: Client):\n        self.bot = bot\n\n    @slash_command(name='logchannel', description=\"set up a logging channel\",\n        default_member_permissions=Permissions.ADMINISTRATOR\n    )\n    @channel()\n    async def logchannel(self, ctx: InteractionContext, channel:OptionType.CHANNEL=None):\n\"\"\"/logchannel\n        Description:\n            set up a logging channel\n\n        Args:\n            channel (OptionType.CHANNEL, optional): CHannel to send log messages in.\n        \"\"\"\n        if channel is None:\n            channel = ctx.channel\n\n        log_entry = await db.logs.find_one({\"guild_id\":ctx.guild_id})\n        if log_entry is None:\n            await db.logs(guild_id=ctx.guild_id, channel_id=channel.id).save()\n            embed = Embed(description=f\"I have assigned {channel.mention} as a log channel.\",\n                                  color=0xffcc50)\n            await ctx.send(embed=embed)\n        else:\n            log_entry.channel_id = channel.id\n            await log_entry.save()\n            embed = Embed(description=f\"I have updated {channel.mention} as a log channel.\",\n                                  color=0xffcc50)\n            await ctx.send(embed=embed)\n\n    @slash_command(name='welcomemessage', description=\"set up a welcome message and channel\",\n        default_member_permissions=Permissions.ADMINISTRATOR\n    )\n    @welcome_message_text()\n    @channel()\n    async def welcome_message_cmd(self, ctx: InteractionContext, welcome_message_text:OptionType.STRING=None, channel:OptionType.CHANNEL=None):\n\"\"\"/welcomemessage\n        Description:\n            set up a welcome message and channel\n\n        Args:\n            welcome_message_text (OptionType.STRING, optional): Welcome message text.\n            channel (OptionType.CHANNEL, optional): Welcome message channel.\n        \"\"\"\n        if (channel is None) and (welcome_message_text is None):\n            embed = Embed(\n                description=\":x: Please provide a channel or welcome message\",\n                color=0xDD2222)\n            await ctx.send(embed=embed)\n            return\n\n        log_entry = await db.welcome_msg.find_one({\"guildid\":ctx.guild_id})\n        if log_entry is None:\n            up_msg = ''\n            if welcome_message_text is not None:\n                up_msg = up_msg + f\"I have updated `{welcome_message_text}` as a welcome message.\\n\"\n\n            if channel is not None:\n                up_msg = up_msg + f\"I have updated {channel.mention} as a welcome channel.\"\n                channel = channel.id\n            elif channel is None:\n                channel = None\n            await db.welcome_msg(guildid=ctx.guild_id, channelid=channel, message=welcome_message_text).save()\n            embed = Embed(description=up_msg,\n                                  color=0xffcc50)\n            await ctx.send(embed=embed)\n        else:\n            up_msg = ''\n            if welcome_message_text is not None:\n                log_entry.message = welcome_message_text\n                up_msg = up_msg + f\"I have updated `{welcome_message_text}` as a welcome message.\\n\"\n\n            if channel is not None:\n                log_entry.channelid = channel.id\n                up_msg = up_msg + f\"I have updated {channel.mention} as a welcome channel.\"\n\n            await log_entry.save()\n            embed = Embed(description=up_msg,\n                                  color=0xffcc50)\n            await ctx.send(embed=embed)\n\n    @slash_command(name='leavemessage', description=\"set up a leave message and channel\",\n        default_member_permissions=Permissions.ADMINISTRATOR\n    )\n    @leave_message_text()\n    @channel()\n    async def leave_message_cmd(self, ctx: InteractionContext, leave_message_text:OptionType.STRING=None, channel:OptionType.CHANNEL=None):\n\"\"\"/leavemessage\n        Description:\n            set up a leave message and channel\n\n        Args:\n            leave_message_text (OptionType.STRING, optional): Leave message text.\n            channel (OptionType.CHANNEL, optional): Leave message channel.\n        \"\"\"\n        if (channel is None) and (leave_message_text is None):\n            embed = Embed(\n                description=\":x: Please provide a channel or leave message\",\n                color=0xDD2222)\n            await ctx.send(embed=embed)\n            return\n\n        log_entry = await db.leave_msg.find_one({\"guildid\":ctx.guild_id})\n        if log_entry is None:\n            up_msg = ''\n            if leave_message_text is not None:\n                up_msg = up_msg + f\"I have updated `{leave_message_text}` as a leave message.\\n\"\n\n            if channel is not None:\n                up_msg = up_msg + f\"I have updated {channel.mention} as a leave channel.\"\n                channel = channel.id\n            elif channel is None:\n                channel = None\n            await db.leave_msg(guildid=ctx.guild_id, channelid=channel, message=leave_message_text).save()\n            embed = Embed(description=up_msg,\n                                  color=0xffcc50)\n            await ctx.send(embed=embed)\n        else:\n            up_msg = ''\n            if leave_message_text is not None:\n                log_entry.message = leave_message_text\n                up_msg = up_msg + f\"I have updated `{leave_message_text}` as a leave message.\\n\"\n\n            if channel is not None:\n                log_entry.channelid = channel.id\n                up_msg = up_msg + f\"I have updated {channel.mention} as a leave channel.\"\n\n            await log_entry.save()\n            embed = Embed(description=up_msg,\n                                  color=0xffcc50)\n            await ctx.send(embed=embed)\n\n    @slash_command(name='specialwelcomemsg', description=\"set up a special welcome message and channel\", scopes=[149167686159564800, 435038183231848449],\n        default_member_permissions=Permissions.ADMINISTRATOR\n    )\n    @welcome_message_text()\n    @channel()\n    async def specialwelcome_message_cmd(self, ctx: InteractionContext, welcome_message_text:OptionType.STRING=None, channel:OptionType.CHANNEL=None):\n        if (channel is None) and (welcome_message_text is None):\n            embed = Embed(\n                description=\":x: Please provide a channel or welcome message\",\n                color=0xDD2222)\n            await ctx.send(embed=embed)\n            return\n\n        log_entry = await db.special_welcome_msg.find_one({\"guildid\":ctx.guild_id})\n        if log_entry is None:\n            up_msg = ''\n            if welcome_message_text is not None:\n                up_msg = up_msg + f\"I have updated `{welcome_message_text}` as a special welcome message.\\n\"\n\n            if channel is not None:\n                up_msg = up_msg + f\"I have updated {channel.mention} as a special welcome channel.\"\n                channel = channel.id\n            elif channel is None:\n                channel = None\n            await db.special_welcome_msg(guildid=ctx.guild_id, channelid=channel, message=welcome_message_text).save()\n            embed = Embed(description=up_msg,\n                                  color=0xffcc50)\n            await ctx.send(embed=embed)\n        else:\n            up_msg = ''\n            if welcome_message_text is not None:\n                log_entry.message = welcome_message_text\n                up_msg = up_msg + f\"I have updated `{welcome_message_text}` as special a welcome message.\\n\"\n\n            if channel is not None:\n                log_entry.channelid = channel.id\n                up_msg = up_msg + f\"I have updated {channel.mention} as a special welcome channel.\"\n\n            await log_entry.save()\n            embed = Embed(description=up_msg,\n                                  color=0xffcc50)\n            await ctx.send(embed=embed)\n\n    @listen()\n    async def on_message_delete_attachments(self, event: MessageDelete):\n        message = event.message\n        if message.author.bot:\n            return\n        if await is_event_active(message.guild, 'message_deleted'):\n            if message.attachments:\n                for file in message.attachments:\n                    if file.filename.endswith('.jpg') or file.filename.endswith('.jpeg') or file.filename.endswith('.png') or file.filename.endswith('.gif'):\n                        url = file.proxy_url\n                        if message.content == '':\n                            content = \"[No written message content]\"\n                        else:\n                            content = message.content\n\n                        embed = Embed(description=f\"Message deleted in {message.channel.mention}\",\n                                                timestamp=datetime.utcnow(),\n                                                color=0xfc5f62)\n                        embed.set_author(name=message.author.display_name)\n                        embed.set_thumbnail(url=message.author.avatar.url)\n                        embed.add_field(name=\"Content:\", value=f\"{content}\", inline=False)\n                        embed.set_image(url=f\"{url}\")\n                        embed.set_footer(text=f'User ID: {message.author.id}\\nMessage ID: {message.id}')\n\n                        channelid = await db.logs.find_one({\"guild_id\":message.guild.id})\n                        id = channelid.channel_id\n                        log_channel = message.guild.get_channel(id)\n                        await log_channel.send(embed=embed)\n                        return\n                    else:\n                        url = file.proxy_url\n                        if message.content == '':\n                            content = \"[No written message content]\"\n                        else:\n                            content = message.content\n\n                        embed = Embed(description=f\"Message deleted in {message.channel.mention}\",\n                                                timestamp=datetime.utcnow(),\n                                                color=0xfc5f62)\n                        embed.set_author(name=message.author.display_name)\n                        embed.set_thumbnail(url=message.author.avatar.url)\n                        embed.add_field(name=\"Content:\", value=f\"{content}\\n\\n{url}\", inline=False)\n                        embed.set_footer(text=f'User ID: {message.author.id}\\nMessage ID: {message.id}')\n\n                        channelid = await db.logs.find_one({\"guild_id\":message.guild.id})\n                        id = channelid.channel_id\n                        log_channel = message.guild.get_channel(id)\n                        await log_channel.send(embed=embed)\n                        return\n\n    @listen()\n    async def on_message_delete_regular(self, event: MessageDelete):\n        message = event.message\n        if message.author.bot:\n            return\n        if await is_event_active(message.guild, 'message_deleted'):\n            if not message.attachments:\n                if geturl(message.content) is None:\n                    embed = Embed(description=f\"Message deleted in {message.channel.mention}\",\n                                            timestamp=datetime.utcnow(),\n                                            color=0xfc5f62)\n                    embed.set_author(name=message.author.display_name)\n                    embed.set_thumbnail(url=message.author.avatar.url)\n                    embed.add_field(name=\"Content:\", value=message.content, inline=False)\n                    embed.set_footer(text=f'User ID: {message.author.id}\\nMessage ID: {message.id}')\n\n                    channelid = await db.logs.find_one({\"guild_id\":message.guild.id})\n                    id = channelid.channel_id\n                    log_channel = message.guild.get_channel(id)\n                    await log_channel.send(embed=embed)\n\n    @listen()\n    async def on_message_delete_url(self, event: MessageDelete):\n        message = event.message\n        if message.author.bot:\n            return\n        if await is_event_active(message.guild, 'message_deleted'):\n            if not message.attachments:\n                if geturl(message.content) is not None:\n                    url = geturl(message.content)\n                    if url.endswith('.jpg') or url.endswith('.jpeg') or url.endswith('.png') or url.endswith('.gif'):\n                        content = message.content.replace(f'{url}', '')\n                        if content == '':\n                            content = \"[No written message content]\"\n\n                        embed = Embed(description=f\"Message deleted in {message.channel.mention}\",\n                                                timestamp=datetime.utcnow(),\n                                                color=0xfc5f62)\n                        embed.set_author(name=message.author.display_name)\n                        embed.set_thumbnail(url=message.author.avatar.url)\n                        embed.add_field(name=\"Content:\", value=content, inline=False)\n                        embed.set_image(url=url)\n                        embed.set_footer(text=f'User ID: {message.author.id}\\nMessage ID: {message.id}')\n\n                        channelid = await db.logs.find_one({\"guild_id\":message.guild.id})\n                        id = channelid.channel_id\n                        log_channel = message.guild.get_channel(id)\n                        await log_channel.send(embed=embed)\n                        return\n                    else:\n                        embed = Embed(description=f\"Message deleted in {message.channel.mention}\",\n                                                timestamp=datetime.utcnow(),\n                                                color=0xfc5f62)\n                        embed.set_author(name=message.author.display_name)\n                        embed.set_thumbnail(url=message.author.avatar.url)\n                        embed.add_field(name=\"Content:\", value=message.content, inline=False)\n                        embed.set_footer(text=f'User ID: {message.author.id}\\nMessage ID: {message.id}')\n\n                        channelid = await db.logs.find_one({\"guild_id\":message.guild.id})\n                        id = channelid.channel_id\n                        log_channel = message.guild.get_channel(id)\n                        await log_channel.send(embed=embed)\n                        return\n\n    @listen()\n    async def on_message_update(self, event:MessageUpdate):\n        if event.before is None:\n            return\n        before = event.before\n        after = event.after\n        if before.author.bot:\n            return\n        if await is_event_active(before.guild, 'message_edited'):\n            if before.content == after.content:\n                return\n\n            embed = Embed(description=f\"Message edited in {before.channel.mention}\\n[[Jump to message.]]({after.jump_url})\",\n                                    timestamp=datetime.utcnow(),\n                                    color=0xfcab5f)\n            embed.set_author(name=before.author.display_name)\n            embed.set_thumbnail(url=before.author.avatar.url)\n            embed.add_field(name=\"Original message\", value=before.content, inline=False)\n            embed.add_field(name=\"Edited message\", value=after.content, inline=False)\n            embed.set_footer(text=f'User ID: {before.author.id}\\nMessage ID: {before.id}')\n\n            channelid = await db.logs.find_one({\"guild_id\":before.guild.id})\n            id = channelid.channel_id\n            log_channel = before.guild.get_channel(id)\n            await log_channel.send(embed=embed)\n\n    @listen()\n    async def on_member_join(self, event: MemberAdd):\n        member = event.member\n\n        if await is_event_active(member.guild, 'member_join') == True:\n\n            channelid = await db.logs.find_one({\"guild_id\":member.guild.id})\n            id = channelid.channel_id\n            log_channel = member.guild.get_channel(id)\n\n            embed = Embed(description=f\"{member.mention} **|** {member.display_name} **joined** {member.guild.name}\",\n                                    timestamp=datetime.utcnow(),\n                                    color=0x4d9d54)\n            embed.set_thumbnail(url=member.avatar.url)\n            embed.add_field(name=\"Account created:\", value=f\"&lt;t:{math.ceil(member.created_at.timestamp())}:R&gt;\")\n            embed.set_footer(text=f'User ID: {member.id}')\n            await log_channel.send(embed=embed)\n\n    @listen()\n    async def on_member_leave(self, event: MemberRemove):\n        member = event.member\n        if await is_event_active(member.guild, 'member_leave') == True:\n            roles = [role.mention for role in member.roles if role.name != '@everyone']\n            rolecount = len(roles)\n            if rolecount == 0:\n                roles = 'None'\n            else:\n                roles = ' '.join(roles)\n\n            channelid = await db.logs.find_one({\"guild_id\":member.guild.id})\n            log_channel = member.guild.get_channel(channelid.channel_id)\n            embed = Embed(description=f\"{member.mention} **|** {member} **left** {member.guild.name}\",\n                                    timestamp=datetime.utcnow(),\n                                    color=0xcb4c4c)\n            embed.set_thumbnail(url=member.avatar.url)\n            embed.add_field(name=f'Roles: [{rolecount}]', value=roles)\n            embed.set_footer(text=f'User ID: {member.id}')\n            await log_channel.send(embed=embed)\n\n    @listen()\n    async def on_member_role_remove(self, event: MemberUpdate):\n        member = event.after\n        if await is_event_active(member.guild, 'member_roles') == True:\n            before_roles = event.before.roles\n            after_roles = event.after.roles\n\n            roles_list = [role.mention for role in before_roles if role not in after_roles]\n            if roles_list != []:\n                roles = ''\n                for role in roles_list:\n                    roles = roles + f'{role} '\n                embed = Embed(description=f\"`{member}` **got removed** {roles} \",\n                                            color=0xffcc50)\n\n                channelid = await db.logs.find_one({\"guild_id\":member.guild.id})\n                log_channel = member.guild.get_channel(channelid.channel_id)\n                await log_channel.send(embed=embed)\n\n    @listen()\n    async def on_member_role_add(self, event: MemberUpdate):\n        member = event.after\n        if await is_event_active(member.guild, 'member_roles') == True:\n            before_roles = event.before.roles\n            after_roles = event.after.roles\n\n            roles_list = [role.mention for role in after_roles if role not in before_roles]\n            if roles_list != []:\n                roles = ''\n                for role in roles_list:\n                    roles = roles + f'{role} '\n                embed = Embed(description=f\"`{member}` **got assigned** {roles} \",\n                                            color=0xffcc50)\n\n                channelid = await db.logs.find_one({\"guild_id\":member.guild.id})\n                log_channel = member.guild.get_channel(channelid.channel_id)\n                await log_channel.send(embed=embed)\n\n    @listen()\n    async def on_member_nickname_change(self, event: MemberUpdate):\n        member = event.after\n        if await is_event_active(member.guild, 'member_nick') == True:\n            before = event.before\n            after = event.after\n\n            if before.display_name != after.display_name:\n                embed = Embed(description=f\"`{member}` changed their nickname\",\n                                        color=0xffcc50)\n                embed.set_thumbnail(url=after.avatar.url)\n                embed.add_field(name=\"Before\", value=before.display_name)\n                embed.add_field(name=\"After\", value=after.display_name)\n\n                channelid = await db.logs.find_one({\"guild_id\":member.guild.id})\n                log_channel = member.guild.get_channel(channelid.channel_id)\n                await log_channel.send(embed=embed)\n\n    @listen()\n    async def on_member_update_timeout_remove(self, event: MemberUpdate):\n        member_after = event.after\n        if event.after.communication_disabled_until is MISSING and event.before.communication_disabled_until is MISSING:\n            return\n        if event.after.communication_disabled_until is None and event.before.communication_disabled_until is None:\n            return\n        if event.after.communication_disabled_until == event.before.communication_disabled_until:\n            return\n        if (member_after.communication_disabled_until is None) and (await is_event_active(event.guild, 'member_timeout') == True):\n            audit_log_entry = await event.guild.fetch_audit_log(action_type=24, limit=1)\n            for au_entry in audit_log_entry.entries:\n                entry_created_at = snowflake_time(au_entry.id)\n                cdiff = date_diff_in_Seconds(datetime.now(tz=timezone.utc), entry_created_at.replace(tzinfo=timezone.utc))\n                if cdiff &lt;= 60:\n                    reason = au_entry.reason\n                    for au_user in audit_log_entry.users:\n                        if au_entry.target_id == au_user.id:\n                            target = au_user\n                        elif au_entry.user_id == au_user.id:\n                            moderator = au_user\n                    if target.id == member_after.id:\n                        embed = Embed(description=f\"{target} **was unmuted** | {reason} \\n**User ID:** {target.id} \\n**Actioned by:** {moderator}\",\n                                        color=0xffcc50,\n                                        timestamp=datetime.utcnow())\n                        embed.set_thumbnail(url=target.avatar.url)\n\n                        channelid = await db.logs.find_one({\"guild_id\":event.guild_id})\n                        log_channel = event.guild.get_channel(channelid.channel_id)\n                        await log_channel.send(embed=embed)\n\n    @listen()\n    async def on_member_update_timeout_add(self, event: MemberUpdate):\n        member_after = event.after\n        if event.after.communication_disabled_until is MISSING and event.before.communication_disabled_until is MISSING:\n            return\n        if event.after.communication_disabled_until is None and event.before.communication_disabled_until is None:\n            return\n        if event.after.communication_disabled_until == event.before.communication_disabled_until:\n            return\n        if member_after.communication_disabled_until is not None:\n            timeout_timestamp = f'{member_after.communication_disabled_until}'.replace('&lt;t:', '')\n            timeout_timestamp = timeout_timestamp.replace('&gt;', '')\n            timeout_timestamp = int(timeout_timestamp)\n            dt = datetime.fromtimestamp(timeout_timestamp)\n            dt = dt.replace(tzinfo=timezone.utc)\n            audit_log_entry = await event.guild.fetch_audit_log(action_type=24, limit=1)\n            for au_entry in audit_log_entry.entries:\n                entry_created_at = snowflake_time(au_entry.id)\n                cdiff = date_diff_in_Seconds(datetime.now(tz=timezone.utc), entry_created_at.replace(tzinfo=timezone.utc))\n                if cdiff &lt;= 60:\n                    reason = au_entry.reason\n                    for au_user in audit_log_entry.users:\n                        if au_entry.target_id == au_user.id:\n                            target = au_user\n                        elif au_entry.user_id == au_user.id:\n                            moderator = au_user\n            if target.id == member_after.id:\n                if (member_after.communication_disabled_until is not None) and (dt &gt; datetime.now(tz=timezone.utc)):\n                    if await is_event_active(event.guild, 'member_timeout') == True:\n                        mute_time = f'{member_after.communication_disabled_until}'.replace('&gt;', ':R&gt;')\n                        embed = Embed(description=f\"{target} **was muted** | {reason} \\n**User ID:** {target.id} \\n**Actioned by:** {moderator}\\n**End time:**{mute_time}\",\n                                        color=0xffcc50,\n                                        timestamp=datetime.utcnow())\n                        embed.set_thumbnail(url=target.avatar.url)\n\n                        channelid = await db.logs.find_one({\"guild_id\":event.guild_id})\n                        log_channel = event.guild.get_channel(channelid.channel_id)\n                        await log_channel.send(embed=embed)\n\n                    daytime = f'&lt;t:{math.ceil(datetime.now().timestamp())}&gt;'\n\n                    while True:\n                        muteid = random_string_generator()\n                        muteid_db = await db.strikes.find_one({'guildid':event.guild_id, 'strikeid':muteid})\n                        if muteid_db is None:\n                            break\n                        else:\n                            continue\n                    await db.strikes(strikeid=muteid, guildid=event.guild_id, user=target.id, moderator=moderator.id, action=\"Mute\", day=daytime, reason=reason).insert()\n\n    @listen()\n    async def audit_log_kick_create(self, event: GuildAuditLogEntryCreate):\n        audit_log = event.audit_log_entry\n        guild = event.guild\n        if audit_log.action_type == 20:\n            moderator = guild.get_member(audit_log.user_id)\n            target = guild.get_member(audit_log.target_id)\n            if target is None:\n                target = await self.bot.fetch_user(audit_log.target_id)\n            reason = audit_log.reason\n            if await is_event_active(guild, 'member_kick'):\n                channelid = await db.logs.find_one({\"guild_id\":guild.id})\n                log_channel = guild.get_channel(channelid.channel_id)\n                embed = Embed(description=f'{moderator.mention}**[**{moderator}**|**{moderator.id}**]** **kicked** {target.mention}**[**{target}**|**{target.id}**]** **|** `{reason}`',\n                                        timestamp=datetime.utcnow(),\n                                        color=0x5c7fb0)\n                embed.set_thumbnail(url=target.avatar.url)\n                await log_channel.send(embed=embed)\n\n            daytime = f'&lt;t:{math.ceil(datetime.now().timestamp())}&gt;'\n            await db.strikes(strikeid=await strike_id_gen(guild), guildid=event.guild_id, user=target.id, moderator=moderator.id, action=\"Kick\", day=daytime, reason=reason).insert()\n\n    @listen()\n    async def audit_log_ban_create(self, event: GuildAuditLogEntryCreate):\n        audit_log = event.audit_log_entry\n        guild = event.guild\n        if audit_log.action_type == 22:\n            moderator = guild.get_member(audit_log.user_id)\n            target = guild.get_member(audit_log.target_id)\n            if target is None:\n                target = await self.bot.fetch_user(audit_log.target_id)\n            reason = audit_log.reason\n            if await is_event_active(guild, 'member_ban'):\n                channelid = await db.logs.find_one({\"guild_id\":guild.id})\n                log_channel = guild.get_channel(channelid.channel_id)\n\n                embed = Embed(description=f'{moderator.mention}**[**{moderator}**|**{moderator.id}**]** **banned** {target.mention}**[**{target}**|**{target.id}**]** **|** `{reason}`',\n                                        timestamp=datetime.utcnow(),\n                                        color=0x62285e)\n                embed.set_thumbnail(url=target.avatar.url)\n                await log_channel.send(embed=embed)\n\n            daytime = f'&lt;t:{math.ceil(datetime.now().timestamp())}&gt;'\n            await db.strikes(strikeid=await strike_id_gen(guild), guildid=guild.id, user=target.id, moderator=moderator.id, action=\"Ban\", day=daytime, reason=reason).insert()\n\n    @listen()\n    async def audit_log_unban_create(self, event: GuildAuditLogEntryCreate):\n        audit_log = event.audit_log_entry\n        guild = event.guild\n        if audit_log.action_type == 23:\n            moderator = guild.get_member(audit_log.user_id)\n            target = guild.get_member(audit_log.target_id)\n            if target is None:\n                target = await self.bot.fetch_user(audit_log.target_id)\n            reason = audit_log.reason\n            if await is_event_active(guild, 'member_unban'):\n                channelid = await db.logs.find_one({\"guild_id\":guild.id})\n                log_channel = guild.get_channel(channelid.channel_id)\n\n                embed = Embed(description=f'{moderator.mention}**[**{moderator}**|**{moderator.id}**]** **unbanned** {target.mention}**[**{target}**|**{target.id}**]** **|** `{reason}`',\n                                        timestamp=datetime.utcnow(),\n                                        color=0x9275b2)\n                embed.set_thumbnail(url=target.avatar.url)\n                await log_channel.send(embed=embed)\n\n            daytime = f'&lt;t:{math.ceil(datetime.now().timestamp())}&gt;'\n            await db.strikes(strikeid=await strike_id_gen(guild), guildid=guild.id, user=target.id, moderator=moderator.id, action=\"Unban\", day=daytime, reason=reason).insert()\n\n    @listen()\n    async def welcome_message(self, event: MemberAdd):\n        member = event.member\n        user = event.member\n        guild = event.member.guild\n        if await is_event_active(member.guild, 'welcome_msg') == True:\n            wm = await db.welcome_msg.find_one({\"guildid\":member.guild.id})\n            if wm is not None:\n                if wm.channelid is not None:\n                    wchannel = member.guild.get_channel(wm.channelid)\n                    if wchannel is not None:\n                        if await is_event_active(member.guild, 'welcome_msg_card') == True:\n                            def round(im):\n                                im = im.resize((210*16,210*16), resample=Image.ANTIALIAS)\n                                mask = Image.new(\"L\", im.size, 0)\n                                draw = ImageDraw.Draw(mask)\n                                draw.ellipse((0,0)+im.size, fill=255)\n                                out = ImageOps.fit(im, mask.size, centering=(0,0))\n                                out.putalpha(mask)\n                                image = out.resize((210,210), resample=Image.ANTIALIAS).convert(\"RGBA\")\n                                return image\n\n                            IW, IH = (956, 435)\n\n                            if wm.background_url is not None:\n                                background = Image.open(requests.get(f'{wm.background_url}', stream=True).raw).crop((0,0,IW,IH)).convert(\"RGBA\")\n                            else:\n                                background = Image.open(requests.get('https://i.imgur.com/5FL6qEm.png', stream=True).raw).convert(\"RGBA\")\n\n                            overlay = Image.open(requests.get('https://i.imgur.com/Bu4STJz.png', stream=True).raw).convert(\"RGBA\")\n                            background.paste(overlay, (0, 0), overlay)\n\n                            pfp = round(Image.open(requests.get(f'{event.member.avatar.url}.png', stream=True).raw).resize((230,230)).convert(\"RGBA\"))\n                            background.paste(pfp, (373, 42), pfp)\n\n                            font = ImageFont.truetype('Everson-Mono-Bold.ttf', 45)\n                            card = ImageDraw.Draw(background)\n                            memname = f\"{member.display_name}\\nMember #{len(member.guild.members)}\"\n                            tw, th = card.textsize(memname, font)\n                            card.text((((IW-tw)/2),283), memname, font=font, stroke_width=2, align=\"center\", stroke_fill=(30, 27, 26), fill=(255, 255, 255))\n                            background.save(f'welcomecard_{member.id}.png')\n                            if wm.message  is not None:\n                                await wchannel.send(wm.message.format(user=user, member=member, guild=guild), file=f'welcomecard_{member.id}.png')\n                            elif wm.message is None:\n                                await wchannel.send(file=f'welcomecard_{member.id}.png')\n                            os.remove(f'welcomecard_{member.id}.png')\n                        else:\n                            if wm.message is not None:\n                                await wchannel.send(wm.message.format(user=user, member=member, guild=guild))\n\n    @listen()\n    async def special_welcome_message(self, event: MemberUpdate):\n        member = event.after\n        user = event.after\n        guild = event.after.guild\n        if await is_event_active(member.guild, 'special_welcome_msg') == True:\n            before_roles = event.before.roles\n            after_roles = event.after.roles\n            ignore_roles = [role for role in before_roles if role.name in ['Muted', 'Limbo']]\n            if ignore_roles == []:\n                roles_list = [role for role in after_roles if role not in before_roles if role.name == 'Gravity Falls Citizens']\n                if roles_list != []:\n                    wm = await db.special_welcome_msg.find_one({\"guildid\":member.guild.id})\n                    if wm is not None:\n                        if wm.channelid is not None:\n                            wchannel = member.guild.get_channel(wm.channelid)\n                            if (wchannel is not None) and (wm.message is not None):\n                                return await wchannel.send(wm.message.format(user=user, member=member, guild=guild))\n\n    @listen()\n    async def leave_message(self, event: MemberRemove):\n        member = event.member\n        user = event.member\n        guild = event.member.guild\n        if await is_event_active(member.guild, 'leave_msg') == True:\n            lm = await db.leave_msg.find_one({\"guildid\":member.guild.id})\n            if lm is not None:\n                if lm.channelid is not None:\n                    lchannel = member.guild.get_channel(lm.channelid)\n                    if (lm.message and lchannel) is not None:\n                        await lchannel.send(lm.message.format(user=user, member=member, guild=guild))\n</code></pre>"},{"location":"event_logs/#extentions.event_logs.EventLogs.logchannel","title":"<code>logchannel(ctx, channel=None)</code>  <code>async</code>","text":"<p>/logchannel</p> Description <p>set up a logging channel</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>OptionType.CHANNEL</code> <p>CHannel to send log messages in.</p> <code>None</code> Source code in <code>extentions/event_logs.py</code> <pre><code>@slash_command(name='logchannel', description=\"set up a logging channel\",\n    default_member_permissions=Permissions.ADMINISTRATOR\n)\n@channel()\nasync def logchannel(self, ctx: InteractionContext, channel:OptionType.CHANNEL=None):\n\"\"\"/logchannel\n    Description:\n        set up a logging channel\n\n    Args:\n        channel (OptionType.CHANNEL, optional): CHannel to send log messages in.\n    \"\"\"\n    if channel is None:\n        channel = ctx.channel\n\n    log_entry = await db.logs.find_one({\"guild_id\":ctx.guild_id})\n    if log_entry is None:\n        await db.logs(guild_id=ctx.guild_id, channel_id=channel.id).save()\n        embed = Embed(description=f\"I have assigned {channel.mention} as a log channel.\",\n                              color=0xffcc50)\n        await ctx.send(embed=embed)\n    else:\n        log_entry.channel_id = channel.id\n        await log_entry.save()\n        embed = Embed(description=f\"I have updated {channel.mention} as a log channel.\",\n                              color=0xffcc50)\n        await ctx.send(embed=embed)\n</code></pre>"},{"location":"event_logs/#extentions.event_logs.EventLogs.welcome_message_cmd","title":"<code>welcome_message_cmd(ctx, welcome_message_text=None, channel=None)</code>  <code>async</code>","text":"<p>/welcomemessage</p> Description <p>set up a welcome message and channel</p> <p>Parameters:</p> Name Type Description Default <code>welcome_message_text</code> <code>OptionType.STRING</code> <p>Welcome message text.</p> <code>None</code> <code>channel</code> <code>OptionType.CHANNEL</code> <p>Welcome message channel.</p> <code>None</code> Source code in <code>extentions/event_logs.py</code> <pre><code>@slash_command(name='welcomemessage', description=\"set up a welcome message and channel\",\n    default_member_permissions=Permissions.ADMINISTRATOR\n)\n@welcome_message_text()\n@channel()\nasync def welcome_message_cmd(self, ctx: InteractionContext, welcome_message_text:OptionType.STRING=None, channel:OptionType.CHANNEL=None):\n\"\"\"/welcomemessage\n    Description:\n        set up a welcome message and channel\n\n    Args:\n        welcome_message_text (OptionType.STRING, optional): Welcome message text.\n        channel (OptionType.CHANNEL, optional): Welcome message channel.\n    \"\"\"\n    if (channel is None) and (welcome_message_text is None):\n        embed = Embed(\n            description=\":x: Please provide a channel or welcome message\",\n            color=0xDD2222)\n        await ctx.send(embed=embed)\n        return\n\n    log_entry = await db.welcome_msg.find_one({\"guildid\":ctx.guild_id})\n    if log_entry is None:\n        up_msg = ''\n        if welcome_message_text is not None:\n            up_msg = up_msg + f\"I have updated `{welcome_message_text}` as a welcome message.\\n\"\n\n        if channel is not None:\n            up_msg = up_msg + f\"I have updated {channel.mention} as a welcome channel.\"\n            channel = channel.id\n        elif channel is None:\n            channel = None\n        await db.welcome_msg(guildid=ctx.guild_id, channelid=channel, message=welcome_message_text).save()\n        embed = Embed(description=up_msg,\n                              color=0xffcc50)\n        await ctx.send(embed=embed)\n    else:\n        up_msg = ''\n        if welcome_message_text is not None:\n            log_entry.message = welcome_message_text\n            up_msg = up_msg + f\"I have updated `{welcome_message_text}` as a welcome message.\\n\"\n\n        if channel is not None:\n            log_entry.channelid = channel.id\n            up_msg = up_msg + f\"I have updated {channel.mention} as a welcome channel.\"\n\n        await log_entry.save()\n        embed = Embed(description=up_msg,\n                              color=0xffcc50)\n        await ctx.send(embed=embed)\n</code></pre>"},{"location":"event_logs/#extentions.event_logs.EventLogs.leave_message_cmd","title":"<code>leave_message_cmd(ctx, leave_message_text=None, channel=None)</code>  <code>async</code>","text":"<p>/leavemessage</p> Description <p>set up a leave message and channel</p> <p>Parameters:</p> Name Type Description Default <code>leave_message_text</code> <code>OptionType.STRING</code> <p>Leave message text.</p> <code>None</code> <code>channel</code> <code>OptionType.CHANNEL</code> <p>Leave message channel.</p> <code>None</code> Source code in <code>extentions/event_logs.py</code> <pre><code>@slash_command(name='leavemessage', description=\"set up a leave message and channel\",\n    default_member_permissions=Permissions.ADMINISTRATOR\n)\n@leave_message_text()\n@channel()\nasync def leave_message_cmd(self, ctx: InteractionContext, leave_message_text:OptionType.STRING=None, channel:OptionType.CHANNEL=None):\n\"\"\"/leavemessage\n    Description:\n        set up a leave message and channel\n\n    Args:\n        leave_message_text (OptionType.STRING, optional): Leave message text.\n        channel (OptionType.CHANNEL, optional): Leave message channel.\n    \"\"\"\n    if (channel is None) and (leave_message_text is None):\n        embed = Embed(\n            description=\":x: Please provide a channel or leave message\",\n            color=0xDD2222)\n        await ctx.send(embed=embed)\n        return\n\n    log_entry = await db.leave_msg.find_one({\"guildid\":ctx.guild_id})\n    if log_entry is None:\n        up_msg = ''\n        if leave_message_text is not None:\n            up_msg = up_msg + f\"I have updated `{leave_message_text}` as a leave message.\\n\"\n\n        if channel is not None:\n            up_msg = up_msg + f\"I have updated {channel.mention} as a leave channel.\"\n            channel = channel.id\n        elif channel is None:\n            channel = None\n        await db.leave_msg(guildid=ctx.guild_id, channelid=channel, message=leave_message_text).save()\n        embed = Embed(description=up_msg,\n                              color=0xffcc50)\n        await ctx.send(embed=embed)\n    else:\n        up_msg = ''\n        if leave_message_text is not None:\n            log_entry.message = leave_message_text\n            up_msg = up_msg + f\"I have updated `{leave_message_text}` as a leave message.\\n\"\n\n        if channel is not None:\n            log_entry.channelid = channel.id\n            up_msg = up_msg + f\"I have updated {channel.mention} as a leave channel.\"\n\n        await log_entry.save()\n        embed = Embed(description=up_msg,\n                              color=0xffcc50)\n        await ctx.send(embed=embed)\n</code></pre>"},{"location":"giveroles/","title":"Giveroles","text":"<p>         Bases: <code>Extension</code></p> Source code in <code>extentions/giveroles.py</code> <pre><code>class GiveRoles(Extension):\n    def __init__(self, bot: Client):\n        self.bot = bot\n\n    give_cmd = SlashCommand(name='give', default_member_permissions=Permissions.BAN_MEMBERS)\n    giveyou_cmd = SlashCommand(name='giveyou', default_member_permissions=Permissions.BAN_MEMBERS)\n\n    @give_cmd.subcommand(sub_cmd_name='you', sub_cmd_description=\"Give members a role from predefined list of roles\")\n    @user()\n    @giveyou_name()\n    async def giveyourole(self, ctx: InteractionContext, user:OptionType.USER=None, giveyou_name:str=None):\n\"\"\"/giveyou\n        Description:\n            Give members a role from predefined list of roles\n\n        Args:\n            user (OptionType.USER, optional): User to give or remove role from\n            giveyou_name (str, optional): Name of the giveyou.\n        \"\"\"\n        if user is None:\n            return await ctx.send(embed=Embed(color=0xDD2222, description=\":x: Please provide a user\"), ephemeral=True)\n        if giveyou_name is None:\n            return await ctx.send(embed=Embed(color=0xDD2222, description=\":x: Please provide a giveyou name\"), ephemeral=True)\n\n\n        regx = {'$regex': f\"^{re.escape(giveyou_name)}$\", '$options':'i'}\n        gy = await db.giveyou.find_one({'name':regx, 'guildid': ctx.guild_id})\n\n        if gy is None:\n            return await ctx.send(embed=Embed(color=0xDD2222, description=f\":x: Couldn't find `{giveyou_name}` as a giveyou for {ctx.guild.name}\"), ephemeral=True)\n\n        role = ctx.guild.get_role(gy.roleid)\n\n        if role in user.roles:\n            await user.remove_role(role, reason=f'{ctx.author.display_name}|{ctx.author.id} removed a giveyou {giveyou_name}')\n            embed = Embed(\n                description=f\"I have removed {role.mention} from {user.mention}\",\n                color=0xffcc50)\n        elif role not in user.roles:\n            await user.add_role(role, reason=f'{ctx.author.display_name}|{ctx.author.id} assigned a giveyou {giveyou_name}')\n            embed = Embed(\n                description=f\"I have assigned {role.mention} to {user.mention}\",\n                color=0xffcc50)\n        await ctx.send(embed=embed)\n\n    @giveyou_cmd.subcommand(sub_cmd_name='create', sub_cmd_description=\"Create giveyou's\")\n    @giveyou_name()\n    @role()\n    async def giveyourole_create(self, ctx: InteractionContext, giveyou_name:str=None, role:OptionType.ROLE=None):\n\"\"\"/giveyou create\n        Description:\n            Create a giveyou role.\n        Args:\n            giveyou_name (str, optional): Name of the giveyou.\n            role (OptionType.ROLE, optional): Role associated with the giveyou.\n        \"\"\"\n        if giveyou_name is None:\n            return await ctx.send(embed=Embed(color=0xDD2222, description=\":x: Please provide a giveyou name\"), ephemeral=True)\n        if role is None:\n            return await ctx.send(embed=Embed(color=0xDD2222, description=\":x: Please provide a role\"), ephemeral=True)\n\n\n        regx = {'$regex': f\"^{re.escape(giveyou_name)}$\", '$options':'i'}\n        gy = await db.giveyou.find_one({'name':regx, 'guildid': ctx.guild_id})\n\n        if gy is not None:\n            return await ctx.send(embed=Embed(color=0xDD2222, description=f\":x: `{giveyou_name}` already exists as a giveyou for {ctx.guild.name}\"), ephemeral=True)\n\n        while True:\n            gyid = random_string_generator()\n            gyid_db = await db.giveyou.find_one({'guildid':ctx.guild.id, 'giveyou_id':gyid})\n            if gyid_db is None:\n                break\n            else:\n                continue\n\n        await db.giveyou(guildid=ctx.guild_id, name=giveyou_name, roleid=role.id, giveyou_id=gyid).insert()\n        await ctx.send(embed=Embed(color=0xffcc50, description=f\"giveyou `{giveyou_name}` created for {role.mention}\"))\n\n    @giveyou_cmd.subcommand(sub_cmd_name='delete', sub_cmd_description=\"Delete giveyou's\")\n    @giveyou_name()\n    async def giveyourole_delete(self, ctx: InteractionContext, giveyou_name:str=None):\n\"\"\"/giveyou delete\n        Description:\n            Delete a giveyou\n\n        Args:\n            giveyou_name (str, optional): Name of the giveyou to delete.\n        \"\"\"\n        if giveyou_name is None:\n            return await ctx.send(embed=Embed(color=0xDD2222, description=\":x: Please provide a giveyou name\"), ephemeral=True)\n\n        regx = {'$regex': f\"^{re.escape(giveyou_name)}$\", '$options':'i'}\n        gy = await db.giveyou.find_one({'name':regx, 'guildid': ctx.guild_id})\n\n        if gy is not None:\n            return await ctx.send(embed=Embed(color=0xDD2222, description=f\":x: `{giveyou_name}` is not a giveyou for {ctx.guild.name}\"), ephemeral=True)\n\n        role = ctx.guild.get_role(gy.roleid)\n        await ctx.send(embed=Embed(color=0xffcc50, description=f\"giveyou `{giveyou_name}` deleted from {role.mention}\"))\n        await gy.delete()\n\n    @giveyou_cmd.subcommand( sub_cmd_name='list', sub_cmd_description=\"Lists all giveyous for guild\")\n    async def giveyourole_list(self, ctx: InteractionContext):\n\"\"\"/giveyou list\n        Description:\n            List all giveyous\n        \"\"\"\n        from interactions.ext.paginators import Paginator\n        def chunks(l, n):\n            n = max(1, n)\n            return (l[i:i+n] for i in range(0, len(l), n))\n\n        def page_list(lst, s, e):\n            nc = list(chunks(lst, 20))\n            mc = ''\n            for testlist in nc[s:e]:\n                for m in testlist:\n                    mc = mc + m\n            return mc\n\n        def newpage(title, names, roles):\n            embed = Embed(title=title,\n            color=0xffcc50)\n            embed.add_field(name='Giveyou', value=names, inline=True)\n            embed.add_field(name='Role', value=roles, inline=True)\n            return embed\n\n\n        gy = db.giveyou.find({\"guildid\":ctx.guild_id})\n        names = []\n        roles = []\n        async for g in gy:\n            names.append(f\"{g.name}\\n\")\n            role = ctx.guild.get_role(g.roleid)\n            if role is None:\n                roles.append(f'[ROLE NOT FOUND]({g.roleid})\\n')\n            else:\n                roles.append(f\"{role.mention}\\n\")\n        if names == []:\n            embed = Embed(description=f\"There are no giveyous for {ctx.guild.name}.\",\n                        color=0xffcc50)\n            await ctx.send(embed=embed)\n            return\n        s = -1\n        e = 0\n        embedcount = 1\n        nc = list(chunks(names, 20))\n\n        embeds = []\n        while embedcount &lt;= len(nc):\n            s = s+1\n            e = e+1\n            embeds.append(newpage(f'List of giveyous for {ctx.guild.name}', page_list(names, s, e), page_list(roles, s, e)))\n            embedcount = embedcount+1\n\n        paginator = Paginator(\n            client=self.bot, \n            pages=embeds,\n            timeout_interval=80,\n            show_select_menu=False)\n        await paginator.send(ctx)\n\n    @slash_command(name='role', description=\"Add/remove users to a role or roles\",\n        default_member_permissions=Permissions.MANAGE_ROLES\n    )\n    @members()\n    @roles()\n    async def give_role(self, ctx: InteractionContext, members:str=None, roles:str=None):\n\"\"\"/give role\n        Description:\n            Add/remove users to a role or roles\n        Args:\n            members (str, optional): Members IDs or @member, seperated by a comma `,`\n            roles (str, optional): Roles IDs or @role, seperated by a comma `,`\n        \"\"\"\n        if members is None:\n            return await ctx.send(embed=Embed(color=0xDD2222, description=\":x: Please provide a user\"), ephemeral=True)\n        if roles is None:\n            return await ctx.send(embed=Embed(color=0xDD2222, description=\":x: Please provide a role\"), ephemeral=True)\n\n        raw_mem_list = members.split(',')\n        member_list =[]\n        for m in raw_mem_list:\n            m = m.replace('&lt;', '')\n            m = m.replace('@', '')\n            m = m.replace('!', '')\n            m = m.replace('&amp;', '')\n            m = m.replace('&gt;', '')\n            member_list.append(m)\n\n        raw_roles_list = roles.split(',')\n        roles_list = []\n        for r in raw_roles_list:\n            r = r.replace('&lt;', '')\n            r = r.replace('@', '')\n            r = r.replace('!', '')\n            r = r.replace('&amp;', '')\n            r = r.replace('&gt;', '')\n            roles_list.append(r)\n\n        for member_id in member_list:\n            member = ctx.guild.get_member(member_id)\n            removed_roles = 'I have removed: '\n            added_roles = 'I have assigned: '\n            for role_id in roles_list:\n                role = ctx.guild.get_role(role_id)\n                if member.has_role(role) == True:\n                    await member.remove_role(role)\n                    removed_roles = removed_roles + f' {role.mention}'\n                else:\n                    await member.add_role(role)\n                    added_roles = added_roles + f' {role.mention}'\n            embed = Embed(description=f'Roles changed for {member.mention}\\n\\n{added_roles}\\n\\n{removed_roles}', color=0xffcc50)\n            await ctx.send(embed=embed)\n</code></pre>"},{"location":"giveroles/#extentions.giveroles.GiveRoles.giveyourole","title":"<code>giveyourole(ctx, user=None, giveyou_name=None)</code>  <code>async</code>","text":"<p>/giveyou</p> Description <p>Give members a role from predefined list of roles</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>OptionType.USER</code> <p>User to give or remove role from</p> <code>None</code> <code>giveyou_name</code> <code>str</code> <p>Name of the giveyou.</p> <code>None</code> Source code in <code>extentions/giveroles.py</code> <pre><code>@give_cmd.subcommand(sub_cmd_name='you', sub_cmd_description=\"Give members a role from predefined list of roles\")\n@user()\n@giveyou_name()\nasync def giveyourole(self, ctx: InteractionContext, user:OptionType.USER=None, giveyou_name:str=None):\n\"\"\"/giveyou\n    Description:\n        Give members a role from predefined list of roles\n\n    Args:\n        user (OptionType.USER, optional): User to give or remove role from\n        giveyou_name (str, optional): Name of the giveyou.\n    \"\"\"\n    if user is None:\n        return await ctx.send(embed=Embed(color=0xDD2222, description=\":x: Please provide a user\"), ephemeral=True)\n    if giveyou_name is None:\n        return await ctx.send(embed=Embed(color=0xDD2222, description=\":x: Please provide a giveyou name\"), ephemeral=True)\n\n\n    regx = {'$regex': f\"^{re.escape(giveyou_name)}$\", '$options':'i'}\n    gy = await db.giveyou.find_one({'name':regx, 'guildid': ctx.guild_id})\n\n    if gy is None:\n        return await ctx.send(embed=Embed(color=0xDD2222, description=f\":x: Couldn't find `{giveyou_name}` as a giveyou for {ctx.guild.name}\"), ephemeral=True)\n\n    role = ctx.guild.get_role(gy.roleid)\n\n    if role in user.roles:\n        await user.remove_role(role, reason=f'{ctx.author.display_name}|{ctx.author.id} removed a giveyou {giveyou_name}')\n        embed = Embed(\n            description=f\"I have removed {role.mention} from {user.mention}\",\n            color=0xffcc50)\n    elif role not in user.roles:\n        await user.add_role(role, reason=f'{ctx.author.display_name}|{ctx.author.id} assigned a giveyou {giveyou_name}')\n        embed = Embed(\n            description=f\"I have assigned {role.mention} to {user.mention}\",\n            color=0xffcc50)\n    await ctx.send(embed=embed)\n</code></pre>"},{"location":"giveroles/#extentions.giveroles.GiveRoles.giveyourole_create","title":"<code>giveyourole_create(ctx, giveyou_name=None, role=None)</code>  <code>async</code>","text":"<p>/giveyou create</p> Description <p>Create a giveyou role.</p> <p>Parameters:</p> Name Type Description Default <code>giveyou_name</code> <code>str</code> <p>Name of the giveyou.</p> <code>None</code> <code>role</code> <code>OptionType.ROLE</code> <p>Role associated with the giveyou.</p> <code>None</code> Source code in <code>extentions/giveroles.py</code> <pre><code>@giveyou_cmd.subcommand(sub_cmd_name='create', sub_cmd_description=\"Create giveyou's\")\n@giveyou_name()\n@role()\nasync def giveyourole_create(self, ctx: InteractionContext, giveyou_name:str=None, role:OptionType.ROLE=None):\n\"\"\"/giveyou create\n    Description:\n        Create a giveyou role.\n    Args:\n        giveyou_name (str, optional): Name of the giveyou.\n        role (OptionType.ROLE, optional): Role associated with the giveyou.\n    \"\"\"\n    if giveyou_name is None:\n        return await ctx.send(embed=Embed(color=0xDD2222, description=\":x: Please provide a giveyou name\"), ephemeral=True)\n    if role is None:\n        return await ctx.send(embed=Embed(color=0xDD2222, description=\":x: Please provide a role\"), ephemeral=True)\n\n\n    regx = {'$regex': f\"^{re.escape(giveyou_name)}$\", '$options':'i'}\n    gy = await db.giveyou.find_one({'name':regx, 'guildid': ctx.guild_id})\n\n    if gy is not None:\n        return await ctx.send(embed=Embed(color=0xDD2222, description=f\":x: `{giveyou_name}` already exists as a giveyou for {ctx.guild.name}\"), ephemeral=True)\n\n    while True:\n        gyid = random_string_generator()\n        gyid_db = await db.giveyou.find_one({'guildid':ctx.guild.id, 'giveyou_id':gyid})\n        if gyid_db is None:\n            break\n        else:\n            continue\n\n    await db.giveyou(guildid=ctx.guild_id, name=giveyou_name, roleid=role.id, giveyou_id=gyid).insert()\n    await ctx.send(embed=Embed(color=0xffcc50, description=f\"giveyou `{giveyou_name}` created for {role.mention}\"))\n</code></pre>"},{"location":"giveroles/#extentions.giveroles.GiveRoles.giveyourole_delete","title":"<code>giveyourole_delete(ctx, giveyou_name=None)</code>  <code>async</code>","text":"<p>/giveyou delete</p> Description <p>Delete a giveyou</p> <p>Parameters:</p> Name Type Description Default <code>giveyou_name</code> <code>str</code> <p>Name of the giveyou to delete.</p> <code>None</code> Source code in <code>extentions/giveroles.py</code> <pre><code>@giveyou_cmd.subcommand(sub_cmd_name='delete', sub_cmd_description=\"Delete giveyou's\")\n@giveyou_name()\nasync def giveyourole_delete(self, ctx: InteractionContext, giveyou_name:str=None):\n\"\"\"/giveyou delete\n    Description:\n        Delete a giveyou\n\n    Args:\n        giveyou_name (str, optional): Name of the giveyou to delete.\n    \"\"\"\n    if giveyou_name is None:\n        return await ctx.send(embed=Embed(color=0xDD2222, description=\":x: Please provide a giveyou name\"), ephemeral=True)\n\n    regx = {'$regex': f\"^{re.escape(giveyou_name)}$\", '$options':'i'}\n    gy = await db.giveyou.find_one({'name':regx, 'guildid': ctx.guild_id})\n\n    if gy is not None:\n        return await ctx.send(embed=Embed(color=0xDD2222, description=f\":x: `{giveyou_name}` is not a giveyou for {ctx.guild.name}\"), ephemeral=True)\n\n    role = ctx.guild.get_role(gy.roleid)\n    await ctx.send(embed=Embed(color=0xffcc50, description=f\"giveyou `{giveyou_name}` deleted from {role.mention}\"))\n    await gy.delete()\n</code></pre>"},{"location":"giveroles/#extentions.giveroles.GiveRoles.giveyourole_list","title":"<code>giveyourole_list(ctx)</code>  <code>async</code>","text":"<p>/giveyou list</p> Description <p>List all giveyous</p> Source code in <code>extentions/giveroles.py</code> <pre><code>@giveyou_cmd.subcommand( sub_cmd_name='list', sub_cmd_description=\"Lists all giveyous for guild\")\nasync def giveyourole_list(self, ctx: InteractionContext):\n\"\"\"/giveyou list\n    Description:\n        List all giveyous\n    \"\"\"\n    from interactions.ext.paginators import Paginator\n    def chunks(l, n):\n        n = max(1, n)\n        return (l[i:i+n] for i in range(0, len(l), n))\n\n    def page_list(lst, s, e):\n        nc = list(chunks(lst, 20))\n        mc = ''\n        for testlist in nc[s:e]:\n            for m in testlist:\n                mc = mc + m\n        return mc\n\n    def newpage(title, names, roles):\n        embed = Embed(title=title,\n        color=0xffcc50)\n        embed.add_field(name='Giveyou', value=names, inline=True)\n        embed.add_field(name='Role', value=roles, inline=True)\n        return embed\n\n\n    gy = db.giveyou.find({\"guildid\":ctx.guild_id})\n    names = []\n    roles = []\n    async for g in gy:\n        names.append(f\"{g.name}\\n\")\n        role = ctx.guild.get_role(g.roleid)\n        if role is None:\n            roles.append(f'[ROLE NOT FOUND]({g.roleid})\\n')\n        else:\n            roles.append(f\"{role.mention}\\n\")\n    if names == []:\n        embed = Embed(description=f\"There are no giveyous for {ctx.guild.name}.\",\n                    color=0xffcc50)\n        await ctx.send(embed=embed)\n        return\n    s = -1\n    e = 0\n    embedcount = 1\n    nc = list(chunks(names, 20))\n\n    embeds = []\n    while embedcount &lt;= len(nc):\n        s = s+1\n        e = e+1\n        embeds.append(newpage(f'List of giveyous for {ctx.guild.name}', page_list(names, s, e), page_list(roles, s, e)))\n        embedcount = embedcount+1\n\n    paginator = Paginator(\n        client=self.bot, \n        pages=embeds,\n        timeout_interval=80,\n        show_select_menu=False)\n    await paginator.send(ctx)\n</code></pre>"},{"location":"giveroles/#extentions.giveroles.GiveRoles.give_role","title":"<code>give_role(ctx, members=None, roles=None)</code>  <code>async</code>","text":"<p>/give role</p> Description <p>Add/remove users to a role or roles</p> <p>Parameters:</p> Name Type Description Default <code>members</code> <code>str</code> <p>Members IDs or @member, seperated by a comma <code>,</code></p> <code>None</code> <code>roles</code> <code>str</code> <p>Roles IDs or @role, seperated by a comma <code>,</code></p> <code>None</code> Source code in <code>extentions/giveroles.py</code> <pre><code>@slash_command(name='role', description=\"Add/remove users to a role or roles\",\n    default_member_permissions=Permissions.MANAGE_ROLES\n)\n@members()\n@roles()\nasync def give_role(self, ctx: InteractionContext, members:str=None, roles:str=None):\n\"\"\"/give role\n    Description:\n        Add/remove users to a role or roles\n    Args:\n        members (str, optional): Members IDs or @member, seperated by a comma `,`\n        roles (str, optional): Roles IDs or @role, seperated by a comma `,`\n    \"\"\"\n    if members is None:\n        return await ctx.send(embed=Embed(color=0xDD2222, description=\":x: Please provide a user\"), ephemeral=True)\n    if roles is None:\n        return await ctx.send(embed=Embed(color=0xDD2222, description=\":x: Please provide a role\"), ephemeral=True)\n\n    raw_mem_list = members.split(',')\n    member_list =[]\n    for m in raw_mem_list:\n        m = m.replace('&lt;', '')\n        m = m.replace('@', '')\n        m = m.replace('!', '')\n        m = m.replace('&amp;', '')\n        m = m.replace('&gt;', '')\n        member_list.append(m)\n\n    raw_roles_list = roles.split(',')\n    roles_list = []\n    for r in raw_roles_list:\n        r = r.replace('&lt;', '')\n        r = r.replace('@', '')\n        r = r.replace('!', '')\n        r = r.replace('&amp;', '')\n        r = r.replace('&gt;', '')\n        roles_list.append(r)\n\n    for member_id in member_list:\n        member = ctx.guild.get_member(member_id)\n        removed_roles = 'I have removed: '\n        added_roles = 'I have assigned: '\n        for role_id in roles_list:\n            role = ctx.guild.get_role(role_id)\n            if member.has_role(role) == True:\n                await member.remove_role(role)\n                removed_roles = removed_roles + f' {role.mention}'\n            else:\n                await member.add_role(role)\n                added_roles = added_roles + f' {role.mention}'\n        embed = Embed(description=f'Roles changed for {member.mention}\\n\\n{added_roles}\\n\\n{removed_roles}', color=0xffcc50)\n        await ctx.send(embed=embed)\n</code></pre>"},{"location":"leveling/","title":"Leveling","text":"<p>         Bases: <code>Extension</code></p> Source code in <code>extentions/leveling.py</code> <pre><code>class Levels(Extension):\n    def __init__(self, bot: Client):\n        self.bot = bot\n\n    @listen()\n    async def on_ready(self):\n        self.lvl_cooldown_task.start()\n\n    LevelSettings = SlashCommand(name='leveling_config', default_member_permissions=Permissions.ADMINISTRATOR, description='Manage leveling settings.')\n\n    @LevelSettings.subcommand('ignored_channel', 'add', 'Add a channel to ignored channels.')\n    @channel()\n    async def LevelingAddIgnoredChannels(self, ctx:InteractionContext, channel: OptionType.CHANNEL=None):\n\"\"\"/leveling_config ignored_channel add\n        Description:\n            Add a channel to ignored channels by leveling\n        Args:\n            channel (OptionType.CHANNEL, optional): Channel to add, defaults to channel command is executed in\n        \"\"\"\n        await ctx.defer(ephemeral=True)\n        if channel is None:\n            channel = ctx.channel\n        settings = await db.leveling_settings.find_one({\"guildid\":ctx.guild.id})\n        if settings is None:\n            await db.leveling_settings(guildid=ctx.guild.id).insert()\n        ignored_channels = settings.ignored_channels\n        if ignored_channels is None:\n            ignored_channels = list()\n        if channel.id in ignored_channels:\n            await ctx.send(f'{channel.mention} is already ignored.', ephemeral=True)\n        ignored_channels.append(channel.id)\n        await settings.save()\n        channel_mentions = [ctx.guild.get_channel(id) for id in ignored_channels]\n        channel_mentions = [ch.mention for ch in channel_mentions if ch is not None]\n        channel_mentions = ' '.join(channel_mentions)\n        embed = Embed(description=f\"Channel {channel.mention} set to be ignored.\")\n        embed.add_field('Ignored Channels', channel_mentions)\n        await ctx.send(embed=embed, ephemeral=True)\n\n    @LevelSettings.subcommand('ignored_channel', 'remove', 'Remove a channel from ignored channels.')\n    @channel()\n    async def LevelingRemoveIgnoredChannels(self, ctx:InteractionContext, channel: OptionType.CHANNEL=None):\n\"\"\"/leveling_config ignored_channel remove\n        Description:\n            Remove a channel from ignored channels by leveling\n        Args:\n            channel (OptionType.CHANNEL, optional): Channel to remove, defaults to channel command is executed in\n        \"\"\"\n        await ctx.defer(ephemeral=True)\n        if channel is None:\n            channel = ctx.channel\n        settings = await db.leveling_settings.find_one({\"guildid\":ctx.guild.id})\n        if settings is None:\n            await db.leveling_settings(guildid=ctx.guild.id).insert()\n        ignored_channels = settings.ignored_channels\n        if ignored_channels is None:\n            ignored_channels = list()\n        if channel.id not in ignored_channels:\n            await ctx.send(f'{channel.mention} is not being ignored by leveling.', ephemeral=True)\n        ignored_channels.remove(channel.id)\n        await settings.save()\n        channel_mentions = [ctx.guild.get_channel(id) for id in ignored_channels]\n        channel_mentions = [ch.mention for ch in channel_mentions if ch is not None]\n        channel_mentions = ' '.join(channel_mentions)\n        embed = Embed(description=f\"Channel {channel.mention} removed from ignored channels.\")\n        embed.add_field('Ignored Channels', channel_mentions)\n        await ctx.send(embed=embed, ephemeral=True)\n\n    @LevelSettings.subcommand('ignored_role', 'add', 'Make a role to be ignored by leveling.')\n    @role()\n    async def LevelingAddIgnoredRoles(self, ctx:InteractionContext, role: OptionType.ROLE):\n\"\"\"/leveling_config ignored_role add\n        Description:\n            Add a role to be ignored by leveling\n        Args:\n            role (OptionType.ROLE): Role to add\n        \"\"\"\n        await ctx.defer(ephemeral=True)\n        settings = await db.leveling_settings.find_one({\"guildid\":ctx.guild.id})\n        if settings is None:\n            await db.leveling_settings(guildid=ctx.guild.id).insert()\n        ignored_roles = settings.ignored_roles\n        if ignored_roles is None:\n            ignored_roles = list()\n        if role.id in ignored_roles:\n            await ctx.send(f'{role.mention} is already ignored.', ephemeral=True)\n        ignored_roles.append(role.id)\n        await settings.save()\n        role_mentions = [ctx.guild.get_role(id) for id in ignored_roles]\n        role_mentions = [r.mention for r in role_mentions if r is not None]\n        role_mentions = ' '.join(role_mentions)\n        embed = Embed(description=f\"Role {role.mention} was added to roles ignored by leveling.\")\n        embed.add_field('Ignored Roles', role_mentions)\n        await ctx.send(embed=embed, ephemeral=True)\n\n    @LevelSettings.subcommand('ignored_role', 'remove', 'Remove a role from ignored roles.')\n    @role()\n    async def LevelingRemoveIgnoredRoles(self, ctx:InteractionContext, role: OptionType.ROLE):\n\"\"\"/leveling_config ignored_role remove\n        Description:\n            Remove a role from ignored by leveling\n        Args:\n            role (OptionType.ROLE): Role to remove\n        \"\"\"\n        await ctx.defer(ephemeral=True)\n        settings = await db.leveling_settings.find_one({\"guildid\":ctx.guild.id})\n        if settings is None:\n            await db.leveling_settings(guildid=ctx.guild.id).insert()\n        ignored_roles = settings.ignored_roles\n        if ignored_roles is None:\n            ignored_roles = list()\n        if role.id not in ignored_roles:\n            await ctx.send(f'{role.mention} is not being ignored by leveling.', ephemeral=True)\n        ignored_roles.remove(role.id)\n        await settings.save()\n        role_mentions = [ctx.guild.get_role(id) for id in ignored_roles]\n        role_mentions = [r.mention for r in role_mentions if r is not None]\n        role_mentions = ' '.join(role_mentions)\n        embed = Embed(description=f\"Role {role.mention} was removed from roles ignored by leveling.\")\n        embed.add_field('Ignored Roles', role_mentions)\n        await ctx.send(embed=embed, ephemeral=True)\n\n    @LevelSettings.subcommand('ignored_member', 'add', 'Make a member to be ignored by leveling.')\n    @user()\n    async def LevelingAddIgnoredMember(self, ctx:InteractionContext, user: OptionType.USER):\n\"\"\"/leveling_config ignored_member add\n        Description:\n            Make a member to be ignored by leveling.\n        Args:\n            user (OptionType.USER): User to add\n        \"\"\"\n        await ctx.defer(ephemeral=True)\n        settings = await db.leveling_settings.find_one({\"guildid\":ctx.guild.id})\n        if settings is None:\n            await db.leveling_settings(guildid=ctx.guild.id).insert()\n        ignored_users = settings.ignored_users\n        if ignored_users is None:\n            ignored_users = list()\n        if user.id in ignored_users:\n            await ctx.send(f'{user}|{user.id} is already ignored.', ephemeral=True)\n        ignored_users.append(user.id)\n        await settings.save()\n        users = [ctx.guild.get_member(id) for id in ignored_users]\n        users = [f'{r}({r.id})' for r in users if r is not None]\n        users = ' '.join(users)\n        embed = Embed(description=f\"Member {user}({user.id}) was added to members ignored by leveling.\")\n        embed.add_field('Ignored Members', users)\n        await ctx.send(embed=embed, ephemeral=True)\n\n    @LevelSettings.subcommand('ignored_member', 'remove', 'Remove a member from ignored members.')\n    @user()\n    async def LevelingRemoveIgnoredMember(self, ctx:InteractionContext, user: OptionType.USER):\n\"\"\"/leveling_config ignored_member remove\n        Description:\n            Remove a member from ignored members for leveling\n\n        Args:\n            user (OptionType.USER): User to ignore\n        \"\"\"\n        await ctx.defer(ephemeral=True)\n        settings = await db.leveling_settings.find_one({\"guildid\":ctx.guild.id})\n        if settings is None:\n           await db.leveling_settings(guildid=ctx.guild.id).insert()\n        ignored_users = settings.ignored_users\n        if ignored_users is None:\n            ignored_users = list()\n        if user.id not in ignored_users:\n            await ctx.send(f'{user}|{user.id} is not being ignored by leveling.', ephemeral=True)\n        ignored_users.remove(user.id)\n        await settings.save()\n        users = [ctx.guild.get_member(id) for id in ignored_users]\n        users = [f'{r}({r.id})' for r in users if r is not None]\n        users = ' '.join(users)\n        embed = Embed(description=f\"Member {user}({user.id}) was removed from members ignored by leveling.\")\n        embed.add_field('Ignored Members', users)\n        await ctx.send(embed=embed, ephemeral=True)\n\n    @listen()\n    async def on_xp_gain(self, event: MessageCreate):\n        message = event.message # get message object from event\n        user = message.author # get user object from message\n        if user.bot: # if user is a bot, return\n            return\n\n        settings = await db.leveling_settings.find_one({'guildid':message.guild.id}) # get leveling settings for guild\n        if not user.has_permission(Permissions.ADMINISTRATOR): # if user is not an admin\n            if settings.ignored_users is not None: # if ignored users list is not empty\n                if user.id in settings.ignored_users: # if user is in ignored users list, return\n                    return\n            if settings.ignored_roles is not None: # if ignored roles list is not empty\n                if any(role for role in user.roles if role.id in settings.ignored_roles): # if user has an ignored role, return\n                    return\n        if settings.ignored_channels is not None: # if ignored channels list is not empty\n            if message.channel.id in settings.ignored_channels: # if message is in ignored channel, return\n                return\n\n        cooldown = await db.levelwait.find_one({'guildid':message.guild.id, 'user':message.author.id}) # check if user is on cooldown\n        if cooldown: # if user is on cooldown, return\n            return\n        await db.levelwait(guildid=message.guild.id, user=message.author.id, starttime=datetime.utcnow(), endtime=(datetime.utcnow() + timedelta(seconds=60))).insert() # add user to cooldown list\n\n        member = await db.leveling.find_one({'guildid':message.guild.id, 'memberid':message.author.id}) # get leveling data for user\n        if not member: # if user has no leveling data, create new data and return\n            await db.leveling(guildid=message.guild.id, memberid=message.author.id, total_xp=0, level=0, xp_to_next_level=0, messages=1).insert()\n            return\n\n        level_stats = await db.levelingStats.find_one( {'level':member.level}) # get leveling stats for user's current level\n\n        if member.xp_to_next_level is None: # if user has no xp to next level, set to 0\n            xptnl = 0\n        else:\n            xptnl = member.xp_to_next_level\n        xp_to_give = random.randint(15, 25) # generate random xp to give\n        member.total_xp = member.total_xp+xp_to_give # add xp to user's total xp\n        if member.messages is None: # if user has no message count, set to 0\n            member.messages = 0\n        member.messages = member.messages+1 # increment user's message count\n        xp = xptnl + xp_to_give # calculate total xp\n\n        if xp &gt;= level_stats.xp_to_next_level: # if user has enough xp to level up\n            member.level = member.level+1 # increment user's level\n            member.xp_to_next_level = 0 # reset user's xp to next level\n            roles = await db.leveling_roles.find_one({'guildid':message.guild.id, 'level':member.level}) # get roles associated with user's new level\n            if roles: # if roles exist for user's new level\n                role = message.guild.get_role(roles.roleid) # get role object\n                if (role is not None) and (role not in message.author.roles): # if role exists and user does not already have role\n                    await message.author.add_role(role, f'[Melody][LEVELUP]Added a role assoiciated with level {member.level}') # add role to user and send message\n        else:\n            member.xp_to_next_level = xp # set user's xp to next level to calculated value\n        await member.save() # save user's leveling data\n\n        # Find all leveling roles for the current guild that have a level requirement less than or equal to the member's level\n        level_roles = db.leveling_roles.find({\"guildid\":message.guild.id, 'level':{'$lte':member.level}})\n\n        # Create an empty list to store the role IDs of the leveling roles the member is eligible for\n        roles = []\n\n        # Loop through the leveling roles the member is eligible for and append their role IDs to the roles list\n        async for role in level_roles:\n            roles.append(role.roleid)\n\n        # If the member is eligible for any leveling roles, loop through the role IDs and add the corresponding roles to the member's roles if they don't already have them\n        if level_roles != []:\n            for role_id in roles:\n                role = message.guild.get_role(role_id)\n                if role not in message.author.roles:\n                    await message.author.add_role(role)\n\n        # If the member's display name is None or different from their current display name, update their display name and save the changes\n        if (member.display_name is None) or (member.display_name != message.author.display_name):\n            member.display_name = message.author.display_name\n            await member.save()\n\n    @Task.create(IntervalTrigger(seconds=5))\n    async def lvl_cooldown_task(self):\n        level_wait = db.levelwait.find({'endtime':{'$lte':datetime.utcnow()}})\n        async for instance in level_wait:\n            mem = int(f'{instance.guildid}{instance.user}')\n            if mem not in cooldown_task_ongoing:\n                cooldown_task_ongoing.append(mem)\n                await instance.delete()\n                cooldown_task_ongoing.remove(mem)\n\n    leveling = SlashCommand(name='leveling', description='add/remove leveling roles', default_member_permissions=Permissions.MANAGE_ROLES)\n\n    @leveling.subcommand(sub_cmd_name='addrole', sub_cmd_description=\"allow's me to create leveling roles\")\n    @role()\n    @role_level()\n    async def leveling_add_role(self, ctx:InteractionContext, role: OptionType.ROLE, role_level:str):\n\"\"\"/leveling addrole\n        Description:\n            Create level roles\n\n        Args:\n            role (OptionType.ROLE): Role\n            role_level (str): Role level number, has to be more than 0 and less than 1000\n        \"\"\"\n        await ctx.defer()\n        if (int(role_level) &lt; 1) or (int(role_level) &gt; 1000):\n            await ctx.send('role level has to be more than 0 and less than 1000')\n            return\n\n        check = await db.leveling_roles.find_one({'guildid':ctx.guild_id, 'roleid':role.id})\n        if check is None:\n            await db.leveling_roles(guildid=ctx.guild_id, roleid=role.id, level=int(role_level)).insert()\n            await ctx.send(embed=Embed(color=0xffcc50, description=f'Leveling role {role.mention} assigned to level {role_level}'))\n        else:\n            await ctx.send(embed=Embed(color=0xDD2222, description=f':x: Leveling role {role.mention} is already assigned to level {check.level}'))\n\n        for member in ctx.guild.members:\n            mem = await db.leveling.find_one({'guildid':ctx.guild.id, 'memberid':member.id})\n            level_roles = db.leveling_roles.find({\"guildid\":ctx.guild_id, 'level':{'$lte':mem.level}})\n            roles = []\n            async for role in level_roles:\n                roles.append(role.roleid)\n            if level_roles != []:\n                for role_id in roles:\n                    role = ctx.guild.get_role(role_id)\n                    if role not in member.roles:\n                        await member.add_role(role)\n\n    @slash_command(name='ranklist', description=\"leveling roles list\")\n    async def ranks_list(self, ctx:InteractionContext):\n\"\"\"/ranklist\n        Description:\n            List leveling roles\n        \"\"\"\n        await ctx.defer()\n        from interactions.ext.paginators import Paginator\n        def chunks(l, n):\n            n = max(1, n)\n            return (l[i:i+n] for i in range(0, len(l), n))\n\n        def mlis(lst, s, e):\n            nc = list(chunks(lst, 20))\n            mc = ''\n            for testlist in nc[s:e]:\n                for m in testlist:\n                    mc = mc + m\n            return mc\n\n        def newpage(title, level, role):\n            embed = Embed(title=title,\n            color=0xffcc50)\n            embed.add_field(name='Level', value=level, inline=True)\n            embed.add_field(name='Role', value=role, inline=True)\n            return embed\n\n\n        levels = db.leveling_roles.find({\"guildid\":ctx.guild_id})\n        level = []\n        roles = []\n        async for l in levels:\n            level.append(f'{l.level}\\n')\n            lvlrole = find_role(ctx, l.roleid)\n            if lvlrole is None:\n                roles.append('[ROLE NOT FOUND]\\n')\n            else:\n                roles.append(f\"{lvlrole.mention}\\n\")\n\n        if (level or roles) == []:\n            embed = Embed(description=f\"There are no ranks for {ctx.guild.name}.\",\n                        color=0xffcc50)\n            await ctx.send(embed=embed)\n            return\n\n        s = -1\n        e = 0\n        embedcount = 1\n        nc = list(chunks(level, 20))\n\n        embeds = []\n        while embedcount &lt;= len(nc):\n            s = s+1\n            e = e+1\n            embeds.append(newpage(f'List of ranks for {ctx.guild.name}', mlis(level, s, e), mlis(roles, s, e)))\n            embedcount = embedcount+1\n\n        paginator = Paginator(\n            client=self.bot, \n            pages=embeds,\n            timeout_interval=80,\n            show_select_menu=False)\n        await paginator.send(ctx)\n\n    @leveling.subcommand(sub_cmd_name='removerole', sub_cmd_description=\"allow's me to remove leveling roles\")\n    @role()\n    async def leveling_remove_role(self, ctx:InteractionContext, role: OptionType.ROLE=None):\n\"\"\"/leveling removerole\n\n        Args:\n            role (OptionType.ROLE, optional): Role to remove from leveling.\n        \"\"\"\n        await ctx.defer()\n        if role is None:\n            await ctx.send('you have to include a role')\n            return\n\n        check = await db.leveling_roles.find_one({'guildid':ctx.guild.id, 'roleid':role.id})\n        if check is None:\n            await ctx.send(embed=Embed(color=0xDD2222, description=f':x: Leveling role {role.mention} is not assigned to a level'))\n        else:\n            await ctx.send(embed=Embed(color=0xffcc50, description=f'Leveling role {role.mention} removed from level {check.level}'))\n            await check.delete()\n\n        for member in ctx.guild.members:\n            if role in member.roles:\n                await member.remove_role(role)\n\n    @slash_command(name='rank', description='check your leveling statistics')\n    @member()\n    async def newrank(self, ctx: SlashContext, member:OptionType.USER=None):\n\"\"\"/rank\n        Description:\n            Generates leveling info card\n\n        Args:\n            member (OptionType.USER, optional): Member, defaults to member executing the command\n        \"\"\"\n        await ctx.defer() # defer the response to avoid timeout\n        if member is None: # if no member parameter is provided, use the author of the command\n            member = ctx.author\n\n        levels = await db.leveling.find_one({'guildid':ctx.guild_id, 'memberid':member.id}) # get the leveling data for the member\n        if levels is None: # if no leveling data is found, send a message and return\n            await ctx.send(\"You don't have any xp yet. You can start having conversations with people to gain xp.\", ephemeral=True)\n            return\n\n        level_stats = await db.levelingStats.find_one({'level':levels.level}) # get the leveling stats for the member's current level\n        if (levels.display_name is None) or (levels.display_name != member.display_name): # if the member's display name has changed, update it in the database\n            levels.display_name = member.display_name\n            await levels.save()\n\n        def getPercent(first, second): # helper function to calculate percentage\n            return first / second * 100\n        percent = getPercent(levels.xp_to_next_level,level_stats.xp_to_next_level) # calculate the percentage of xp towards the next level\n        def findx(percentage): # helper function to calculate the progress bar width\n            if percentage == 0:\n                return 1\n            return 550/(100/percentage)\n\n        if member.guild_avatar is not None: # get the member's avatar url\n            avatarurl = f'{member.guild_avatar.url}.png'\n        else:\n            avatarurl = f'{member.avatar.url}.png'\n\n        def round(im): # helper function to round the member's avatar\n            im = im.resize((210*16,210*16), resample=Image.ANTIALIAS)\n            mask = Image.new(\"L\", im.size, 0)\n            draw = ImageDraw.Draw(mask)\n            draw.ellipse((0,0)+im.size, fill=255)\n            out = ImageOps.fit(im, mask.size, centering=(0,0))\n            out.putalpha(mask)\n            image = out.resize((210,210), resample=Image.ANTIALIAS).convert(\"RGBA\")\n            return image\n\n        IW, IH = (956, 435) # set the image width and height\n        aspect_ratio = IW/IH\n\n        if levels.lc_background is not None: # get the background image for the level card\n            try:\n                background = Image.open(requests.get(f'{levels.lc_background}', stream=True).raw).crop((0,0,IW,IH)).convert(\"RGBA\")\n            except:\n                background = Image.open(requests.get('https://i.imgur.com/4yzKbQo.png', stream=True).raw).convert(\"RGBA\")\n        else:\n            background = Image.open(requests.get('https://i.imgur.com/4yzKbQo.png', stream=True).raw).convert(\"RGBA\")\n\n        overlay = Image.open(requests.get('https://i.imgur.com/fsuIzSv.png', stream=True).raw).convert(\"RGBA\") # add an overlay to the background\n        background.paste(overlay, (0, 0), overlay)\n\n        try:\n            pfp = Image.open(requests.get(avatarurl, stream=True).raw).resize((230,230)).convert(\"RGBA\") # get the member's avatar image\n        except:\n            pfp = Image.open(requests.get('https://cdn.discordapp.com/embed/avatars/1.png', stream=True).raw).resize((230,230)).convert(\"RGBA\")\n        pfp = round(pfp) # round the member's avatar\n        background.paste(pfp, (78, 115), pfp) # paste the avatar onto the background\n\n        def draw_progress_bar(fx): # helper function to draw the progress bar\n            rad = 115\n            im = Image.open(requests.get('https://i.imgur.com/sRseF8Y.png', stream=True).raw).convert('RGBA')\n            im = im.resize((fx*16,30*16), resample=Image.ANTIALIAS)\n            circle = Image.new('L', (rad * 2, rad * 2), 0)\n            draw = ImageDraw.Draw(circle)\n            draw.ellipse((0, 0, rad * 2, rad * 2), fill=255)\n            alpha = Image.new('L', im.size, 255)\n            w, h = im.size\n            alpha.paste(circle.crop((0, 0, rad, rad)), (0, 0))\n            alpha.paste(circle.crop((0, rad, rad, rad * 2)), (0, h - rad))\n            alpha.paste(circle.crop((rad, 0, rad * 2, rad)), (w - rad, 0))\n            alpha.paste(circle.crop((rad, rad, rad * 2, rad * 2)), (w - rad, h - rad))\n            im.putalpha(alpha)\n            im = im.resize((fx,30), resample=Image.ANTIALIAS)\n            return im\n\n        fx = findx(int(percent)) # calculate the progress bar width\n        progress_bar = draw_progress_bar(int(fx)) # draw the progress bar\n        background.paste(progress_bar, (330, 370), progress_bar) # paste the progress bar onto the background\n\n        def rectangle_fill(im): # helper function to fill the background with a rectangle\n            mask = Image.new(\"L\", im.size, 0)\n            draw = ImageDraw.Draw(mask)\n            draw.rectangle((0,0)+im.size, fill=255)\n            out = ImageOps.fit(im, mask.size, centering=(0,0))\n            out.putalpha(mask)\n            return out\n\n        background = rectangle_fill(background) # fill the background with a rectangle\n\n        font = ImageFont.truetype('Everson-Mono-Bold.ttf', 45) # set the font for the text\n\n        I1 = ImageDraw.Draw(background)\n\n        lvlfont = ImageFont.truetype('Everson-Mono-Bold.ttf', 45)\n        I1.text((73,352), f'LVL:{levels.level}', font=lvlfont, stroke_width=2, stroke_fill=(30, 27, 26), fill=(255, 255, 255)) # add the member's level to the level card\n\n        lvlmsg = f'XP: {levels.xp_to_next_level}/{level_stats.xp_to_next_level}\\nTotal XP: {levels.total_xp}\\nMessages: {levels.messages}' # create the level message\n        I1.text((341,110), lvlmsg, font=font, stroke_width=2, stroke_fill=(30, 27, 26), fill=(255, 255, 255)) # add the level message to the level card\n\n        namefont = ImageFont.truetype('Everson-Mono-Bold.ttf', 50)\n        name = f'{member.display_name}'\n        if len(name) &gt; 27: # shorten the member's name if it is too long\n            name = name[:-4]\n\n        I1.text((73,28), name, font=namefont, stroke_width=2, stroke_fill=(30, 27, 26), fill=(255, 255, 255)) # add the member's name to the level card\n        background.save(f'levelcard_{member.id}.png') # save the level card as a file\n        await ctx.send(file=f\"levelcard_{member.id}.png\") # send the level card as a file\n        os.remove(f'levelcard_{member.id}.png') # remove the level card file\n\n    @slash_command(name='leaderboard', description='check the servers leveling leaderboard')\n    async def leaderboard(self, ctx: InteractionContext):\n\"\"\"/leaderboard\n        Description:\n            Sends a button to the leaderboard for the server the command is executed in.\n        \"\"\"\n        components = Button(\n            style=ButtonStyle.URL,\n            label=\"Click Me!\",\n            url=f\"https://www.beni2am.space/melody/leaderboard/{ctx.guild_id}/\",\n        )\n        await ctx.send(\"A button to the web leaderboard!\", components=components)\n</code></pre>"},{"location":"leveling/#extentions.leveling.Levels.LevelingAddIgnoredChannels","title":"<code>LevelingAddIgnoredChannels(ctx, channel=None)</code>  <code>async</code>","text":"<p>/leveling_config ignored_channel add</p> Description <p>Add a channel to ignored channels by leveling</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>OptionType.CHANNEL</code> <p>Channel to add, defaults to channel command is executed in</p> <code>None</code> Source code in <code>extentions/leveling.py</code> <pre><code>@LevelSettings.subcommand('ignored_channel', 'add', 'Add a channel to ignored channels.')\n@channel()\nasync def LevelingAddIgnoredChannels(self, ctx:InteractionContext, channel: OptionType.CHANNEL=None):\n\"\"\"/leveling_config ignored_channel add\n    Description:\n        Add a channel to ignored channels by leveling\n    Args:\n        channel (OptionType.CHANNEL, optional): Channel to add, defaults to channel command is executed in\n    \"\"\"\n    await ctx.defer(ephemeral=True)\n    if channel is None:\n        channel = ctx.channel\n    settings = await db.leveling_settings.find_one({\"guildid\":ctx.guild.id})\n    if settings is None:\n        await db.leveling_settings(guildid=ctx.guild.id).insert()\n    ignored_channels = settings.ignored_channels\n    if ignored_channels is None:\n        ignored_channels = list()\n    if channel.id in ignored_channels:\n        await ctx.send(f'{channel.mention} is already ignored.', ephemeral=True)\n    ignored_channels.append(channel.id)\n    await settings.save()\n    channel_mentions = [ctx.guild.get_channel(id) for id in ignored_channels]\n    channel_mentions = [ch.mention for ch in channel_mentions if ch is not None]\n    channel_mentions = ' '.join(channel_mentions)\n    embed = Embed(description=f\"Channel {channel.mention} set to be ignored.\")\n    embed.add_field('Ignored Channels', channel_mentions)\n    await ctx.send(embed=embed, ephemeral=True)\n</code></pre>"},{"location":"leveling/#extentions.leveling.Levels.LevelingRemoveIgnoredChannels","title":"<code>LevelingRemoveIgnoredChannels(ctx, channel=None)</code>  <code>async</code>","text":"<p>/leveling_config ignored_channel remove</p> Description <p>Remove a channel from ignored channels by leveling</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>OptionType.CHANNEL</code> <p>Channel to remove, defaults to channel command is executed in</p> <code>None</code> Source code in <code>extentions/leveling.py</code> <pre><code>@LevelSettings.subcommand('ignored_channel', 'remove', 'Remove a channel from ignored channels.')\n@channel()\nasync def LevelingRemoveIgnoredChannels(self, ctx:InteractionContext, channel: OptionType.CHANNEL=None):\n\"\"\"/leveling_config ignored_channel remove\n    Description:\n        Remove a channel from ignored channels by leveling\n    Args:\n        channel (OptionType.CHANNEL, optional): Channel to remove, defaults to channel command is executed in\n    \"\"\"\n    await ctx.defer(ephemeral=True)\n    if channel is None:\n        channel = ctx.channel\n    settings = await db.leveling_settings.find_one({\"guildid\":ctx.guild.id})\n    if settings is None:\n        await db.leveling_settings(guildid=ctx.guild.id).insert()\n    ignored_channels = settings.ignored_channels\n    if ignored_channels is None:\n        ignored_channels = list()\n    if channel.id not in ignored_channels:\n        await ctx.send(f'{channel.mention} is not being ignored by leveling.', ephemeral=True)\n    ignored_channels.remove(channel.id)\n    await settings.save()\n    channel_mentions = [ctx.guild.get_channel(id) for id in ignored_channels]\n    channel_mentions = [ch.mention for ch in channel_mentions if ch is not None]\n    channel_mentions = ' '.join(channel_mentions)\n    embed = Embed(description=f\"Channel {channel.mention} removed from ignored channels.\")\n    embed.add_field('Ignored Channels', channel_mentions)\n    await ctx.send(embed=embed, ephemeral=True)\n</code></pre>"},{"location":"leveling/#extentions.leveling.Levels.LevelingAddIgnoredRoles","title":"<code>LevelingAddIgnoredRoles(ctx, role)</code>  <code>async</code>","text":"<p>/leveling_config ignored_role add</p> Description <p>Add a role to be ignored by leveling</p> <p>Parameters:</p> Name Type Description Default <code>role</code> <code>OptionType.ROLE</code> <p>Role to add</p> required Source code in <code>extentions/leveling.py</code> <pre><code>@LevelSettings.subcommand('ignored_role', 'add', 'Make a role to be ignored by leveling.')\n@role()\nasync def LevelingAddIgnoredRoles(self, ctx:InteractionContext, role: OptionType.ROLE):\n\"\"\"/leveling_config ignored_role add\n    Description:\n        Add a role to be ignored by leveling\n    Args:\n        role (OptionType.ROLE): Role to add\n    \"\"\"\n    await ctx.defer(ephemeral=True)\n    settings = await db.leveling_settings.find_one({\"guildid\":ctx.guild.id})\n    if settings is None:\n        await db.leveling_settings(guildid=ctx.guild.id).insert()\n    ignored_roles = settings.ignored_roles\n    if ignored_roles is None:\n        ignored_roles = list()\n    if role.id in ignored_roles:\n        await ctx.send(f'{role.mention} is already ignored.', ephemeral=True)\n    ignored_roles.append(role.id)\n    await settings.save()\n    role_mentions = [ctx.guild.get_role(id) for id in ignored_roles]\n    role_mentions = [r.mention for r in role_mentions if r is not None]\n    role_mentions = ' '.join(role_mentions)\n    embed = Embed(description=f\"Role {role.mention} was added to roles ignored by leveling.\")\n    embed.add_field('Ignored Roles', role_mentions)\n    await ctx.send(embed=embed, ephemeral=True)\n</code></pre>"},{"location":"leveling/#extentions.leveling.Levels.LevelingRemoveIgnoredRoles","title":"<code>LevelingRemoveIgnoredRoles(ctx, role)</code>  <code>async</code>","text":"<p>/leveling_config ignored_role remove</p> Description <p>Remove a role from ignored by leveling</p> <p>Parameters:</p> Name Type Description Default <code>role</code> <code>OptionType.ROLE</code> <p>Role to remove</p> required Source code in <code>extentions/leveling.py</code> <pre><code>@LevelSettings.subcommand('ignored_role', 'remove', 'Remove a role from ignored roles.')\n@role()\nasync def LevelingRemoveIgnoredRoles(self, ctx:InteractionContext, role: OptionType.ROLE):\n\"\"\"/leveling_config ignored_role remove\n    Description:\n        Remove a role from ignored by leveling\n    Args:\n        role (OptionType.ROLE): Role to remove\n    \"\"\"\n    await ctx.defer(ephemeral=True)\n    settings = await db.leveling_settings.find_one({\"guildid\":ctx.guild.id})\n    if settings is None:\n        await db.leveling_settings(guildid=ctx.guild.id).insert()\n    ignored_roles = settings.ignored_roles\n    if ignored_roles is None:\n        ignored_roles = list()\n    if role.id not in ignored_roles:\n        await ctx.send(f'{role.mention} is not being ignored by leveling.', ephemeral=True)\n    ignored_roles.remove(role.id)\n    await settings.save()\n    role_mentions = [ctx.guild.get_role(id) for id in ignored_roles]\n    role_mentions = [r.mention for r in role_mentions if r is not None]\n    role_mentions = ' '.join(role_mentions)\n    embed = Embed(description=f\"Role {role.mention} was removed from roles ignored by leveling.\")\n    embed.add_field('Ignored Roles', role_mentions)\n    await ctx.send(embed=embed, ephemeral=True)\n</code></pre>"},{"location":"leveling/#extentions.leveling.Levels.LevelingAddIgnoredMember","title":"<code>LevelingAddIgnoredMember(ctx, user)</code>  <code>async</code>","text":"<p>/leveling_config ignored_member add</p> Description <p>Make a member to be ignored by leveling.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>OptionType.USER</code> <p>User to add</p> required Source code in <code>extentions/leveling.py</code> <pre><code>@LevelSettings.subcommand('ignored_member', 'add', 'Make a member to be ignored by leveling.')\n@user()\nasync def LevelingAddIgnoredMember(self, ctx:InteractionContext, user: OptionType.USER):\n\"\"\"/leveling_config ignored_member add\n    Description:\n        Make a member to be ignored by leveling.\n    Args:\n        user (OptionType.USER): User to add\n    \"\"\"\n    await ctx.defer(ephemeral=True)\n    settings = await db.leveling_settings.find_one({\"guildid\":ctx.guild.id})\n    if settings is None:\n        await db.leveling_settings(guildid=ctx.guild.id).insert()\n    ignored_users = settings.ignored_users\n    if ignored_users is None:\n        ignored_users = list()\n    if user.id in ignored_users:\n        await ctx.send(f'{user}|{user.id} is already ignored.', ephemeral=True)\n    ignored_users.append(user.id)\n    await settings.save()\n    users = [ctx.guild.get_member(id) for id in ignored_users]\n    users = [f'{r}({r.id})' for r in users if r is not None]\n    users = ' '.join(users)\n    embed = Embed(description=f\"Member {user}({user.id}) was added to members ignored by leveling.\")\n    embed.add_field('Ignored Members', users)\n    await ctx.send(embed=embed, ephemeral=True)\n</code></pre>"},{"location":"leveling/#extentions.leveling.Levels.LevelingRemoveIgnoredMember","title":"<code>LevelingRemoveIgnoredMember(ctx, user)</code>  <code>async</code>","text":"<p>/leveling_config ignored_member remove</p> Description <p>Remove a member from ignored members for leveling</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>OptionType.USER</code> <p>User to ignore</p> required Source code in <code>extentions/leveling.py</code> <pre><code>@LevelSettings.subcommand('ignored_member', 'remove', 'Remove a member from ignored members.')\n@user()\nasync def LevelingRemoveIgnoredMember(self, ctx:InteractionContext, user: OptionType.USER):\n\"\"\"/leveling_config ignored_member remove\n    Description:\n        Remove a member from ignored members for leveling\n\n    Args:\n        user (OptionType.USER): User to ignore\n    \"\"\"\n    await ctx.defer(ephemeral=True)\n    settings = await db.leveling_settings.find_one({\"guildid\":ctx.guild.id})\n    if settings is None:\n       await db.leveling_settings(guildid=ctx.guild.id).insert()\n    ignored_users = settings.ignored_users\n    if ignored_users is None:\n        ignored_users = list()\n    if user.id not in ignored_users:\n        await ctx.send(f'{user}|{user.id} is not being ignored by leveling.', ephemeral=True)\n    ignored_users.remove(user.id)\n    await settings.save()\n    users = [ctx.guild.get_member(id) for id in ignored_users]\n    users = [f'{r}({r.id})' for r in users if r is not None]\n    users = ' '.join(users)\n    embed = Embed(description=f\"Member {user}({user.id}) was removed from members ignored by leveling.\")\n    embed.add_field('Ignored Members', users)\n    await ctx.send(embed=embed, ephemeral=True)\n</code></pre>"},{"location":"leveling/#extentions.leveling.Levels.leveling_add_role","title":"<code>leveling_add_role(ctx, role, role_level)</code>  <code>async</code>","text":"<p>/leveling addrole</p> Description <p>Create level roles</p> <p>Parameters:</p> Name Type Description Default <code>role</code> <code>OptionType.ROLE</code> <p>Role</p> required <code>role_level</code> <code>str</code> <p>Role level number, has to be more than 0 and less than 1000</p> required Source code in <code>extentions/leveling.py</code> <pre><code>@leveling.subcommand(sub_cmd_name='addrole', sub_cmd_description=\"allow's me to create leveling roles\")\n@role()\n@role_level()\nasync def leveling_add_role(self, ctx:InteractionContext, role: OptionType.ROLE, role_level:str):\n\"\"\"/leveling addrole\n    Description:\n        Create level roles\n\n    Args:\n        role (OptionType.ROLE): Role\n        role_level (str): Role level number, has to be more than 0 and less than 1000\n    \"\"\"\n    await ctx.defer()\n    if (int(role_level) &lt; 1) or (int(role_level) &gt; 1000):\n        await ctx.send('role level has to be more than 0 and less than 1000')\n        return\n\n    check = await db.leveling_roles.find_one({'guildid':ctx.guild_id, 'roleid':role.id})\n    if check is None:\n        await db.leveling_roles(guildid=ctx.guild_id, roleid=role.id, level=int(role_level)).insert()\n        await ctx.send(embed=Embed(color=0xffcc50, description=f'Leveling role {role.mention} assigned to level {role_level}'))\n    else:\n        await ctx.send(embed=Embed(color=0xDD2222, description=f':x: Leveling role {role.mention} is already assigned to level {check.level}'))\n\n    for member in ctx.guild.members:\n        mem = await db.leveling.find_one({'guildid':ctx.guild.id, 'memberid':member.id})\n        level_roles = db.leveling_roles.find({\"guildid\":ctx.guild_id, 'level':{'$lte':mem.level}})\n        roles = []\n        async for role in level_roles:\n            roles.append(role.roleid)\n        if level_roles != []:\n            for role_id in roles:\n                role = ctx.guild.get_role(role_id)\n                if role not in member.roles:\n                    await member.add_role(role)\n</code></pre>"},{"location":"leveling/#extentions.leveling.Levels.ranks_list","title":"<code>ranks_list(ctx)</code>  <code>async</code>","text":"<p>/ranklist</p> Description <p>List leveling roles</p> Source code in <code>extentions/leveling.py</code> <pre><code>@slash_command(name='ranklist', description=\"leveling roles list\")\nasync def ranks_list(self, ctx:InteractionContext):\n\"\"\"/ranklist\n    Description:\n        List leveling roles\n    \"\"\"\n    await ctx.defer()\n    from interactions.ext.paginators import Paginator\n    def chunks(l, n):\n        n = max(1, n)\n        return (l[i:i+n] for i in range(0, len(l), n))\n\n    def mlis(lst, s, e):\n        nc = list(chunks(lst, 20))\n        mc = ''\n        for testlist in nc[s:e]:\n            for m in testlist:\n                mc = mc + m\n        return mc\n\n    def newpage(title, level, role):\n        embed = Embed(title=title,\n        color=0xffcc50)\n        embed.add_field(name='Level', value=level, inline=True)\n        embed.add_field(name='Role', value=role, inline=True)\n        return embed\n\n\n    levels = db.leveling_roles.find({\"guildid\":ctx.guild_id})\n    level = []\n    roles = []\n    async for l in levels:\n        level.append(f'{l.level}\\n')\n        lvlrole = find_role(ctx, l.roleid)\n        if lvlrole is None:\n            roles.append('[ROLE NOT FOUND]\\n')\n        else:\n            roles.append(f\"{lvlrole.mention}\\n\")\n\n    if (level or roles) == []:\n        embed = Embed(description=f\"There are no ranks for {ctx.guild.name}.\",\n                    color=0xffcc50)\n        await ctx.send(embed=embed)\n        return\n\n    s = -1\n    e = 0\n    embedcount = 1\n    nc = list(chunks(level, 20))\n\n    embeds = []\n    while embedcount &lt;= len(nc):\n        s = s+1\n        e = e+1\n        embeds.append(newpage(f'List of ranks for {ctx.guild.name}', mlis(level, s, e), mlis(roles, s, e)))\n        embedcount = embedcount+1\n\n    paginator = Paginator(\n        client=self.bot, \n        pages=embeds,\n        timeout_interval=80,\n        show_select_menu=False)\n    await paginator.send(ctx)\n</code></pre>"},{"location":"leveling/#extentions.leveling.Levels.leveling_remove_role","title":"<code>leveling_remove_role(ctx, role=None)</code>  <code>async</code>","text":"<p>/leveling removerole</p> <p>Parameters:</p> Name Type Description Default <code>role</code> <code>OptionType.ROLE</code> <p>Role to remove from leveling.</p> <code>None</code> Source code in <code>extentions/leveling.py</code> <pre><code>@leveling.subcommand(sub_cmd_name='removerole', sub_cmd_description=\"allow's me to remove leveling roles\")\n@role()\nasync def leveling_remove_role(self, ctx:InteractionContext, role: OptionType.ROLE=None):\n\"\"\"/leveling removerole\n\n    Args:\n        role (OptionType.ROLE, optional): Role to remove from leveling.\n    \"\"\"\n    await ctx.defer()\n    if role is None:\n        await ctx.send('you have to include a role')\n        return\n\n    check = await db.leveling_roles.find_one({'guildid':ctx.guild.id, 'roleid':role.id})\n    if check is None:\n        await ctx.send(embed=Embed(color=0xDD2222, description=f':x: Leveling role {role.mention} is not assigned to a level'))\n    else:\n        await ctx.send(embed=Embed(color=0xffcc50, description=f'Leveling role {role.mention} removed from level {check.level}'))\n        await check.delete()\n\n    for member in ctx.guild.members:\n        if role in member.roles:\n            await member.remove_role(role)\n</code></pre>"},{"location":"leveling/#extentions.leveling.Levels.newrank","title":"<code>newrank(ctx, member=None)</code>  <code>async</code>","text":"<p>/rank</p> Description <p>Generates leveling info card</p> <p>Parameters:</p> Name Type Description Default <code>member</code> <code>OptionType.USER</code> <p>Member, defaults to member executing the command</p> <code>None</code> Source code in <code>extentions/leveling.py</code> <pre><code>@slash_command(name='rank', description='check your leveling statistics')\n@member()\nasync def newrank(self, ctx: SlashContext, member:OptionType.USER=None):\n\"\"\"/rank\n    Description:\n        Generates leveling info card\n\n    Args:\n        member (OptionType.USER, optional): Member, defaults to member executing the command\n    \"\"\"\n    await ctx.defer() # defer the response to avoid timeout\n    if member is None: # if no member parameter is provided, use the author of the command\n        member = ctx.author\n\n    levels = await db.leveling.find_one({'guildid':ctx.guild_id, 'memberid':member.id}) # get the leveling data for the member\n    if levels is None: # if no leveling data is found, send a message and return\n        await ctx.send(\"You don't have any xp yet. You can start having conversations with people to gain xp.\", ephemeral=True)\n        return\n\n    level_stats = await db.levelingStats.find_one({'level':levels.level}) # get the leveling stats for the member's current level\n    if (levels.display_name is None) or (levels.display_name != member.display_name): # if the member's display name has changed, update it in the database\n        levels.display_name = member.display_name\n        await levels.save()\n\n    def getPercent(first, second): # helper function to calculate percentage\n        return first / second * 100\n    percent = getPercent(levels.xp_to_next_level,level_stats.xp_to_next_level) # calculate the percentage of xp towards the next level\n    def findx(percentage): # helper function to calculate the progress bar width\n        if percentage == 0:\n            return 1\n        return 550/(100/percentage)\n\n    if member.guild_avatar is not None: # get the member's avatar url\n        avatarurl = f'{member.guild_avatar.url}.png'\n    else:\n        avatarurl = f'{member.avatar.url}.png'\n\n    def round(im): # helper function to round the member's avatar\n        im = im.resize((210*16,210*16), resample=Image.ANTIALIAS)\n        mask = Image.new(\"L\", im.size, 0)\n        draw = ImageDraw.Draw(mask)\n        draw.ellipse((0,0)+im.size, fill=255)\n        out = ImageOps.fit(im, mask.size, centering=(0,0))\n        out.putalpha(mask)\n        image = out.resize((210,210), resample=Image.ANTIALIAS).convert(\"RGBA\")\n        return image\n\n    IW, IH = (956, 435) # set the image width and height\n    aspect_ratio = IW/IH\n\n    if levels.lc_background is not None: # get the background image for the level card\n        try:\n            background = Image.open(requests.get(f'{levels.lc_background}', stream=True).raw).crop((0,0,IW,IH)).convert(\"RGBA\")\n        except:\n            background = Image.open(requests.get('https://i.imgur.com/4yzKbQo.png', stream=True).raw).convert(\"RGBA\")\n    else:\n        background = Image.open(requests.get('https://i.imgur.com/4yzKbQo.png', stream=True).raw).convert(\"RGBA\")\n\n    overlay = Image.open(requests.get('https://i.imgur.com/fsuIzSv.png', stream=True).raw).convert(\"RGBA\") # add an overlay to the background\n    background.paste(overlay, (0, 0), overlay)\n\n    try:\n        pfp = Image.open(requests.get(avatarurl, stream=True).raw).resize((230,230)).convert(\"RGBA\") # get the member's avatar image\n    except:\n        pfp = Image.open(requests.get('https://cdn.discordapp.com/embed/avatars/1.png', stream=True).raw).resize((230,230)).convert(\"RGBA\")\n    pfp = round(pfp) # round the member's avatar\n    background.paste(pfp, (78, 115), pfp) # paste the avatar onto the background\n\n    def draw_progress_bar(fx): # helper function to draw the progress bar\n        rad = 115\n        im = Image.open(requests.get('https://i.imgur.com/sRseF8Y.png', stream=True).raw).convert('RGBA')\n        im = im.resize((fx*16,30*16), resample=Image.ANTIALIAS)\n        circle = Image.new('L', (rad * 2, rad * 2), 0)\n        draw = ImageDraw.Draw(circle)\n        draw.ellipse((0, 0, rad * 2, rad * 2), fill=255)\n        alpha = Image.new('L', im.size, 255)\n        w, h = im.size\n        alpha.paste(circle.crop((0, 0, rad, rad)), (0, 0))\n        alpha.paste(circle.crop((0, rad, rad, rad * 2)), (0, h - rad))\n        alpha.paste(circle.crop((rad, 0, rad * 2, rad)), (w - rad, 0))\n        alpha.paste(circle.crop((rad, rad, rad * 2, rad * 2)), (w - rad, h - rad))\n        im.putalpha(alpha)\n        im = im.resize((fx,30), resample=Image.ANTIALIAS)\n        return im\n\n    fx = findx(int(percent)) # calculate the progress bar width\n    progress_bar = draw_progress_bar(int(fx)) # draw the progress bar\n    background.paste(progress_bar, (330, 370), progress_bar) # paste the progress bar onto the background\n\n    def rectangle_fill(im): # helper function to fill the background with a rectangle\n        mask = Image.new(\"L\", im.size, 0)\n        draw = ImageDraw.Draw(mask)\n        draw.rectangle((0,0)+im.size, fill=255)\n        out = ImageOps.fit(im, mask.size, centering=(0,0))\n        out.putalpha(mask)\n        return out\n\n    background = rectangle_fill(background) # fill the background with a rectangle\n\n    font = ImageFont.truetype('Everson-Mono-Bold.ttf', 45) # set the font for the text\n\n    I1 = ImageDraw.Draw(background)\n\n    lvlfont = ImageFont.truetype('Everson-Mono-Bold.ttf', 45)\n    I1.text((73,352), f'LVL:{levels.level}', font=lvlfont, stroke_width=2, stroke_fill=(30, 27, 26), fill=(255, 255, 255)) # add the member's level to the level card\n\n    lvlmsg = f'XP: {levels.xp_to_next_level}/{level_stats.xp_to_next_level}\\nTotal XP: {levels.total_xp}\\nMessages: {levels.messages}' # create the level message\n    I1.text((341,110), lvlmsg, font=font, stroke_width=2, stroke_fill=(30, 27, 26), fill=(255, 255, 255)) # add the level message to the level card\n\n    namefont = ImageFont.truetype('Everson-Mono-Bold.ttf', 50)\n    name = f'{member.display_name}'\n    if len(name) &gt; 27: # shorten the member's name if it is too long\n        name = name[:-4]\n\n    I1.text((73,28), name, font=namefont, stroke_width=2, stroke_fill=(30, 27, 26), fill=(255, 255, 255)) # add the member's name to the level card\n    background.save(f'levelcard_{member.id}.png') # save the level card as a file\n    await ctx.send(file=f\"levelcard_{member.id}.png\") # send the level card as a file\n    os.remove(f'levelcard_{member.id}.png') # remove the level card file\n</code></pre>"},{"location":"leveling/#extentions.leveling.Levels.leaderboard","title":"<code>leaderboard(ctx)</code>  <code>async</code>","text":"<p>/leaderboard</p> Description <p>Sends a button to the leaderboard for the server the command is executed in.</p> Source code in <code>extentions/leveling.py</code> <pre><code>@slash_command(name='leaderboard', description='check the servers leveling leaderboard')\nasync def leaderboard(self, ctx: InteractionContext):\n\"\"\"/leaderboard\n    Description:\n        Sends a button to the leaderboard for the server the command is executed in.\n    \"\"\"\n    components = Button(\n        style=ButtonStyle.URL,\n        label=\"Click Me!\",\n        url=f\"https://www.beni2am.space/melody/leaderboard/{ctx.guild_id}/\",\n    )\n    await ctx.send(\"A button to the web leaderboard!\", components=components)\n</code></pre>"},{"location":"moderation/","title":"Moderation","text":"<p>         Bases: <code>Extension</code></p> Source code in <code>extentions/moderation.py</code> <pre><code>class Moderation(Extension):\n    def __init__(self, bot: Client):\n        self.bot = bot\n\n    @listen()\n    async def on_ready(self):\n        self.unban_task.start()\n\n    @slash_command(name='modapp', description=\"Apply to be a moderator\", scopes=[435038183231848449,149167686159564800])\n    async def modapps_modal(self, ctx:SlashContext):\n        await ctx.defer()\n        m = Modal(title='Mod Application', components=[\n            InputText(\n                label=\"Age &amp; Country (Looking for variety!)\",\n                style=TextStyles.SHORT,\n                custom_id=f'age_country',\n                placeholder=\"What is your age and what country are you from?\",\n                required=True,\n                max_length=100\n            ),\n            InputText(\n                label=\"Can you handle uneasy/difficult situations?\",\n                style=TextStyles.SHORT,\n                custom_id=f'wimp',\n                placeholder=\"Can you handle uncomfortable and difficult situations?\",\n                required=True,\n                max_length=100\n            ),\n            InputText(\n                label=\"How yould you handle this?\",\n                style=TextStyles.PARAGRAPH,\n                custom_id=f'situation',\n                placeholder=\"How would you handle the situation described in the announcement?(https://pastebin.com/raw/MSa1Gbjn)\",\n                required=True,\n                max_length=1024\n            ),\n            InputText(\n                label=\"Why do you want to be part of our staff?\",\n                style=TextStyles.PARAGRAPH,\n                custom_id=f'reason',\n                placeholder=\"Why do you want to be part of our staff?\",\n                required=True,\n                max_length=1024\n            )\n        ],custom_id=f'{random_string_generator()}_modapp_modal')\n\n        await ctx.send_modal(modal=m)\n        try:\n            modal_recived: ModalContext = await ctx.bot.wait_for_modal(modal=m, author=ctx.author.id, timeout=600)\n        except asyncio.TimeoutError:\n            return await ctx.author.send(f\":x: You took longer than 10 minutes to respond to the mod application  Please try again.\")\n        age_country = modal_recived.responses.get('age_country')\n        wimp = modal_recived.responses.get('wimp')\n        situation = modal_recived.responses.get('situation')\n        reason = modal_recived.responses.get('reason')\n\n        embed = Embed(title=f\"Mod Application - {ctx.author.display_name}\",\n                      thumbnail=ctx.author.display_avatar.url,\n                      color=0xf6cd4f)\n        embed.add_field(name='Age &amp; Country (Looking for variety!)', value=age_country, inline=False)\n        embed.add_field(name='Can you handle uncomfortable and difficult situations?', value=wimp, inline=False)\n        embed.add_field(name='How yould you handle the situation described in the announcement?', value=situation, inline=False)\n        embed.add_field(name='Why do you want to be part of our staff?', value=reason, inline=False)\n        embed.set_footer(text=f\"{ctx.author}|{ctx.author.id}\")\n        channel = await self.bot.fetch_channel(639258147734683659)\n        await channel.send(embed=embed)\n        await modal_recived.author.send(f\"Your mod application has been sent to the staff team.\", embed=embed)\n        await modal_recived.send(f\"Your mod application has been sent to the staff team.\", ephemeral=True)\n\n\n    @slash_command(name='delete', description=\"Allows you to delete messages, max: 700\",\n        default_member_permissions=Permissions.MANAGE_MESSAGES\n    )\n    @amount()\n    @reason()\n    async def delete_messages(self, ctx:InteractionContext, amount:int=0, reason:str='MISSING'):\n\"\"\"/delete\n        Description:\n            Allows you to delete messages, max: 700\n\n        Args:\n            amount (int, optional): Amount of messages to delete, max 700\n            reason (str, optional): Reason\n        \"\"\"\n        def chunks(l, n):\n            n = max(1, n)\n            return (l[i:i+n] for i in range(0, len(l), n))\n        await ctx.defer()\n        if (amount &lt; 2) or (amount &gt; 700):\n            embed = Embed(description=f\":x: Amount can't be less than 2 or more than 700\",\n                        color=0xDD2222)\n            await ctx.send(embed=embed)\n            return\n        messages = await ctx.channel.fetch_messages(limit=(amount+1))\n        messages.pop(0)\n        new_msgs = []\n        old_msgs = []\n        for message in messages:\n            twa = datetime.now() - timedelta(weeks=2)\n            cat = await seperate_string_number(str(message.created_at))\n            ca = datetime.fromtimestamp(int(cat[3]))\n            if ca &gt; twa:\n                new_msgs.append(message)\n            elif ca &lt; twa:\n                old_msgs.append(message)\n        for new_msgs in chunks(new_msgs, 100):\n            await ctx.channel.delete_messages(new_msgs, reason)\n        for msg in old_msgs:\n            await msg.delete()\n        embed = Embed(description=f\"I've deleted {len(new_msgs)+len(old_msgs)} messages\\nReason: {reason}\",\n                            timestamp=datetime.utcnow(),\n                            color=0xffcc50)\n        embed.set_footer(text=f\"Actioned by: {ctx.author}|{ctx.author.id}\")\n        await ctx.send(embed=embed)\n\n    @slash_command(name='userpurge', description=\"Allows you to purge users messages\",\n        default_member_permissions=Permissions.MANAGE_MESSAGES\n    )\n    @user()\n    @amount()\n    @reason()\n    async def userpurge(self, ctx: SlashContext, user: OptionType.USER = None, amount: int = None, reason: str = None):\n\"\"\"/userpurge\n         Description:\n             Allows you to purge users messages\n         Args:\n             user (OptionType.USER, optional): User\n             amount (int, optional): Amount of messages to purge, max 300\n             reason (str, optional): Reason\n         \"\"\"\n        if amount is None:\n            await ctx.send(\"Please provide the amount of messages to purge.\")\n            return\n        if amount &gt; 300:\n            await ctx.send(\"The maximum amount of messages to purge is 300.\")\n            return\n        if user is None:\n            await ctx.send(\"Please provide a user to purge messages from.\")\n            return\n        if reason is None:\n            reason = \"No reason provided.\"\n        await ctx.channel.purge(deletion_limit=amount, predicate=lambda m: m.author == user)\n        await ctx.send(f\"Purged {amount} messages from {user.mention} for reason: {reason}.\")\n\n    @slash_command(name='ban', description=\"Allows you to ban users from the server\",\n        default_member_permissions=Permissions.BAN_MEMBERS\n    )\n    @user()\n    @bantime()\n    @deletedays()\n    @reason()\n    async def ban(self, ctx:InteractionContext, user:OptionType.USER=None, reason:str='No reason given', bantime:str=None, deletedays:int=0):\n\"\"\"/ban\n        Description:\n            Ban a user from the server. \n\n        Args:\n            user: User\n            reason: Set the reason for the ban\n            bantime: Optionally specify ban time Examples: `10 S`, `10 M`, `10 H`, `10 D`. It can't be shorter than 1 hour and longer than 3 years\n            deletedays: Delete the last x days of messages from that user. You can choose from 0 to 7.\n        \"\"\"\n        await ctx.defer()\n        if user is ctx.author:\n            await ctx.send(\"You can't ban yourself\", ephemeral=True)\n            return\n        banned = await ctx.guild.fetch_ban(user)\n        if banned is None:     \n            member = find_member(ctx, user.id)\n            if member is not None:\n                if member.has_permission(Permissions.ADMINISTRATOR) == True:\n                    await ctx.send(\"You can't ban an admin\", ephemeral=True)\n                    return\n                elif member.has_permission(Permissions.BAN_MEMBERS) == True:\n                    await ctx.send(\"You can't ban users with ban perms\", ephemeral=True)\n                    return\n                elif ctx.author.top_role == member.top_role:\n                    embed = Embed(description=f\":x: You can't ban people with the same role as you!\",\n                                color=0xDD2222)\n                    await ctx.send(embed=embed)\n                    return\n\n                elif ctx.author.top_role.position &lt; member.top_role.position:\n                    embed = Embed(description=f\":x: You can't ban people with roles higher than yours!\",\n                                color=0xDD2222)\n                    await ctx.send(embed=embed)\n                    return\n\n            # while True:\n            #     banid = random_string_generator()\n            #     banid_db = await db.find_one(strikes, {'guildid':ctx.guild_id, 'strikeid':banid})\n            #     if banid_db is None:\n            #         break\n            #     else:\n            #         continue\n            # daytime = f'&lt;t:{math.ceil(datetime.now().timestamp())}&gt;'\n            if bantime is None:\n                # await db.save(strikes(strikeid=banid, guildid=ctx.guild_id, user=user.id, moderator=ctx.author.id, action=\"Ban\", day=daytime, reason=reason))\n                embed = Embed(description=f\"{user} **was banned** | {reason} \\n**User ID:** {user.id} \\n**Actioned by:** {ctx.author.mention}\",\n                                color=0xffcc50,\n                                timestamp=datetime.utcnow())\n                embed.set_thumbnail(url=user.avatar.url)\n                await ctx.send(embed=embed)\n            else:\n                tempbanned = await db.tempbans.find_one({\"user\":user.id, \"guildid\":ctx.guild_id})\n                if tempbanned is not None:\n                    await tempbanned.delete()\n\n                ban_time = [int(i) for i in bantime.lower().split() if i.isdigit()]\n                if ban_time == []:\n                    embed = Embed(description=f\":x: Ban time formatting not correct. Try again. \\n\\n[Examples: `10 S`, `10 M`, `10 H`, `10 D`]\",\n                                    color=0xDD2222)\n                    await ctx.send(embed=embed)\n                else:\n                    for num in ban_time:\n                        time = num\n                    ban_time_type = [str(type) for type in bantime.lower().split() if not type.isdigit()]\n                    for time_type in ban_time_type:\n                        type = time_type\n\n                if type in d:\n                    seconds = time * 86400\n                    endtime = datetime.now() + timedelta(days=int(time))\n\n                elif type in h:\n                    seconds = time * 3600\n                    endtime = datetime.now() + timedelta(hours=int(time))\n\n                elif type in m:\n                    seconds = time * 60\n                    endtime = datetime.now() + timedelta(minutes=int(time))\n\n                elif type in s:\n                    seconds = time\n                    endtime = datetime.now() + timedelta(seconds=int(time))\n\n                else:\n                    embed = Embed(description=f\":x: Time type not supported. You can use: {d}, {h}, {m}, {s}\",\n                                color=0xDD2222)\n                    await ctx.send(embed=embed)\n                    return\n\n                if (seconds &lt; 3600) or (seconds &gt; 94672800):\n                    await ctx.send(\"Ban time can't be shorter than 1 hour and longer than 3 years\")\n                    return\n\n                # await db.save(strikes(strikeid=banid, guildid=ctx.guild_id, user=user.id, moderator=ctx.author.id, action=\"Temp Ban\", day=daytime, reason=reason))\n                await db.tempbans(guildid=ctx.guild_id, user=user.id, starttime=datetime.now(), endtime=endtime, banreason=reason).insert()\n\n                embed = Embed(description=f\"{user} **was temporarily banned** | {reason} \\n**User ID:** {user.id} \\n**Actioned by:** {ctx.author.mention}\\n**End time:**&lt;t:{math.ceil(endtime.timestamp())}:R&gt;\",\n                                color=0xffcc50,\n                                timestamp=datetime.utcnow())\n                embed.set_thumbnail(url=user.avatar.url)\n                await ctx.send(embed=embed)\n            await ctx.guild.ban(DiscordObject(id=int(user.id), client=self.bot), reason=reason, delete_message_days=deletedays)\n        else:\n            await ctx.send(f'{user} already banned')\n\n    @slash_command(name='unban', description=\"Allows you to unban users from the server\",\n        default_member_permissions=Permissions.BAN_MEMBERS\n    )\n    @user()\n    @reason()\n    async def unban(self, ctx:InteractionContext, user:OptionType.USER=None, reason:str='No reason given'):\n\"\"\"/unban\n        Description:\n            Unban a user from the server.\n\n        Args:\n            user: User to unban\n            reason: Specify the reason for the unban\n        \"\"\"\n        await ctx.defer()\n        if user == ctx.author:\n            embed = Embed(description=f\":x: This is not how that works buddy...\",\n                        color=0xDD2222)\n            await ctx.send(embed=embed)\n            return\n        banned = await ctx.guild.fetch_ban(user)\n        if banned is None:\n            embed = Embed(description=f\":x: {user} not banned\",\n                        color=0xDD2222)\n            await ctx.send(embed=embed)\n            return\n        else:\n            await ctx.guild.unban(user, reason)\n            embed = Embed(description=f\"{user} **was unbanned by {ctx.author.mention}** | {reason} \\n**User ID:** {user.id}\",\n                                color=0xffcc50,\n                                timestamp=datetime.utcnow())\n            embed.set_thumbnail(url=user.avatar.url)\n            await ctx.send(embed=embed)\n            # \n            # while True:\n            #     banid = random_string_generator()\n            #     banid_db = await db.find_one(strikes, {'guildid':ctx.guild_id, 'strikeid':banid})\n            #     if banid_db is None:\n            #         break\n            #     else:\n            #         continue\n            # daytime = f'&lt;t:{math.ceil(datetime.now().timestamp())}&gt;'\n            # await db.save(strikes(strikeid=banid, guildid=ctx.guild_id, user=user.id, moderator=ctx.author.id, action=\"Unban\", day=daytime, reason=reason))\n\n    @slash_command(name='kick', description=\"[MOD]allows me to kick users from the server\",\n        default_member_permissions=Permissions.KICK_MEMBERS\n    )\n    @user()\n    @reason()\n    async def kick(self, ctx:InteractionContext, user:OptionType.USER=None, reason:str='No reason given'):\n\"\"\"/kick\n        Description:\n            The kick function kicks a user from the server.\n\n\n        Args:\n            user: User to kick\n            reason: Specify the reason for the kick\n        \"\"\"\n        await ctx.defer()\n        member = find_member(ctx, user.id)\n        if member is not None:\n            # if user is None:\n            #     await ctx.send('You have to include a user', ephemeral=True)\n            #     return\n            if user is ctx.author:\n                await ctx.send(\"You can't kick yourself\", ephemeral=True)\n                return\n\n            if member.has_permission(Permissions.ADMINISTRATOR) == True:\n                await ctx.send(\"You can't kick an admin\", ephemeral=True)\n                return\n            elif member.has_permission(Permissions.BAN_MEMBERS) == True:\n                await ctx.send(\"You can't kick users with ban perms\", ephemeral=True)\n                return\n            elif member.has_permission(Permissions.KICK_MEMBERS) == True:\n                await ctx.send(\"You can't kick users with kick perms\", ephemeral=True)\n                return\n\n            if ctx.author.top_role == member.top_role:\n                embed = Embed(description=f\":x: You can't kick people with the same role as you!\",\n                            color=0xDD2222)\n                await ctx.send(embed=embed)\n                return\n\n            if ctx.author.top_role.position &lt; member.top_role.position:\n                embed = Embed(description=f\":x: You can't kick people with roles higher than yours!\",\n                            color=0xDD2222)\n                await ctx.send(embed=embed)\n                return\n            # \n            # while True:\n            #     kickid = random_string_generator()\n            #     kickid_db = await db.find_one(strikes, {'guildid':ctx.guild_id, 'strikeid':kickid})\n            #     if kickid_db is None:\n            #         break\n            #     else:\n            #         continue\n            # daytime = f'&lt;t:{math.ceil(datetime.now().timestamp())}&gt;'\n            # await db.save(strikes(strikeid=kickid, guildid=ctx.guild_id, user=user.id, moderator=ctx.author.id, action=\"Kick\", day=daytime, reason=reason))\n            await ctx.guild.kick(user, reason)\n            embed = Embed(description=f\"{user} **was kicked** | {reason} \\n**User ID:** {user.id} \\n**Actioned by:** {ctx.author.mention}\",\n                        color=0xffcc50,\n                        timestamp=datetime.utcnow())\n            embed.set_thumbnail(url=user.avatar.url)\n            await ctx.send(embed=embed)\n        else:\n            raise UserNotFound()\n\n    @slash_command(name='mute', description=\"Allows you to mute users\",\n        default_member_permissions=Permissions.MODERATE_MEMBERS\n    )\n    @user()\n    @mutetime()\n    @reason()\n    async def mute(self, ctx:InteractionContext, user:OptionType.USER=None, mutetime:str=None, reason:str='No reason given'):\n\"\"\"/mute\n        Description:\n            Mutes a user for a specified amount of time. Mute time can't be shorter than 10 seconds and longer than 28 days.\n\n        Args:\n            user: User that you want to mute\n            mutetime: Specify the time, Examples: `10 S`, `10 M`, `10 H`, `10 D`\n            reason: Specify the reason for muting a user\n        \"\"\"\n        await ctx.defer()\n        if user is ctx.author:\n            await ctx.send(\"You can't mute yourself\", ephemeral=True)\n            return\n        member = find_member(ctx, user.id)\n        if member is not None:\n            if member.has_permission(Permissions.ADMINISTRATOR) == True:\n                await ctx.send(\"You can't mute an admin\", ephemeral=True)\n                return\n            elif member.has_permission(Permissions.BAN_MEMBERS) == True:\n                await ctx.send(\"You can't mute users with ban perms\", ephemeral=True)\n                return\n            elif member.has_permission(Permissions.KICK_MEMBERS) == True:\n                await ctx.send(\"You can't mute users with kick perms\", ephemeral=True)\n                return\n\n            if ctx.author.top_role == member.top_role:\n                embed = Embed(description=f\":x: You can't mute people with the same role as you!\",\n                            color=0xDD2222)\n                await ctx.send(embed=embed)\n                return\n\n            if ctx.author.top_role.position &lt; member.top_role.position:\n                embed = Embed(description=f\":x: You can't mute people with roles higher than yours!\",\n                            color=0xDD2222)\n                await ctx.send(embed=embed)\n                return\n\n            mute_time = [int(i) for i in mutetime.lower().split() if i.isdigit()]\n            if mute_time == []:\n                embed = Embed(description=f\":x: Mute time formatting not correct. Try again. \\n\\n[Examples: `10 S`, `10 M`, `10 H`, `10 D`]\",\n                                color=0xDD2222)\n                await ctx.send(embed=embed)\n            else:\n                for num in mute_time:\n                    time = num\n                mute_time_type = [str(type) for type in mutetime.lower().split() if not type.isdigit()]\n                for time_type in mute_time_type:\n                    type = time_type\n\n            if type in d:\n                seconds = time * 86400\n                endtime = datetime.now() + timedelta(days=int(time))\n\n            elif type in h:\n                seconds = time * 3600\n                endtime = datetime.now() + timedelta(hours=int(time))\n\n            elif type in m:\n                seconds = time * 60\n                endtime = datetime.now() + timedelta(minutes=int(time))\n\n            elif type in s:\n                seconds = time\n                endtime = datetime.now() + timedelta(seconds=int(time))\n\n            else:\n                embed = Embed(description=f\":x: Time type not supported. You can use: {d}, {h}, {m}, {s}\",\n                            color=0xDD2222)\n                await ctx.send(embed=embed)\n                return\n\n            if (seconds &lt; 10) or (seconds &gt; 2419200):\n                await ctx.send(\"Mute time can't be shorter than 10 seconds and longer than 28 days.\", ephemeral=True)\n            # daytime = f'&lt;t:{math.ceil(datetime.now().timestamp())}&gt;'\n            # \n            # while True:\n            #     muteid = random_string_generator()\n            #     muteid_db = await db.find_one(strikes, {'guildid':ctx.guild_id, 'strikeid':muteid})\n            #     if muteid_db is None:\n            #         break\n            #     else:\n            #         continue\n            # await db.save(strikes(strikeid=muteid, guildid=ctx.guild_id, user=member.id, moderator=ctx.author.id, action=\"Mute\", day=daytime, reason=reason))\n            await member.timeout(endtime, reason)\n            embed = Embed(description=f\"{member} **was muted** | {reason} \\n**User ID:** {member.id} \\n**Actioned by:** {ctx.author.mention}\\n**End time:**&lt;t:{math.ceil(endtime.timestamp())}:R&gt;\",\n                            color=0xffcc50,\n                            timestamp=datetime.utcnow())\n            embed.set_thumbnail(url=member.avatar.url)\n            await ctx.send(embed=embed)\n        else:\n            raise UserNotFound()\n\n    @slash_command(name='unmute', description=\"[MOD]allows me to unmute users\",\n        default_member_permissions=Permissions.MODERATE_MEMBERS\n    )\n    @user()\n    @reason()\n    async def unmute(self, ctx:InteractionContext, user:OptionType.USER=None, reason:str='No reason given'):\n\"\"\"/unmute\n        Description:\n            Unmute a user.\n\n\n        Args:\n            user: User\n            reason: Set the reason for unmuting a user\n        \"\"\"\n        await ctx.defer()\n        member = find_member(ctx, user.id)\n        if member is not None:\n            await member.timeout(None, '[UNMUTE] '+reason)\n            embed = Embed(description=f\"{user} **was unmuted** | {reason} \\n**User ID:** {user.id} \\n**Actioned by:** {ctx.author.mention}\",\n                            color=0xffcc50,\n                            timestamp=datetime.utcnow())\n            embed.set_thumbnail(url=user.avatar.url)\n            await ctx.send(embed=embed)\n        else:\n            raise UserNotFound()\n\n    warn = SlashCommand(name='warn', default_member_permissions=Permissions.MODERATE_MEMBERS)\n\n    @warn.subcommand('add', sub_cmd_description='Add a warn to a member.')\n    @slash_option(\n        name=\"type\",\n        description=\"Warn type\",\n        required=True,\n        opt_type=OptionType.STRING,\n        choices=[\n            SlashCommandChoice(name=\"Minor\", value='Minor'),\n            SlashCommandChoice(name=\"Major\", value='Major'),\n        ]\n    )\n    @user()\n    @reason()\n    async def warnadd(self, ctx:InteractionContext, type:str, user:OptionType.USER, reason:str=None):\n\"\"\"/warn add\n        Description:\n            Gives user a warning, depending on type it gives them a warn role, It also sends them a warn DM if available.\n\n        Args:\n            type: Specify the type of warning, either major or minor\n            user: User\n            reason: Reason for the warning\n        \"\"\"\n        await ctx.defer()\n        if user is ctx.author:\n            await ctx.send(\"You can't warn yourself\", ephemeral=True)\n            return\n        elif reason is None:\n            await ctx.send(\"You have to include a reason\", ephemeral=True)\n            return\n        member = ctx.guild.get_member(user.id)\n        if member is not None:\n            while True:\n                warnid = random_string_generator()\n                warnid_db = await db.strikes.find_one({'guildid':ctx.guild_id, 'strikeid':warnid})\n                if warnid_db is None:\n                    break\n                else:\n                    continue\n\n            if type == 'Major':\n                warnings = db.strikes.find({'guildid':ctx.guild_id, 'user':user.id, 'action':{'$regex':'^warn$', '$options':'i'}, 'type':'Major'})\n                warncount = []\n                async for warn in warnings:\n                    warncount.append(warn.strikeid)\n                if warncount == []:\n                    warnrolename = 'Warning-1'\n                else:\n                    warnrolename = f'Warning-{len(warncount)+1}'\n\n                warn_role = [role for role in ctx.guild.roles if role.name == warnrolename]\n                if warn_role == []:\n                    role = await ctx.guild.create_role(name=warnrolename, reason='[automod]|[warn]created new warnrole as warnrole with this number did not exist yet')\n                else:\n                    for role in warn_role:\n                        role = role\n\n                await user.add_role(role, reason)\n\n                try:\n                    embed = Embed(\n                        title='Major Warning',\n                        description=f\":grey_exclamation: **You've been given a major warning in {ctx.guild.name} for:** {reason}\",\n                        color=0xffcc50)\n                    await user.send(embed=embed)\n                except HTTPException:\n                    embed = Embed(\n                        title='Major Warning',\n                        description=f\"Couldn't dm {user.mention}, major warn logged and user was given {role.mention} | {reason} \\n**User ID:** {user.id} \\n**Actioned by:** {ctx.author.mention}\",\n                        color=0xffcc50)\n                    await ctx.send(embed=embed)\n                else:\n                    embed = Embed(\n                        title='Major Warning',\n                        description=f\"{user.mention} warned and given {role.mention} | {reason} \\n**User ID:** {user.id} \\n**Actioned by:** {ctx.author.mention}\",\n                        color=0xffcc50)\n                    await ctx.send(embed=embed)\n            elif type == 'Minor':\n                try:\n                    embed = Embed(\n                        title='Minor Warning',\n                        description=f\":grey_exclamation: **You've been given a minor warning in {ctx.guild.name} for:** {reason}\",\n                        color=0xffcc50)\n                    await user.send(embed=embed)\n                except HTTPException:\n                    embed = Embed(\n                        title='Minor Warning',\n                        description=f\"Couldn't dm {user.mention}, minor warn logged | {reason} \\n**User ID:** {user.id} \\n**Actioned by:** {ctx.author.mention}\",\n                        color=0xffcc50\n                    )\n                    await ctx.send(embed=embed)\n                else:\n                    embed = Embed(\n                        title='Minor Warning', \n                        description=f\"{user.mention} warned | {reason} \\n**User ID:** {user.id} \\n**Actioned by:** {ctx.author.mention}\",\n                        color=0xffcc50)\n                    await ctx.send(embed=embed)\n\n            daytime = f'&lt;t:{math.ceil(datetime.now().timestamp())}&gt;'\n            await db.strikes(type=type, strikeid=warnid, guildid=ctx.guild_id, user=user.id, moderator=ctx.author.id, action=\"Warn\", day=daytime, reason=reason).insert()\n\n            mw = db.strikes.find({'type':'Minor', 'guildid':ctx.guild_id, 'user':user.id, 'action':{'$regex':'^warn$', '$options':'i'}})\n            mwc = []\n            counter = []\n            i = 1\n            while i &lt; 11:\n                v = 3 * i\n                counter.append(v)\n                i = i + 1\n            async for warn in mw:\n                mwc.append(warn.strikeid)\n            if len(mwc) in counter:\n                await ctx.send(f'**[REMINDER]** {user} now has {len(mwc)} minor warnings.')\n        else:\n            raise UserNotFound()\n\n    @warn.subcommand('remove', sub_cmd_description='Remove a warn from a member.')\n    @user()\n    @warnid()\n    @reason()\n    async def warn_remove(self, ctx:InteractionContext, user:OptionType.USER=None, warnid:str=None, reason:str=None):\n\"\"\"/warn remove\n        Description:\n            Remove a warn from a user.\n\n        Args:\n            user: User to remove a warn from\n            warnid: warnID\n            reason: Specify the reason for removing the warn\n        \"\"\"\n        await ctx.defer()\n        if user is ctx.author:\n            await ctx.send(\"You can't remove a warn from yourself\", ephemeral=True)\n            return\n        elif reason is None:\n            await ctx.send(\"You have to include a reason\", ephemeral=True)\n            return\n        member = find_member(ctx, user.id)\n        if member is not None:\n            warning = await db.strikes.find_one({'guildid':ctx.guild_id, 'user':user.id, 'action':{'$regex':'^warn$', '$options':'i'}, 'strikeid':warnid})\n            if warning is None:\n                return await ctx.send(f'Warning not found for {user}', ephemeral=True)\n            warncount = []\n            async for warn in db.strikes.find({'guildid':ctx.guild_id, 'user':user.id, 'action':{'$regex':'^warn$', '$options':'i'}}):\n                warncount.append(warn.strikeid)\n            warnrolename = f'Warning-{len(warncount)}'\n            warn_role = [role for role in ctx.guild.roles if role.name == warnrolename]\n            for role in warn_role:\n                await user.remove_role(role, reason)\n                await warning.delete()\n                embed = Embed(description=f\"warn removed from {user.mention}, {role.mention} was taken away | {reason} \\n**User ID:** {user.id} \\n**Actioned by:** {ctx.author.mention}\",\n                            color=0xffcc50)\n                await ctx.send(embed=embed)\n        else:\n            raise UserNotFound()\n\n    @warn.subcommand('removeall', sub_cmd_description='Remove all warns from a member.')\n    @user()\n    async def warnremoveall(self, ctx:InteractionContext, user: OptionType.USER):\n\"\"\"/warn removeall\n        Description:\n            Removes all warns from a user.\n\n        Args:\n            user: The user that you want to remove all warns from\n        \"\"\"\n        await ctx.defer()\n        if ctx.author != 400713431423909889:\n            await ctx.send(\"This command cannot be used.\", ephemeral=True)\n            return\n        if user is ctx.author:\n            await ctx.send(\"You can't remove a warn from yourself\", ephemeral=True)\n            return\n        await db.strikes.find({'guildid':ctx.guild_id, 'user':user.id, 'action':'Warn'}).delete_many()\n        await ctx.send(f'All warns removed from {user}')\n\n    @slash_command(name='warnings', description=\"shows you a users warn list\",\n        default_member_permissions=Permissions.MODERATE_MEMBERS\n    )\n    @user()\n    async def warn_list(self, ctx:InteractionContext, user:OptionType.USER):\n\"\"\"/warnings\n        Description:\n            Display a list of warnings for a user.\n\n        Args:\n            user: User\n        \"\"\"\n        await ctx.defer()\n        def chunks(l, n):\n            n = max(1, n)\n            return (l[i:i+n] for i in range(0, len(l), n))\n\n        def mlis(lst, s, e):\n            nc = list(chunks(lst, 20))\n            mc = ''\n            for testlist in nc[s:e]:\n                for m in testlist:\n                    mc = mc + m\n            return mc\n\n        def newpage(title, warns):\n            embed = Embed(\n                title=title,\n                description=warns,\n                color=0xffcc50)\n            return embed\n\n        warnings = db.strikes.find({'guildid':ctx.guild_id, 'user':user.id, 'action':'Warn'})\n        warns = []\n        async for warn in warnings:\n            if warn.type is None:\n                warntype = 'Major'\n            else:\n                warntype = warn.type\n            warns.append(f\"**Type:** {warntype} | **Warning ID:** {warn.strikeid} | **Reason:** {warn.reason} | **Moderator:** {warn.moderator} | **Day:** {warn.day}\\n\\n\")\n        if warns == []:\n            embed = Embed(description=f\"There are no warnings for {user}.\",\n                        color=0xffcc50)\n            await ctx.send(embed=embed)\n            return\n\n        s = -1\n        e = 0\n        embedcount = 1\n        nc = list(chunks(warns, 20))\n\n        embeds = []\n        while embedcount &lt;= len(nc):\n            s = s+1\n            e = e+1\n            embeds.append(newpage(f'Warnings for {user}', mlis(warns, s, e)))\n            embedcount = embedcount+1\n\n        paginator = Paginator(\n            client=self.bot, \n            pages=embeds,\n            timeout_interval=80,\n            show_select_menu=False)\n        await paginator.send(ctx)\n\n    @slash_command(name='strikes', description=\"shows you a users strike list\",\n        default_member_permissions=Permissions.MODERATE_MEMBERS\n    )\n    @user()\n    async def strikes_list(self, ctx:InteractionContext, user:OptionType.USER=None):\n\"\"\"/strikes\n        Description:\n            List all strikes for a user.\n\n        Args:\n            user: Specify that the user parameter is an optional parameter\n        \"\"\"\n        await ctx.defer()\n        def chunks(l, n):\n            n = max(1, n)\n            return (l[i:i+n] for i in range(0, len(l), n))\n\n        def mlis(lst, s, e):\n            nc = list(chunks(lst, 20))\n            mc = ''\n            for testlist in nc[s:e]:\n                for m in testlist:\n                    mc = mc + m\n            return mc\n\n        def newpage(title, warns):\n            embed = Embed(\n                title=title,\n                description=warns,\n                color=0xffcc50)\n            return embed\n\n        all_strikes = db.strikes.find({'guildid':ctx.guild_id, 'user':user.id})\n        allstrikes = []\n        async for s in all_strikes:\n            if s.action.lower() != 'warn':\n                allstrikes.append(f\"**Strike ID:** {s.strikeid} | **Action:** {s.action} | **Reason:** {s.reason} | **Moderator:** {s.moderator} | **Day:** {s.day}\\n\\n\")\n            else:\n                if s.type is None:\n                    warntype = 'Major'\n                else:\n                    warntype = s.type\n                allstrikes.append(f\"**Strike ID:** {s.strikeid} | **Action:** {warntype} {s.action} | **Reason:** {s.reason} | **Moderator:** {s.moderator} | **Day:** {s.day}\\n\\n\")\n\n        if allstrikes == []:\n            embed = Embed(description=f\"There are no strikes for {user}.\",\n                        color=0xffcc50)\n            await ctx.send(embed=embed)\n            return\n\n        s = -1\n        e = 0\n        embedcount = 1\n        nc = list(chunks(allstrikes, 20))\n\n        embeds = []\n        while embedcount &lt;= len(nc):\n            s = s+1\n            e = e+1\n            embeds.append(newpage(f'Strikes for {user}', mlis(allstrikes, s, e)))\n            embedcount = embedcount+1\n\n        paginator = Paginator(\n            client=self.bot, \n            pages=embeds,\n            timeout_interval=80,\n            show_select_menu=False)\n        await paginator.send(ctx)\n\n    @slash_command('removeallstrikes', description='Remove all strikes from a member.')\n    @member()\n    async def strikesremoveall(self, ctx:InteractionContext, user: OptionType.USER):\n\"\"\"/removeallstrikes\n        Description:\n            Remove all strikes from a user.\n\n        Args:\n            user: Specify the user that is being removed from the database\n        \"\"\"\n\n        await ctx.defer()\n        if ctx.author.id != 400713431423909889:\n            await ctx.send(\"This command cannot be used.\", ephemeral=True)\n            return\n        print(user.id)\n        await db.strikes.find({'guildid':ctx.guild_id, 'user':user.id}).delete_many()\n        await ctx.send(f'All strikes removed from {user}')\n\n    @slash_command(name='strike', description=\"look at a strike info\",\n        default_member_permissions=Permissions.MODERATE_MEMBERS,\n    )\n    @warnid()\n    async def strike_info(self, ctx:InteractionContext, warnid:str=None):\n\"\"\"/strike\n        Description:\n            Display information about a specific strike.\n\n        Args:\n            warnid: WarnID\n        \"\"\"\n        await ctx.defer()\n        s = await db.strikes.find_one({'guildid':ctx.guild_id, 'strikeid':warnid})\n        if s is None:\n            return await ctx.send(f'Strike not found', ephemeral=True)\n        if s.action.lower() != 'warn':\n            info = f\"**Strike ID:** {s.strikeid} | **Action:** {s.action} | **Reason:** {s.reason} | **Moderator:** {s.moderator} | **Day:** {s.day}\"\n        else:\n            if s.type is None:\n                warntype = 'Major'\n            else:\n                warntype = s.type\n            info = f\"**Strike ID:** {s.strikeid} | **Action:** {warntype} {s.action} | **Reason:** {s.reason} | **Moderator:** {s.moderator} | **Day:** {s.day}\"\n        embed = Embed(\n            description=info,\n            color=0xffcc50)\n        await ctx.send(embed=embed)\n\n    @slash_command(name='reason', description=\"allows me to modify reasons of strikes\",\n        default_member_permissions=Permissions.MODERATE_MEMBERS,\n    )\n    @warnid()\n    @reason()\n    async def strike_reason(self, ctx:InteractionContext, warnid:str=None, reason:str=None):\n\"\"\"/reason\n        Description:\n            Allows a user to change the reason of a strike.\n            This is useful if the original reason was not clear enough or if it was changed by mistake.\n            The function takes in two arguments: ctx and warnid, with an optional third argument being reason.\n            If no reason is provided, then the user will be prompted to provide one.\n\n        Args:\n            warnid: warnID\n            reason: Set the reason for the strike\n        \"\"\"\n        await ctx.defer()\n        if reason is None:\n            await ctx.send(\"You have to include a reason\", ephemeral=True)\n            return\n        strike = await db.strikes.find_one({'guildid':ctx.guild_id, 'strikeid':warnid})\n        if strike is None:\n            return await ctx.send(f'Strike not found', ephemeral=True)\n        if strike.user == ctx.author.id:\n            await ctx.send(\"You can't change a reason on a strike directed at you\", ephemeral=True)\n            return\n        embed = Embed(\n            description=f\"Strike reason changed from `{strike.reason}` to `{reason}`\\n**Strike ID:** {strike.strikeid}\\n**Action:** {strike.action}\\n**User ID:** {strike.user} \\n**Actioned by:** {ctx.author.mention}\",\n            color=0xffcc50)\n        await ctx.send(embed=embed)\n        strike.reason = reason\n        await strike.save()\n\n    @slash_command(name='limbo', sub_cmd_name='add', sub_cmd_description=\"[MOD]allows me to limbo users\", scopes=[435038183231848449,149167686159564800],\n        default_member_permissions=Permissions.BAN_MEMBERS\n    )\n    @user()\n    @reason()\n    async def limbo_add(self, ctx:InteractionContext, user:OptionType.USER=None, reason:str=None):\n        await ctx.defer()\n        if reason is None:\n            await ctx.send('You have to include a reason', ephemeral=True)\n            return\n        member = find_member(ctx, user.id)\n        if member is not None:\n            if member.has_permission(Permissions.ADMINISTRATOR) == True:\n                await ctx.send(\"You can't limbo an admin\", ephemeral=True)\n                return\n            elif member.has_permission(Permissions.BAN_MEMBERS) == True:\n                await ctx.send(\"You can't limbo users with ban perms\", ephemeral=True)\n                return\n            elif member.has_permission(Permissions.KICK_MEMBERS) == True:\n                await ctx.send(\"You can't limbo users with kick perms\", ephemeral=True)\n                return\n\n            if member.roles:\n                if ctx.author.top_role == member.top_role:\n                    embed = Embed(description=f\":x: You can't limbo people with the same role as you!\",\n                                color=0xDD2222)\n                    await ctx.send(embed=embed)\n                    return\n\n                if ctx.author.top_role.position &lt; member.top_role.position:\n                    embed = Embed(description=f\":x: You can't limbo people with roles higher than yours!\",\n                                color=0xDD2222)\n                    await ctx.send(embed=embed)\n                    return\n\n            limboed = await db.limbo.find_one({'guildid':ctx.guild_id, 'userid':member.id})\n            if limboed is not None:\n                await ctx.send(f'{member.mention} is already in limbo', ephemeral=True)\n                return\n            limbo_role = [role for role in ctx.guild.roles if role.name == 'Limbo']\n            if limbo_role == []:\n                limborole = await ctx.guild.create_role(name='Limbo', reason='[automod]|[limbo]created new limbo role as limbo role did not exist yet')\n            else:\n                for role in limbo_role:\n                    limborole = role\n            user_roles = [role for role in member.roles if role.name != '@everyone']\n            ur = ''\n            for r in user_roles:\n                ur = ur+f\"{r.id},\"\n            await db.limbo(guildid=ctx.guild_id, userid=member.id, roles=ur, reason=reason).insert()\n            for user_role in user_roles:\n                await member.remove_role(user_role)\n            await member.add_role(limborole)\n            embed = Embed(description=f\"{member.mention} put in limbo | {reason} \\n**User ID:** {member.id} \\n**Actioned by:** {ctx.author.mention}\",\n                        color=0xffcc50)\n            await ctx.send(embed=embed)\n            while True:\n                warnid = random_string_generator()\n                warnid_db = await db.strikes.find_one({'guildid':ctx.guild_id, 'strikeid':warnid})\n                if warnid_db is None:\n                    break\n                else:\n                    continue\n            daytime = f'&lt;t:{math.ceil(datetime.now().timestamp())}&gt;'\n            await db.strikes(strikeid=warnid, guildid=ctx.guild_id, user=member.id, moderator=ctx.author.id, action=\"Limbo\", day=daytime, reason=reason).insert()\n        else:\n            raise UserNotFound()\n\n    @slash_command(name='limbo', sub_cmd_name='remove', sub_cmd_description=\"[MOD]allows me to let users out of limbo\", scopes=[435038183231848449,149167686159564800],\n        default_member_permissions=Permissions.BAN_MEMBERS\n    )\n    @user()\n    @reason()\n    async def limbo_remove(self, ctx:InteractionContext, user:OptionType.USER=None, reason:str=None):\n        await ctx.defer()\n        if reason is None:\n            await ctx.send('You have to include a reason', ephemeral=True)\n            return\n        member = find_member(ctx, user.id)\n        if member is not None:\n\n            limboed = await db.limbo.find_one({'guildid':ctx.guild_id, 'userid':member.id})\n            if limboed is None:\n                await ctx.send(f'{member.mention} is not in limbo', ephemeral=True)\n                return\n\n            limborole = [role for role in member.roles if role.name == 'Limbo']\n            for limborole in limborole:\n                limborole = limborole\n\n            user_limbo_data = await db.limbo.find_one({\"guildid\":ctx.guild_id, \"userid\":member.id})\n            roles = [ctx.guild.get_role(int(id_)) for id_ in user_limbo_data.roles.split(\",\") if len(id_)]\n            for r in roles:\n                await member.add_role(r)\n            await member.remove_role(limborole)\n\n            await user_limbo_data.delete()\n\n            embed = Embed(description=f\"{member.mention} let out of limbo | {reason} \\n**User ID:** {member.id} \\n**Actioned by:** {ctx.author.mention}\",\n                        color=0xffcc50)\n            await ctx.send(embed=embed)\n        else:\n            raise UserNotFound\n\n    # @listen()\n    # async def on_message_create(self, event):\n    #     message = event.message\n    #     if message.guild.id == 149167686159564800:\n    #         \n    #         channel = await db.find_one(logs, {'guild_id':message.guild.id})\n    #         if channel is not None:\n    #             log_channel = message.guild.get_channel(int(channel.channel_id))\n\n    #             if message.channel.id == 736680179253903491:\n    #                 embed = Embed(title=\"Limbo log\", timestamp=datetime.utcnow(), color=0xffcc50)\n    #                 embed.set_thumbnail(url=f'{message.author.avatar.url}')\n    #                 embed.add_field(name=f\"{message.author}\", value=f\"{message.content}\", inline=False)\n    #                 embed.set_footer(text=f'User ID: {message.author.id}')\n    #                 await log_channel.send(embed=embed)\n\n    from interactions.models.internal.tasks import Task\n    from interactions.models.internal.tasks.triggers import IntervalTrigger\n\n    @Task.create(IntervalTrigger(seconds=60))\n    async def unban_task(self):\n        endtimes = db.tempbans.find({'endtime':{'$lte':datetime.now()}})\n        async for m in endtimes:\n            if m is not None:\n                guild = self.bot.get_guild(m.guildid)\n                if guild is None:\n                    if self.bot.user.id != 785122198247178260:\n                        print(f\"[automod]|[unban_task]{m.guildid} not found in the guild list\")\n                        await m.delete()\n                        return\n                elif guild is not None:\n                    banned = await guild.fetch_ban(m.user)\n                    if banned is None:\n                        print(f\"[automod]|[unban_task]{m.user} not found in the ban list\")\n                        await m.delete()\n                        return\n                    await guild.unban(m.user, '[automod]|[unban_task] ban time expired')\n                    await m.delete()\n</code></pre>"},{"location":"moderation/#extentions.moderation.Moderation.delete_messages","title":"<code>delete_messages(ctx, amount=0, reason='MISSING')</code>  <code>async</code>","text":"<p>/delete</p> Description <p>Allows you to delete messages, max: 700</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>int</code> <p>Amount of messages to delete, max 700</p> <code>0</code> <code>reason</code> <code>str</code> <p>Reason</p> <code>'MISSING'</code> Source code in <code>extentions/moderation.py</code> <pre><code>@slash_command(name='delete', description=\"Allows you to delete messages, max: 700\",\n    default_member_permissions=Permissions.MANAGE_MESSAGES\n)\n@amount()\n@reason()\nasync def delete_messages(self, ctx:InteractionContext, amount:int=0, reason:str='MISSING'):\n\"\"\"/delete\n    Description:\n        Allows you to delete messages, max: 700\n\n    Args:\n        amount (int, optional): Amount of messages to delete, max 700\n        reason (str, optional): Reason\n    \"\"\"\n    def chunks(l, n):\n        n = max(1, n)\n        return (l[i:i+n] for i in range(0, len(l), n))\n    await ctx.defer()\n    if (amount &lt; 2) or (amount &gt; 700):\n        embed = Embed(description=f\":x: Amount can't be less than 2 or more than 700\",\n                    color=0xDD2222)\n        await ctx.send(embed=embed)\n        return\n    messages = await ctx.channel.fetch_messages(limit=(amount+1))\n    messages.pop(0)\n    new_msgs = []\n    old_msgs = []\n    for message in messages:\n        twa = datetime.now() - timedelta(weeks=2)\n        cat = await seperate_string_number(str(message.created_at))\n        ca = datetime.fromtimestamp(int(cat[3]))\n        if ca &gt; twa:\n            new_msgs.append(message)\n        elif ca &lt; twa:\n            old_msgs.append(message)\n    for new_msgs in chunks(new_msgs, 100):\n        await ctx.channel.delete_messages(new_msgs, reason)\n    for msg in old_msgs:\n        await msg.delete()\n    embed = Embed(description=f\"I've deleted {len(new_msgs)+len(old_msgs)} messages\\nReason: {reason}\",\n                        timestamp=datetime.utcnow(),\n                        color=0xffcc50)\n    embed.set_footer(text=f\"Actioned by: {ctx.author}|{ctx.author.id}\")\n    await ctx.send(embed=embed)\n</code></pre>"},{"location":"moderation/#extentions.moderation.Moderation.userpurge","title":"<code>userpurge(ctx, user=None, amount=None, reason=None)</code>  <code>async</code>","text":"<p>/userpurge</p> Description <p>Allows you to purge users messages</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>OptionType.USER</code> <p>User</p> <code>None</code> <code>amount</code> <code>int</code> <p>Amount of messages to purge, max 300</p> <code>None</code> <code>reason</code> <code>str</code> <p>Reason</p> <code>None</code> Source code in <code>extentions/moderation.py</code> <pre><code>@slash_command(name='userpurge', description=\"Allows you to purge users messages\",\n    default_member_permissions=Permissions.MANAGE_MESSAGES\n)\n@user()\n@amount()\n@reason()\nasync def userpurge(self, ctx: SlashContext, user: OptionType.USER = None, amount: int = None, reason: str = None):\n\"\"\"/userpurge\n     Description:\n         Allows you to purge users messages\n     Args:\n         user (OptionType.USER, optional): User\n         amount (int, optional): Amount of messages to purge, max 300\n         reason (str, optional): Reason\n     \"\"\"\n    if amount is None:\n        await ctx.send(\"Please provide the amount of messages to purge.\")\n        return\n    if amount &gt; 300:\n        await ctx.send(\"The maximum amount of messages to purge is 300.\")\n        return\n    if user is None:\n        await ctx.send(\"Please provide a user to purge messages from.\")\n        return\n    if reason is None:\n        reason = \"No reason provided.\"\n    await ctx.channel.purge(deletion_limit=amount, predicate=lambda m: m.author == user)\n    await ctx.send(f\"Purged {amount} messages from {user.mention} for reason: {reason}.\")\n</code></pre>"},{"location":"moderation/#extentions.moderation.Moderation.ban","title":"<code>ban(ctx, user=None, reason='No reason given', bantime=None, deletedays=0)</code>  <code>async</code>","text":"<p>/ban</p> Description <p>Ban a user from the server. </p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>OptionType.USER</code> <p>User</p> <code>None</code> <code>reason</code> <code>str</code> <p>Set the reason for the ban</p> <code>'No reason given'</code> <code>bantime</code> <code>str</code> <p>Optionally specify ban time Examples: <code>10 S</code>, <code>10 M</code>, <code>10 H</code>, <code>10 D</code>. It can't be shorter than 1 hour and longer than 3 years</p> <code>None</code> <code>deletedays</code> <code>int</code> <p>Delete the last x days of messages from that user. You can choose from 0 to 7.</p> <code>0</code> Source code in <code>extentions/moderation.py</code> <pre><code>@slash_command(name='ban', description=\"Allows you to ban users from the server\",\n    default_member_permissions=Permissions.BAN_MEMBERS\n)\n@user()\n@bantime()\n@deletedays()\n@reason()\nasync def ban(self, ctx:InteractionContext, user:OptionType.USER=None, reason:str='No reason given', bantime:str=None, deletedays:int=0):\n\"\"\"/ban\n    Description:\n        Ban a user from the server. \n\n    Args:\n        user: User\n        reason: Set the reason for the ban\n        bantime: Optionally specify ban time Examples: `10 S`, `10 M`, `10 H`, `10 D`. It can't be shorter than 1 hour and longer than 3 years\n        deletedays: Delete the last x days of messages from that user. You can choose from 0 to 7.\n    \"\"\"\n    await ctx.defer()\n    if user is ctx.author:\n        await ctx.send(\"You can't ban yourself\", ephemeral=True)\n        return\n    banned = await ctx.guild.fetch_ban(user)\n    if banned is None:     \n        member = find_member(ctx, user.id)\n        if member is not None:\n            if member.has_permission(Permissions.ADMINISTRATOR) == True:\n                await ctx.send(\"You can't ban an admin\", ephemeral=True)\n                return\n            elif member.has_permission(Permissions.BAN_MEMBERS) == True:\n                await ctx.send(\"You can't ban users with ban perms\", ephemeral=True)\n                return\n            elif ctx.author.top_role == member.top_role:\n                embed = Embed(description=f\":x: You can't ban people with the same role as you!\",\n                            color=0xDD2222)\n                await ctx.send(embed=embed)\n                return\n\n            elif ctx.author.top_role.position &lt; member.top_role.position:\n                embed = Embed(description=f\":x: You can't ban people with roles higher than yours!\",\n                            color=0xDD2222)\n                await ctx.send(embed=embed)\n                return\n\n        # while True:\n        #     banid = random_string_generator()\n        #     banid_db = await db.find_one(strikes, {'guildid':ctx.guild_id, 'strikeid':banid})\n        #     if banid_db is None:\n        #         break\n        #     else:\n        #         continue\n        # daytime = f'&lt;t:{math.ceil(datetime.now().timestamp())}&gt;'\n        if bantime is None:\n            # await db.save(strikes(strikeid=banid, guildid=ctx.guild_id, user=user.id, moderator=ctx.author.id, action=\"Ban\", day=daytime, reason=reason))\n            embed = Embed(description=f\"{user} **was banned** | {reason} \\n**User ID:** {user.id} \\n**Actioned by:** {ctx.author.mention}\",\n                            color=0xffcc50,\n                            timestamp=datetime.utcnow())\n            embed.set_thumbnail(url=user.avatar.url)\n            await ctx.send(embed=embed)\n        else:\n            tempbanned = await db.tempbans.find_one({\"user\":user.id, \"guildid\":ctx.guild_id})\n            if tempbanned is not None:\n                await tempbanned.delete()\n\n            ban_time = [int(i) for i in bantime.lower().split() if i.isdigit()]\n            if ban_time == []:\n                embed = Embed(description=f\":x: Ban time formatting not correct. Try again. \\n\\n[Examples: `10 S`, `10 M`, `10 H`, `10 D`]\",\n                                color=0xDD2222)\n                await ctx.send(embed=embed)\n            else:\n                for num in ban_time:\n                    time = num\n                ban_time_type = [str(type) for type in bantime.lower().split() if not type.isdigit()]\n                for time_type in ban_time_type:\n                    type = time_type\n\n            if type in d:\n                seconds = time * 86400\n                endtime = datetime.now() + timedelta(days=int(time))\n\n            elif type in h:\n                seconds = time * 3600\n                endtime = datetime.now() + timedelta(hours=int(time))\n\n            elif type in m:\n                seconds = time * 60\n                endtime = datetime.now() + timedelta(minutes=int(time))\n\n            elif type in s:\n                seconds = time\n                endtime = datetime.now() + timedelta(seconds=int(time))\n\n            else:\n                embed = Embed(description=f\":x: Time type not supported. You can use: {d}, {h}, {m}, {s}\",\n                            color=0xDD2222)\n                await ctx.send(embed=embed)\n                return\n\n            if (seconds &lt; 3600) or (seconds &gt; 94672800):\n                await ctx.send(\"Ban time can't be shorter than 1 hour and longer than 3 years\")\n                return\n\n            # await db.save(strikes(strikeid=banid, guildid=ctx.guild_id, user=user.id, moderator=ctx.author.id, action=\"Temp Ban\", day=daytime, reason=reason))\n            await db.tempbans(guildid=ctx.guild_id, user=user.id, starttime=datetime.now(), endtime=endtime, banreason=reason).insert()\n\n            embed = Embed(description=f\"{user} **was temporarily banned** | {reason} \\n**User ID:** {user.id} \\n**Actioned by:** {ctx.author.mention}\\n**End time:**&lt;t:{math.ceil(endtime.timestamp())}:R&gt;\",\n                            color=0xffcc50,\n                            timestamp=datetime.utcnow())\n            embed.set_thumbnail(url=user.avatar.url)\n            await ctx.send(embed=embed)\n        await ctx.guild.ban(DiscordObject(id=int(user.id), client=self.bot), reason=reason, delete_message_days=deletedays)\n    else:\n        await ctx.send(f'{user} already banned')\n</code></pre>"},{"location":"moderation/#extentions.moderation.Moderation.unban","title":"<code>unban(ctx, user=None, reason='No reason given')</code>  <code>async</code>","text":"<p>/unban</p> Description <p>Unban a user from the server.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>OptionType.USER</code> <p>User to unban</p> <code>None</code> <code>reason</code> <code>str</code> <p>Specify the reason for the unban</p> <code>'No reason given'</code> Source code in <code>extentions/moderation.py</code> <pre><code>@slash_command(name='unban', description=\"Allows you to unban users from the server\",\n    default_member_permissions=Permissions.BAN_MEMBERS\n)\n@user()\n@reason()\nasync def unban(self, ctx:InteractionContext, user:OptionType.USER=None, reason:str='No reason given'):\n\"\"\"/unban\n    Description:\n        Unban a user from the server.\n\n    Args:\n        user: User to unban\n        reason: Specify the reason for the unban\n    \"\"\"\n    await ctx.defer()\n    if user == ctx.author:\n        embed = Embed(description=f\":x: This is not how that works buddy...\",\n                    color=0xDD2222)\n        await ctx.send(embed=embed)\n        return\n    banned = await ctx.guild.fetch_ban(user)\n    if banned is None:\n        embed = Embed(description=f\":x: {user} not banned\",\n                    color=0xDD2222)\n        await ctx.send(embed=embed)\n        return\n    else:\n        await ctx.guild.unban(user, reason)\n        embed = Embed(description=f\"{user} **was unbanned by {ctx.author.mention}** | {reason} \\n**User ID:** {user.id}\",\n                            color=0xffcc50,\n                            timestamp=datetime.utcnow())\n        embed.set_thumbnail(url=user.avatar.url)\n        await ctx.send(embed=embed)\n</code></pre>"},{"location":"moderation/#extentions.moderation.Moderation.kick","title":"<code>kick(ctx, user=None, reason='No reason given')</code>  <code>async</code>","text":"<p>/kick</p> Description <p>The kick function kicks a user from the server.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>OptionType.USER</code> <p>User to kick</p> <code>None</code> <code>reason</code> <code>str</code> <p>Specify the reason for the kick</p> <code>'No reason given'</code> Source code in <code>extentions/moderation.py</code> <pre><code>@slash_command(name='kick', description=\"[MOD]allows me to kick users from the server\",\n    default_member_permissions=Permissions.KICK_MEMBERS\n)\n@user()\n@reason()\nasync def kick(self, ctx:InteractionContext, user:OptionType.USER=None, reason:str='No reason given'):\n\"\"\"/kick\n    Description:\n        The kick function kicks a user from the server.\n\n\n    Args:\n        user: User to kick\n        reason: Specify the reason for the kick\n    \"\"\"\n    await ctx.defer()\n    member = find_member(ctx, user.id)\n    if member is not None:\n        # if user is None:\n        #     await ctx.send('You have to include a user', ephemeral=True)\n        #     return\n        if user is ctx.author:\n            await ctx.send(\"You can't kick yourself\", ephemeral=True)\n            return\n\n        if member.has_permission(Permissions.ADMINISTRATOR) == True:\n            await ctx.send(\"You can't kick an admin\", ephemeral=True)\n            return\n        elif member.has_permission(Permissions.BAN_MEMBERS) == True:\n            await ctx.send(\"You can't kick users with ban perms\", ephemeral=True)\n            return\n        elif member.has_permission(Permissions.KICK_MEMBERS) == True:\n            await ctx.send(\"You can't kick users with kick perms\", ephemeral=True)\n            return\n\n        if ctx.author.top_role == member.top_role:\n            embed = Embed(description=f\":x: You can't kick people with the same role as you!\",\n                        color=0xDD2222)\n            await ctx.send(embed=embed)\n            return\n\n        if ctx.author.top_role.position &lt; member.top_role.position:\n            embed = Embed(description=f\":x: You can't kick people with roles higher than yours!\",\n                        color=0xDD2222)\n            await ctx.send(embed=embed)\n            return\n        # \n        # while True:\n        #     kickid = random_string_generator()\n        #     kickid_db = await db.find_one(strikes, {'guildid':ctx.guild_id, 'strikeid':kickid})\n        #     if kickid_db is None:\n        #         break\n        #     else:\n        #         continue\n        # daytime = f'&lt;t:{math.ceil(datetime.now().timestamp())}&gt;'\n        # await db.save(strikes(strikeid=kickid, guildid=ctx.guild_id, user=user.id, moderator=ctx.author.id, action=\"Kick\", day=daytime, reason=reason))\n        await ctx.guild.kick(user, reason)\n        embed = Embed(description=f\"{user} **was kicked** | {reason} \\n**User ID:** {user.id} \\n**Actioned by:** {ctx.author.mention}\",\n                    color=0xffcc50,\n                    timestamp=datetime.utcnow())\n        embed.set_thumbnail(url=user.avatar.url)\n        await ctx.send(embed=embed)\n    else:\n        raise UserNotFound()\n</code></pre>"},{"location":"moderation/#extentions.moderation.Moderation.mute","title":"<code>mute(ctx, user=None, mutetime=None, reason='No reason given')</code>  <code>async</code>","text":"<p>/mute</p> Description <p>Mutes a user for a specified amount of time. Mute time can't be shorter than 10 seconds and longer than 28 days.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>OptionType.USER</code> <p>User that you want to mute</p> <code>None</code> <code>mutetime</code> <code>str</code> <p>Specify the time, Examples: <code>10 S</code>, <code>10 M</code>, <code>10 H</code>, <code>10 D</code></p> <code>None</code> <code>reason</code> <code>str</code> <p>Specify the reason for muting a user</p> <code>'No reason given'</code> Source code in <code>extentions/moderation.py</code> <pre><code>@slash_command(name='mute', description=\"Allows you to mute users\",\n    default_member_permissions=Permissions.MODERATE_MEMBERS\n)\n@user()\n@mutetime()\n@reason()\nasync def mute(self, ctx:InteractionContext, user:OptionType.USER=None, mutetime:str=None, reason:str='No reason given'):\n\"\"\"/mute\n    Description:\n        Mutes a user for a specified amount of time. Mute time can't be shorter than 10 seconds and longer than 28 days.\n\n    Args:\n        user: User that you want to mute\n        mutetime: Specify the time, Examples: `10 S`, `10 M`, `10 H`, `10 D`\n        reason: Specify the reason for muting a user\n    \"\"\"\n    await ctx.defer()\n    if user is ctx.author:\n        await ctx.send(\"You can't mute yourself\", ephemeral=True)\n        return\n    member = find_member(ctx, user.id)\n    if member is not None:\n        if member.has_permission(Permissions.ADMINISTRATOR) == True:\n            await ctx.send(\"You can't mute an admin\", ephemeral=True)\n            return\n        elif member.has_permission(Permissions.BAN_MEMBERS) == True:\n            await ctx.send(\"You can't mute users with ban perms\", ephemeral=True)\n            return\n        elif member.has_permission(Permissions.KICK_MEMBERS) == True:\n            await ctx.send(\"You can't mute users with kick perms\", ephemeral=True)\n            return\n\n        if ctx.author.top_role == member.top_role:\n            embed = Embed(description=f\":x: You can't mute people with the same role as you!\",\n                        color=0xDD2222)\n            await ctx.send(embed=embed)\n            return\n\n        if ctx.author.top_role.position &lt; member.top_role.position:\n            embed = Embed(description=f\":x: You can't mute people with roles higher than yours!\",\n                        color=0xDD2222)\n            await ctx.send(embed=embed)\n            return\n\n        mute_time = [int(i) for i in mutetime.lower().split() if i.isdigit()]\n        if mute_time == []:\n            embed = Embed(description=f\":x: Mute time formatting not correct. Try again. \\n\\n[Examples: `10 S`, `10 M`, `10 H`, `10 D`]\",\n                            color=0xDD2222)\n            await ctx.send(embed=embed)\n        else:\n            for num in mute_time:\n                time = num\n            mute_time_type = [str(type) for type in mutetime.lower().split() if not type.isdigit()]\n            for time_type in mute_time_type:\n                type = time_type\n\n        if type in d:\n            seconds = time * 86400\n            endtime = datetime.now() + timedelta(days=int(time))\n\n        elif type in h:\n            seconds = time * 3600\n            endtime = datetime.now() + timedelta(hours=int(time))\n\n        elif type in m:\n            seconds = time * 60\n            endtime = datetime.now() + timedelta(minutes=int(time))\n\n        elif type in s:\n            seconds = time\n            endtime = datetime.now() + timedelta(seconds=int(time))\n\n        else:\n            embed = Embed(description=f\":x: Time type not supported. You can use: {d}, {h}, {m}, {s}\",\n                        color=0xDD2222)\n            await ctx.send(embed=embed)\n            return\n\n        if (seconds &lt; 10) or (seconds &gt; 2419200):\n            await ctx.send(\"Mute time can't be shorter than 10 seconds and longer than 28 days.\", ephemeral=True)\n        # daytime = f'&lt;t:{math.ceil(datetime.now().timestamp())}&gt;'\n        # \n        # while True:\n        #     muteid = random_string_generator()\n        #     muteid_db = await db.find_one(strikes, {'guildid':ctx.guild_id, 'strikeid':muteid})\n        #     if muteid_db is None:\n        #         break\n        #     else:\n        #         continue\n        # await db.save(strikes(strikeid=muteid, guildid=ctx.guild_id, user=member.id, moderator=ctx.author.id, action=\"Mute\", day=daytime, reason=reason))\n        await member.timeout(endtime, reason)\n        embed = Embed(description=f\"{member} **was muted** | {reason} \\n**User ID:** {member.id} \\n**Actioned by:** {ctx.author.mention}\\n**End time:**&lt;t:{math.ceil(endtime.timestamp())}:R&gt;\",\n                        color=0xffcc50,\n                        timestamp=datetime.utcnow())\n        embed.set_thumbnail(url=member.avatar.url)\n        await ctx.send(embed=embed)\n    else:\n        raise UserNotFound()\n</code></pre>"},{"location":"moderation/#extentions.moderation.Moderation.unmute","title":"<code>unmute(ctx, user=None, reason='No reason given')</code>  <code>async</code>","text":"<p>/unmute</p> Description <p>Unmute a user.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>OptionType.USER</code> <p>User</p> <code>None</code> <code>reason</code> <code>str</code> <p>Set the reason for unmuting a user</p> <code>'No reason given'</code> Source code in <code>extentions/moderation.py</code> <pre><code>@slash_command(name='unmute', description=\"[MOD]allows me to unmute users\",\n    default_member_permissions=Permissions.MODERATE_MEMBERS\n)\n@user()\n@reason()\nasync def unmute(self, ctx:InteractionContext, user:OptionType.USER=None, reason:str='No reason given'):\n\"\"\"/unmute\n    Description:\n        Unmute a user.\n\n\n    Args:\n        user: User\n        reason: Set the reason for unmuting a user\n    \"\"\"\n    await ctx.defer()\n    member = find_member(ctx, user.id)\n    if member is not None:\n        await member.timeout(None, '[UNMUTE] '+reason)\n        embed = Embed(description=f\"{user} **was unmuted** | {reason} \\n**User ID:** {user.id} \\n**Actioned by:** {ctx.author.mention}\",\n                        color=0xffcc50,\n                        timestamp=datetime.utcnow())\n        embed.set_thumbnail(url=user.avatar.url)\n        await ctx.send(embed=embed)\n    else:\n        raise UserNotFound()\n</code></pre>"},{"location":"moderation/#extentions.moderation.Moderation.warnadd","title":"<code>warnadd(ctx, type, user, reason=None)</code>  <code>async</code>","text":"<p>/warn add</p> Description <p>Gives user a warning, depending on type it gives them a warn role, It also sends them a warn DM if available.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>str</code> <p>Specify the type of warning, either major or minor</p> required <code>user</code> <code>OptionType.USER</code> <p>User</p> required <code>reason</code> <code>str</code> <p>Reason for the warning</p> <code>None</code> Source code in <code>extentions/moderation.py</code> <pre><code>@warn.subcommand('add', sub_cmd_description='Add a warn to a member.')\n@slash_option(\n    name=\"type\",\n    description=\"Warn type\",\n    required=True,\n    opt_type=OptionType.STRING,\n    choices=[\n        SlashCommandChoice(name=\"Minor\", value='Minor'),\n        SlashCommandChoice(name=\"Major\", value='Major'),\n    ]\n)\n@user()\n@reason()\nasync def warnadd(self, ctx:InteractionContext, type:str, user:OptionType.USER, reason:str=None):\n\"\"\"/warn add\n    Description:\n        Gives user a warning, depending on type it gives them a warn role, It also sends them a warn DM if available.\n\n    Args:\n        type: Specify the type of warning, either major or minor\n        user: User\n        reason: Reason for the warning\n    \"\"\"\n    await ctx.defer()\n    if user is ctx.author:\n        await ctx.send(\"You can't warn yourself\", ephemeral=True)\n        return\n    elif reason is None:\n        await ctx.send(\"You have to include a reason\", ephemeral=True)\n        return\n    member = ctx.guild.get_member(user.id)\n    if member is not None:\n        while True:\n            warnid = random_string_generator()\n            warnid_db = await db.strikes.find_one({'guildid':ctx.guild_id, 'strikeid':warnid})\n            if warnid_db is None:\n                break\n            else:\n                continue\n\n        if type == 'Major':\n            warnings = db.strikes.find({'guildid':ctx.guild_id, 'user':user.id, 'action':{'$regex':'^warn$', '$options':'i'}, 'type':'Major'})\n            warncount = []\n            async for warn in warnings:\n                warncount.append(warn.strikeid)\n            if warncount == []:\n                warnrolename = 'Warning-1'\n            else:\n                warnrolename = f'Warning-{len(warncount)+1}'\n\n            warn_role = [role for role in ctx.guild.roles if role.name == warnrolename]\n            if warn_role == []:\n                role = await ctx.guild.create_role(name=warnrolename, reason='[automod]|[warn]created new warnrole as warnrole with this number did not exist yet')\n            else:\n                for role in warn_role:\n                    role = role\n\n            await user.add_role(role, reason)\n\n            try:\n                embed = Embed(\n                    title='Major Warning',\n                    description=f\":grey_exclamation: **You've been given a major warning in {ctx.guild.name} for:** {reason}\",\n                    color=0xffcc50)\n                await user.send(embed=embed)\n            except HTTPException:\n                embed = Embed(\n                    title='Major Warning',\n                    description=f\"Couldn't dm {user.mention}, major warn logged and user was given {role.mention} | {reason} \\n**User ID:** {user.id} \\n**Actioned by:** {ctx.author.mention}\",\n                    color=0xffcc50)\n                await ctx.send(embed=embed)\n            else:\n                embed = Embed(\n                    title='Major Warning',\n                    description=f\"{user.mention} warned and given {role.mention} | {reason} \\n**User ID:** {user.id} \\n**Actioned by:** {ctx.author.mention}\",\n                    color=0xffcc50)\n                await ctx.send(embed=embed)\n        elif type == 'Minor':\n            try:\n                embed = Embed(\n                    title='Minor Warning',\n                    description=f\":grey_exclamation: **You've been given a minor warning in {ctx.guild.name} for:** {reason}\",\n                    color=0xffcc50)\n                await user.send(embed=embed)\n            except HTTPException:\n                embed = Embed(\n                    title='Minor Warning',\n                    description=f\"Couldn't dm {user.mention}, minor warn logged | {reason} \\n**User ID:** {user.id} \\n**Actioned by:** {ctx.author.mention}\",\n                    color=0xffcc50\n                )\n                await ctx.send(embed=embed)\n            else:\n                embed = Embed(\n                    title='Minor Warning', \n                    description=f\"{user.mention} warned | {reason} \\n**User ID:** {user.id} \\n**Actioned by:** {ctx.author.mention}\",\n                    color=0xffcc50)\n                await ctx.send(embed=embed)\n\n        daytime = f'&lt;t:{math.ceil(datetime.now().timestamp())}&gt;'\n        await db.strikes(type=type, strikeid=warnid, guildid=ctx.guild_id, user=user.id, moderator=ctx.author.id, action=\"Warn\", day=daytime, reason=reason).insert()\n\n        mw = db.strikes.find({'type':'Minor', 'guildid':ctx.guild_id, 'user':user.id, 'action':{'$regex':'^warn$', '$options':'i'}})\n        mwc = []\n        counter = []\n        i = 1\n        while i &lt; 11:\n            v = 3 * i\n            counter.append(v)\n            i = i + 1\n        async for warn in mw:\n            mwc.append(warn.strikeid)\n        if len(mwc) in counter:\n            await ctx.send(f'**[REMINDER]** {user} now has {len(mwc)} minor warnings.')\n    else:\n        raise UserNotFound()\n</code></pre>"},{"location":"moderation/#extentions.moderation.Moderation.warn_remove","title":"<code>warn_remove(ctx, user=None, warnid=None, reason=None)</code>  <code>async</code>","text":"<p>/warn remove</p> Description <p>Remove a warn from a user.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>OptionType.USER</code> <p>User to remove a warn from</p> <code>None</code> <code>warnid</code> <code>str</code> <p>warnID</p> <code>None</code> <code>reason</code> <code>str</code> <p>Specify the reason for removing the warn</p> <code>None</code> Source code in <code>extentions/moderation.py</code> <pre><code>@warn.subcommand('remove', sub_cmd_description='Remove a warn from a member.')\n@user()\n@warnid()\n@reason()\nasync def warn_remove(self, ctx:InteractionContext, user:OptionType.USER=None, warnid:str=None, reason:str=None):\n\"\"\"/warn remove\n    Description:\n        Remove a warn from a user.\n\n    Args:\n        user: User to remove a warn from\n        warnid: warnID\n        reason: Specify the reason for removing the warn\n    \"\"\"\n    await ctx.defer()\n    if user is ctx.author:\n        await ctx.send(\"You can't remove a warn from yourself\", ephemeral=True)\n        return\n    elif reason is None:\n        await ctx.send(\"You have to include a reason\", ephemeral=True)\n        return\n    member = find_member(ctx, user.id)\n    if member is not None:\n        warning = await db.strikes.find_one({'guildid':ctx.guild_id, 'user':user.id, 'action':{'$regex':'^warn$', '$options':'i'}, 'strikeid':warnid})\n        if warning is None:\n            return await ctx.send(f'Warning not found for {user}', ephemeral=True)\n        warncount = []\n        async for warn in db.strikes.find({'guildid':ctx.guild_id, 'user':user.id, 'action':{'$regex':'^warn$', '$options':'i'}}):\n            warncount.append(warn.strikeid)\n        warnrolename = f'Warning-{len(warncount)}'\n        warn_role = [role for role in ctx.guild.roles if role.name == warnrolename]\n        for role in warn_role:\n            await user.remove_role(role, reason)\n            await warning.delete()\n            embed = Embed(description=f\"warn removed from {user.mention}, {role.mention} was taken away | {reason} \\n**User ID:** {user.id} \\n**Actioned by:** {ctx.author.mention}\",\n                        color=0xffcc50)\n            await ctx.send(embed=embed)\n    else:\n        raise UserNotFound()\n</code></pre>"},{"location":"moderation/#extentions.moderation.Moderation.warnremoveall","title":"<code>warnremoveall(ctx, user)</code>  <code>async</code>","text":"<p>/warn removeall</p> Description <p>Removes all warns from a user.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>OptionType.USER</code> <p>The user that you want to remove all warns from</p> required Source code in <code>extentions/moderation.py</code> <pre><code>@warn.subcommand('removeall', sub_cmd_description='Remove all warns from a member.')\n@user()\nasync def warnremoveall(self, ctx:InteractionContext, user: OptionType.USER):\n\"\"\"/warn removeall\n    Description:\n        Removes all warns from a user.\n\n    Args:\n        user: The user that you want to remove all warns from\n    \"\"\"\n    await ctx.defer()\n    if ctx.author != 400713431423909889:\n        await ctx.send(\"This command cannot be used.\", ephemeral=True)\n        return\n    if user is ctx.author:\n        await ctx.send(\"You can't remove a warn from yourself\", ephemeral=True)\n        return\n    await db.strikes.find({'guildid':ctx.guild_id, 'user':user.id, 'action':'Warn'}).delete_many()\n    await ctx.send(f'All warns removed from {user}')\n</code></pre>"},{"location":"moderation/#extentions.moderation.Moderation.warn_list","title":"<code>warn_list(ctx, user)</code>  <code>async</code>","text":"<p>/warnings</p> Description <p>Display a list of warnings for a user.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>OptionType.USER</code> <p>User</p> required Source code in <code>extentions/moderation.py</code> <pre><code>@slash_command(name='warnings', description=\"shows you a users warn list\",\n    default_member_permissions=Permissions.MODERATE_MEMBERS\n)\n@user()\nasync def warn_list(self, ctx:InteractionContext, user:OptionType.USER):\n\"\"\"/warnings\n    Description:\n        Display a list of warnings for a user.\n\n    Args:\n        user: User\n    \"\"\"\n    await ctx.defer()\n    def chunks(l, n):\n        n = max(1, n)\n        return (l[i:i+n] for i in range(0, len(l), n))\n\n    def mlis(lst, s, e):\n        nc = list(chunks(lst, 20))\n        mc = ''\n        for testlist in nc[s:e]:\n            for m in testlist:\n                mc = mc + m\n        return mc\n\n    def newpage(title, warns):\n        embed = Embed(\n            title=title,\n            description=warns,\n            color=0xffcc50)\n        return embed\n\n    warnings = db.strikes.find({'guildid':ctx.guild_id, 'user':user.id, 'action':'Warn'})\n    warns = []\n    async for warn in warnings:\n        if warn.type is None:\n            warntype = 'Major'\n        else:\n            warntype = warn.type\n        warns.append(f\"**Type:** {warntype} | **Warning ID:** {warn.strikeid} | **Reason:** {warn.reason} | **Moderator:** {warn.moderator} | **Day:** {warn.day}\\n\\n\")\n    if warns == []:\n        embed = Embed(description=f\"There are no warnings for {user}.\",\n                    color=0xffcc50)\n        await ctx.send(embed=embed)\n        return\n\n    s = -1\n    e = 0\n    embedcount = 1\n    nc = list(chunks(warns, 20))\n\n    embeds = []\n    while embedcount &lt;= len(nc):\n        s = s+1\n        e = e+1\n        embeds.append(newpage(f'Warnings for {user}', mlis(warns, s, e)))\n        embedcount = embedcount+1\n\n    paginator = Paginator(\n        client=self.bot, \n        pages=embeds,\n        timeout_interval=80,\n        show_select_menu=False)\n    await paginator.send(ctx)\n</code></pre>"},{"location":"moderation/#extentions.moderation.Moderation.strikes_list","title":"<code>strikes_list(ctx, user=None)</code>  <code>async</code>","text":"<p>/strikes</p> Description <p>List all strikes for a user.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>OptionType.USER</code> <p>Specify that the user parameter is an optional parameter</p> <code>None</code> Source code in <code>extentions/moderation.py</code> <pre><code>@slash_command(name='strikes', description=\"shows you a users strike list\",\n    default_member_permissions=Permissions.MODERATE_MEMBERS\n)\n@user()\nasync def strikes_list(self, ctx:InteractionContext, user:OptionType.USER=None):\n\"\"\"/strikes\n    Description:\n        List all strikes for a user.\n\n    Args:\n        user: Specify that the user parameter is an optional parameter\n    \"\"\"\n    await ctx.defer()\n    def chunks(l, n):\n        n = max(1, n)\n        return (l[i:i+n] for i in range(0, len(l), n))\n\n    def mlis(lst, s, e):\n        nc = list(chunks(lst, 20))\n        mc = ''\n        for testlist in nc[s:e]:\n            for m in testlist:\n                mc = mc + m\n        return mc\n\n    def newpage(title, warns):\n        embed = Embed(\n            title=title,\n            description=warns,\n            color=0xffcc50)\n        return embed\n\n    all_strikes = db.strikes.find({'guildid':ctx.guild_id, 'user':user.id})\n    allstrikes = []\n    async for s in all_strikes:\n        if s.action.lower() != 'warn':\n            allstrikes.append(f\"**Strike ID:** {s.strikeid} | **Action:** {s.action} | **Reason:** {s.reason} | **Moderator:** {s.moderator} | **Day:** {s.day}\\n\\n\")\n        else:\n            if s.type is None:\n                warntype = 'Major'\n            else:\n                warntype = s.type\n            allstrikes.append(f\"**Strike ID:** {s.strikeid} | **Action:** {warntype} {s.action} | **Reason:** {s.reason} | **Moderator:** {s.moderator} | **Day:** {s.day}\\n\\n\")\n\n    if allstrikes == []:\n        embed = Embed(description=f\"There are no strikes for {user}.\",\n                    color=0xffcc50)\n        await ctx.send(embed=embed)\n        return\n\n    s = -1\n    e = 0\n    embedcount = 1\n    nc = list(chunks(allstrikes, 20))\n\n    embeds = []\n    while embedcount &lt;= len(nc):\n        s = s+1\n        e = e+1\n        embeds.append(newpage(f'Strikes for {user}', mlis(allstrikes, s, e)))\n        embedcount = embedcount+1\n\n    paginator = Paginator(\n        client=self.bot, \n        pages=embeds,\n        timeout_interval=80,\n        show_select_menu=False)\n    await paginator.send(ctx)\n</code></pre>"},{"location":"moderation/#extentions.moderation.Moderation.strikesremoveall","title":"<code>strikesremoveall(ctx, user)</code>  <code>async</code>","text":"<p>/removeallstrikes</p> Description <p>Remove all strikes from a user.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>OptionType.USER</code> <p>Specify the user that is being removed from the database</p> required Source code in <code>extentions/moderation.py</code> <pre><code>@slash_command('removeallstrikes', description='Remove all strikes from a member.')\n@member()\nasync def strikesremoveall(self, ctx:InteractionContext, user: OptionType.USER):\n\"\"\"/removeallstrikes\n    Description:\n        Remove all strikes from a user.\n\n    Args:\n        user: Specify the user that is being removed from the database\n    \"\"\"\n\n    await ctx.defer()\n    if ctx.author.id != 400713431423909889:\n        await ctx.send(\"This command cannot be used.\", ephemeral=True)\n        return\n    print(user.id)\n    await db.strikes.find({'guildid':ctx.guild_id, 'user':user.id}).delete_many()\n    await ctx.send(f'All strikes removed from {user}')\n</code></pre>"},{"location":"moderation/#extentions.moderation.Moderation.strike_info","title":"<code>strike_info(ctx, warnid=None)</code>  <code>async</code>","text":"<p>/strike</p> Description <p>Display information about a specific strike.</p> <p>Parameters:</p> Name Type Description Default <code>warnid</code> <code>str</code> <p>WarnID</p> <code>None</code> Source code in <code>extentions/moderation.py</code> <pre><code>@slash_command(name='strike', description=\"look at a strike info\",\n    default_member_permissions=Permissions.MODERATE_MEMBERS,\n)\n@warnid()\nasync def strike_info(self, ctx:InteractionContext, warnid:str=None):\n\"\"\"/strike\n    Description:\n        Display information about a specific strike.\n\n    Args:\n        warnid: WarnID\n    \"\"\"\n    await ctx.defer()\n    s = await db.strikes.find_one({'guildid':ctx.guild_id, 'strikeid':warnid})\n    if s is None:\n        return await ctx.send(f'Strike not found', ephemeral=True)\n    if s.action.lower() != 'warn':\n        info = f\"**Strike ID:** {s.strikeid} | **Action:** {s.action} | **Reason:** {s.reason} | **Moderator:** {s.moderator} | **Day:** {s.day}\"\n    else:\n        if s.type is None:\n            warntype = 'Major'\n        else:\n            warntype = s.type\n        info = f\"**Strike ID:** {s.strikeid} | **Action:** {warntype} {s.action} | **Reason:** {s.reason} | **Moderator:** {s.moderator} | **Day:** {s.day}\"\n    embed = Embed(\n        description=info,\n        color=0xffcc50)\n    await ctx.send(embed=embed)\n</code></pre>"},{"location":"moderation/#extentions.moderation.Moderation.strike_reason","title":"<code>strike_reason(ctx, warnid=None, reason=None)</code>  <code>async</code>","text":"<p>/reason</p> Description <p>Allows a user to change the reason of a strike. This is useful if the original reason was not clear enough or if it was changed by mistake. The function takes in two arguments: ctx and warnid, with an optional third argument being reason. If no reason is provided, then the user will be prompted to provide one.</p> <p>Parameters:</p> Name Type Description Default <code>warnid</code> <code>str</code> <p>warnID</p> <code>None</code> <code>reason</code> <code>str</code> <p>Set the reason for the strike</p> <code>None</code> Source code in <code>extentions/moderation.py</code> <pre><code>@slash_command(name='reason', description=\"allows me to modify reasons of strikes\",\n    default_member_permissions=Permissions.MODERATE_MEMBERS,\n)\n@warnid()\n@reason()\nasync def strike_reason(self, ctx:InteractionContext, warnid:str=None, reason:str=None):\n\"\"\"/reason\n    Description:\n        Allows a user to change the reason of a strike.\n        This is useful if the original reason was not clear enough or if it was changed by mistake.\n        The function takes in two arguments: ctx and warnid, with an optional third argument being reason.\n        If no reason is provided, then the user will be prompted to provide one.\n\n    Args:\n        warnid: warnID\n        reason: Set the reason for the strike\n    \"\"\"\n    await ctx.defer()\n    if reason is None:\n        await ctx.send(\"You have to include a reason\", ephemeral=True)\n        return\n    strike = await db.strikes.find_one({'guildid':ctx.guild_id, 'strikeid':warnid})\n    if strike is None:\n        return await ctx.send(f'Strike not found', ephemeral=True)\n    if strike.user == ctx.author.id:\n        await ctx.send(\"You can't change a reason on a strike directed at you\", ephemeral=True)\n        return\n    embed = Embed(\n        description=f\"Strike reason changed from `{strike.reason}` to `{reason}`\\n**Strike ID:** {strike.strikeid}\\n**Action:** {strike.action}\\n**User ID:** {strike.user} \\n**Actioned by:** {ctx.author.mention}\",\n        color=0xffcc50)\n    await ctx.send(embed=embed)\n    strike.reason = reason\n    await strike.save()\n</code></pre>"},{"location":"persistentroles/","title":"Persistentroles","text":"<p>         Bases: <code>Extension</code></p> Source code in <code>extentions/persistentroles.py</code> <pre><code>class PersistentRoles(Extension):\n    def __init__(self, bot: Client):\n        self.bot = bot\n\n    persistent_roles = SlashCommand(name='persistentroles',  description='Manage persistent roles', default_member_permissions=Permissions.ADMINISTRATOR)\n\n    @persistent_roles.subcommand(sub_cmd_name='add', sub_cmd_description=\"Make a role persistent\")\n    @role()\n    async def persistent_roles_add(self, ctx, role:OptionType.ROLE=None):\n\"\"\"/persistentroles add\n        Description:\n            Add a role to the persistent roles list. This means that when a user leaves and rejoins, they will be given this role again.\n\n        Args:\n            role: Role\n        \"\"\"\n        # if role is None:\n        #     return await ctx.send(embed=Embed(color=0xDD2222, description=\":x: Please provide a role\"), ephemeral=True)\n        if role == ctx.guild.my_role:\n            return await ctx.send(embed=Embed(color=0xDD2222, description=\":x: This is my role, you cannot manage this role\"), ephemeral=True)\n        elif role == ctx.guild.default_role:\n            return await ctx.send(embed=Embed(color=0xDD2222, description=\":x: This is a default role, you cannot manage this role\"), ephemeral=True)\n\n        ranks = await db.leveling_roles.find_one({'guildid':ctx.guild_id, 'roleid':role.id})\n        if ranks is not None:\n            return await ctx.send(embed=Embed(color=0xDD2222, description=f\":x: {role.mention} is a rank, which makes it already a persistant role.\"), ephemeral=True)\n        pers_roles = await db.persistent_roles_settings.find_one({'guildid':ctx.guild_id, 'roleid':role.id})\n        if pers_roles is not None:\n            return await ctx.send(embed=Embed(color=0xDD2222, description=f\":x: {role.mention} is already a persistent role.\"), ephemeral=True)\n        await db.persistent_roles_settings(guildid=ctx.guild_id, roleid=role.id).insert()\n        if ctx.author.guild_avatar is not None:\n            avatarurl = f'{ctx.author.guild_avatar.url}.png'\n        else:\n            avatarurl = f'{ctx.author.avatar.url}.png'\n        embed = Embed(description=f\"I have made {role.mention} a persistent role.\",\n                                  color=0xffcc50)\n        embed.set_footer(text=f'{ctx.author}|{ctx.author.id}',icon_url=avatarurl)\n        await ctx.send(embed=embed)\n\n    @persistent_roles.subcommand(sub_cmd_name='remove', sub_cmd_description=\"Remove role from persistent roles\")\n    @role()\n    async def persistent_roles_remove(self, ctx, role:OptionType.ROLE=None):\n\"\"\"/persistentroles remove\n        Description:\n            Removes a role from the persistent roles list.\n\n        Args:\n            role: Get the role object from the user's input\n        \"\"\"\n        if role is None:\n            return await ctx.send(embed=Embed(color=0xDD2222, description=\":x: Please provide a role\"), ephemeral=True)\n        elif role == ctx.guild.my_role:\n            return await ctx.send(embed=Embed(color=0xDD2222, description=\":x: This is my role, you cannot manage this role\"), ephemeral=True)\n        elif role == ctx.guild.default_role:\n            return await ctx.send(embed=Embed(color=0xDD2222, description=\":x: This is a default role, you cannot manage this role\"), ephemeral=True)\n\n        ranks = await db.leveling_roles.find_one({'guildid':ctx.guild_id, 'roleid':role.id})\n        if ranks.roleid == role.id:\n            return await ctx.send(embed=Embed(color=0xDD2222, description=f\":x: {role.mention} is a rank, which makes it a persistant role that you can't remove from persistent roles.\"), ephemeral=True)\n        pers_roles = await db.persistent_roles_settings.find_one({'guildid':ctx.guild_id, 'roleid':role.id})\n        if pers_roles.roleid != role.id:\n            return await ctx.send(embed=Embed(color=0xDD2222, description=f\":x: {role.mention} is not a persistent role.\"), ephemeral=True)\n        await pers_roles.delete()\n        if ctx.author.guild_avatar is not None:\n            avatarurl = f'{ctx.author.guild_avatar.url}.png'\n        else:\n            avatarurl = f'{ctx.author.avatar.url}.png'\n        embed = Embed(description=f\"I have removed {role.mention} from persistent roles.\",\n                                  color=0xffcc50)\n        embed.set_footer(text=f'{ctx.author}|{ctx.author.id}',icon_url=avatarurl)\n        await ctx.send(embed=embed)\n\n    @persistent_roles.subcommand(sub_cmd_name='list', sub_cmd_description=\"List all the persistent roles\")\n    async def persistent_roles_list(self, ctx):\n\"\"\"/persistentroles list\n        Description:\n            Display a list of all persistent roles for the guild.\n        \"\"\"\n        from interactions.ext.paginators import Paginator\n        def chunks(l, n):\n            n = max(1, n)\n            return (l[i:i+n] for i in range(0, len(l), n))\n\n        def mlis(lst, s, e):\n            nc = list(chunks(lst, 20))\n            mc = ''\n            for l in nc[s:e]:\n                for m in l:\n                    mc = mc + m\n            return mc\n\n        def newpage(title, roles):\n            embed = Embed(title=title,\n            color=0xffcc50)\n            embed.add_field(name='Roles', value=roles, inline=True)\n            return embed\n\n\n        leveling_roles = db.leveling_roles.find({\"guildid\":ctx.guild.id})\n        level_roles = []\n        async for lvl in leveling_roles:\n            level_roles.append(lvl.roleid)\n        pr = db.persistent_roles_settings.find({'guildid':ctx.guild.id})\n        pers_roles = []\n        async for r in pr:\n            pers_roles.append(r.roleid)\n\n        all_persistent_roles = level_roles+pers_roles\n        if all_persistent_roles == []:\n            embed = Embed(description=f\"There are no persistent roles for {ctx.guild.name}.\",\n                        color=0xffcc50)\n            await ctx.send(embed=embed)\n            return\n        roles = []\n        for r in all_persistent_roles:\n            role = ctx.guild.get_role(r)\n            if role is None:\n                roles.append(f'{r}[ROLE NOT FOUND]\\n')\n            else:\n                roles.append(f\"{role.mention}\\n\")\n\n        s = -1\n        e = 0\n        embedcount = 1\n        nc = list(chunks(roles, 20))\n\n        embeds = []\n        while embedcount &lt;= len(nc):\n            s = s+1\n            e = e+1\n            embeds.append(newpage(f'List of persistent roles for {ctx.guild.name}', mlis(roles, s, e)))\n            embedcount = embedcount+1\n\n        paginator = Paginator(\n            client=self.bot, \n            pages=embeds,\n            timeout_interval=80,\n            show_select_menu=False)\n        await paginator.send(ctx)\n\n    @listen()\n    async def on_member_remove(self, event):\n        guild= event.member.guild\n        member = event.member\n        member_roles = [role.id for role in member.roles if role.name != '@everyone']\n        if member_roles == []:\n            return\n\n        p_r = await db.persistent_roles.find_one({'guildid':guild.id, 'user':member.id})\n        if p_r is not None:\n            await p_r.delete()\n        leveling_roles = db.leveling_roles.find({\"guildid\":guild.id})\n        level_roles = []\n        async for lvl in leveling_roles:\n            level_roles.append(lvl.roleid)\n\n        persistent_roles = db.persistent_roles_settings.find({'guildid':guild.id})\n        pers_roles = []\n        async for r in persistent_roles:\n            pers_roles.append(r.roleid)\n\n        all_persistent_roles = level_roles+pers_roles\n        member_roles = [str(role.id) for role in member.roles if role.id in all_persistent_roles]\n        if member_roles == []:\n            return\n        roles = ','.join(member_roles)\n        await db.persistent_roles(guildid=guild.id, user=member.id, roles=roles).insert()\n\n    @listen()\n    async def on_member_add(self, event):\n        guild = event.member.guild\n        member = event.member\n\n        warnings = db.strikes.find({'guildid':guild.id, 'user':member.id, 'action':{'$regex':'^warn$', '$options':'i'}})\n        warncount = []\n        async for warn in warnings:\n            if warn.type != 'Minor':\n                warncount.append(warn.strikeid)\n        if warncount != []:\n            wrc = 0\n            while wrc != len(warncount):\n                warnrolename = f'Warning-{wrc+1}'\n                wrc = wrc+1\n                warn_role = [role for role in guild.roles if role.name == warnrolename]\n                if warn_role == []:\n                    role = await guild.create_role(name=warnrolename, reason='[automod]|[warn]created new warnrole as warnrole with this number did not exist yet')\n                    await member.add_role(role, '[automod] Given back warnrole on server rejoin')\n                else:\n                    for role in warn_role:\n                        await member.add_role(role, '[automod] Given back warnrole on server rejoin')\n\n        p_r = await db.persistent_roles.find_one({'guildid':guild.id, 'user':member.id})\n        if p_r is not None:\n            roles = [guild.get_role(int(id_)) for id_ in p_r.roles.split(\",\") if len(id_)]\n            for role in roles:\n                if role not in member.roles:\n                    await member.add_role(role, '[pt]persistent_role stored in db was added back to member on rejoin')\n        else:\n            p_r = await db.persistentroles.find_one({'guildid':guild.id, 'userid':member.id})\n            if p_r is not None:\n                roles = [guild.get_role(int(id_)) for id_ in p_r.roles.split(\",\") if len(id_)]\n                leveling_roles = db.leveling_roles.find({\"guildid\":guild.id})\n                level_roles = []\n                async for lvl in leveling_roles:\n                    level_roles.append(lvl.roleid)\n\n                persistent_roles = db.persistent_roles_settings.find({'guildid':guild.id})\n                pers_roles = []\n                async for r in persistent_roles:\n                    pers_roles.append(r.roleid)\n\n                all_persistent_roles = level_roles+pers_roles\n                member_roles = [role.id for role in roles if role.id in all_persistent_roles]\n                for role in member_roles:\n                    if role not in member.roles:\n                        await member.add_role(role, '[pt]persistent_role stored in db was added back to member on rejoin')\n            else:\n                mem_lvl = await db.leveling.find_one({'guildid':guild.id, 'memberid':member.id})\n                if mem_lvl is not None:\n                    level_roles = db.leveling_roles.find({\"guildid\":guild.id, 'level':{'$lte':mem_lvl.level}})\n                    roles = []\n                    async for role in level_roles:\n                        roles.append(role.roleid)\n                    if level_roles != []:\n                        for role_id in roles:\n                            role = guild.get_role(role_id)\n                            if role not in member.roles:\n                                await member.add_role(role)\n</code></pre>"},{"location":"persistentroles/#extentions.persistentroles.PersistentRoles.persistent_roles_add","title":"<code>persistent_roles_add(ctx, role=None)</code>  <code>async</code>","text":"<p>/persistentroles add</p> Description <p>Add a role to the persistent roles list. This means that when a user leaves and rejoins, they will be given this role again.</p> <p>Parameters:</p> Name Type Description Default <code>role</code> <code>OptionType.ROLE</code> <p>Role</p> <code>None</code> Source code in <code>extentions/persistentroles.py</code> <pre><code>@persistent_roles.subcommand(sub_cmd_name='add', sub_cmd_description=\"Make a role persistent\")\n@role()\nasync def persistent_roles_add(self, ctx, role:OptionType.ROLE=None):\n\"\"\"/persistentroles add\n    Description:\n        Add a role to the persistent roles list. This means that when a user leaves and rejoins, they will be given this role again.\n\n    Args:\n        role: Role\n    \"\"\"\n    # if role is None:\n    #     return await ctx.send(embed=Embed(color=0xDD2222, description=\":x: Please provide a role\"), ephemeral=True)\n    if role == ctx.guild.my_role:\n        return await ctx.send(embed=Embed(color=0xDD2222, description=\":x: This is my role, you cannot manage this role\"), ephemeral=True)\n    elif role == ctx.guild.default_role:\n        return await ctx.send(embed=Embed(color=0xDD2222, description=\":x: This is a default role, you cannot manage this role\"), ephemeral=True)\n\n    ranks = await db.leveling_roles.find_one({'guildid':ctx.guild_id, 'roleid':role.id})\n    if ranks is not None:\n        return await ctx.send(embed=Embed(color=0xDD2222, description=f\":x: {role.mention} is a rank, which makes it already a persistant role.\"), ephemeral=True)\n    pers_roles = await db.persistent_roles_settings.find_one({'guildid':ctx.guild_id, 'roleid':role.id})\n    if pers_roles is not None:\n        return await ctx.send(embed=Embed(color=0xDD2222, description=f\":x: {role.mention} is already a persistent role.\"), ephemeral=True)\n    await db.persistent_roles_settings(guildid=ctx.guild_id, roleid=role.id).insert()\n    if ctx.author.guild_avatar is not None:\n        avatarurl = f'{ctx.author.guild_avatar.url}.png'\n    else:\n        avatarurl = f'{ctx.author.avatar.url}.png'\n    embed = Embed(description=f\"I have made {role.mention} a persistent role.\",\n                              color=0xffcc50)\n    embed.set_footer(text=f'{ctx.author}|{ctx.author.id}',icon_url=avatarurl)\n    await ctx.send(embed=embed)\n</code></pre>"},{"location":"persistentroles/#extentions.persistentroles.PersistentRoles.persistent_roles_remove","title":"<code>persistent_roles_remove(ctx, role=None)</code>  <code>async</code>","text":"<p>/persistentroles remove</p> Description <p>Removes a role from the persistent roles list.</p> <p>Parameters:</p> Name Type Description Default <code>role</code> <code>OptionType.ROLE</code> <p>Get the role object from the user's input</p> <code>None</code> Source code in <code>extentions/persistentroles.py</code> <pre><code>@persistent_roles.subcommand(sub_cmd_name='remove', sub_cmd_description=\"Remove role from persistent roles\")\n@role()\nasync def persistent_roles_remove(self, ctx, role:OptionType.ROLE=None):\n\"\"\"/persistentroles remove\n    Description:\n        Removes a role from the persistent roles list.\n\n    Args:\n        role: Get the role object from the user's input\n    \"\"\"\n    if role is None:\n        return await ctx.send(embed=Embed(color=0xDD2222, description=\":x: Please provide a role\"), ephemeral=True)\n    elif role == ctx.guild.my_role:\n        return await ctx.send(embed=Embed(color=0xDD2222, description=\":x: This is my role, you cannot manage this role\"), ephemeral=True)\n    elif role == ctx.guild.default_role:\n        return await ctx.send(embed=Embed(color=0xDD2222, description=\":x: This is a default role, you cannot manage this role\"), ephemeral=True)\n\n    ranks = await db.leveling_roles.find_one({'guildid':ctx.guild_id, 'roleid':role.id})\n    if ranks.roleid == role.id:\n        return await ctx.send(embed=Embed(color=0xDD2222, description=f\":x: {role.mention} is a rank, which makes it a persistant role that you can't remove from persistent roles.\"), ephemeral=True)\n    pers_roles = await db.persistent_roles_settings.find_one({'guildid':ctx.guild_id, 'roleid':role.id})\n    if pers_roles.roleid != role.id:\n        return await ctx.send(embed=Embed(color=0xDD2222, description=f\":x: {role.mention} is not a persistent role.\"), ephemeral=True)\n    await pers_roles.delete()\n    if ctx.author.guild_avatar is not None:\n        avatarurl = f'{ctx.author.guild_avatar.url}.png'\n    else:\n        avatarurl = f'{ctx.author.avatar.url}.png'\n    embed = Embed(description=f\"I have removed {role.mention} from persistent roles.\",\n                              color=0xffcc50)\n    embed.set_footer(text=f'{ctx.author}|{ctx.author.id}',icon_url=avatarurl)\n    await ctx.send(embed=embed)\n</code></pre>"},{"location":"persistentroles/#extentions.persistentroles.PersistentRoles.persistent_roles_list","title":"<code>persistent_roles_list(ctx)</code>  <code>async</code>","text":"<p>/persistentroles list</p> Description <p>Display a list of all persistent roles for the guild.</p> Source code in <code>extentions/persistentroles.py</code> <pre><code>@persistent_roles.subcommand(sub_cmd_name='list', sub_cmd_description=\"List all the persistent roles\")\nasync def persistent_roles_list(self, ctx):\n\"\"\"/persistentroles list\n    Description:\n        Display a list of all persistent roles for the guild.\n    \"\"\"\n    from interactions.ext.paginators import Paginator\n    def chunks(l, n):\n        n = max(1, n)\n        return (l[i:i+n] for i in range(0, len(l), n))\n\n    def mlis(lst, s, e):\n        nc = list(chunks(lst, 20))\n        mc = ''\n        for l in nc[s:e]:\n            for m in l:\n                mc = mc + m\n        return mc\n\n    def newpage(title, roles):\n        embed = Embed(title=title,\n        color=0xffcc50)\n        embed.add_field(name='Roles', value=roles, inline=True)\n        return embed\n\n\n    leveling_roles = db.leveling_roles.find({\"guildid\":ctx.guild.id})\n    level_roles = []\n    async for lvl in leveling_roles:\n        level_roles.append(lvl.roleid)\n    pr = db.persistent_roles_settings.find({'guildid':ctx.guild.id})\n    pers_roles = []\n    async for r in pr:\n        pers_roles.append(r.roleid)\n\n    all_persistent_roles = level_roles+pers_roles\n    if all_persistent_roles == []:\n        embed = Embed(description=f\"There are no persistent roles for {ctx.guild.name}.\",\n                    color=0xffcc50)\n        await ctx.send(embed=embed)\n        return\n    roles = []\n    for r in all_persistent_roles:\n        role = ctx.guild.get_role(r)\n        if role is None:\n            roles.append(f'{r}[ROLE NOT FOUND]\\n')\n        else:\n            roles.append(f\"{role.mention}\\n\")\n\n    s = -1\n    e = 0\n    embedcount = 1\n    nc = list(chunks(roles, 20))\n\n    embeds = []\n    while embedcount &lt;= len(nc):\n        s = s+1\n        e = e+1\n        embeds.append(newpage(f'List of persistent roles for {ctx.guild.name}', mlis(roles, s, e)))\n        embedcount = embedcount+1\n\n    paginator = Paginator(\n        client=self.bot, \n        pages=embeds,\n        timeout_interval=80,\n        show_select_menu=False)\n    await paginator.send(ctx)\n</code></pre>"},{"location":"sp2yt/","title":"Sp2yt","text":"<p>         Bases: <code>Extension</code></p> Source code in <code>extentions/sp2yt.py</code> <pre><code>class SpotifyToYoutube(Extension):\n    def __init__(self, bot: Client):\n        self.bot = bot\n\n    @listen() \n    async def spotify_link_listen(self, event: MessageCreate):\n        user = event.message.author # get the user who sent the message\n        message = event.message.content # get the content of the message\n        if user.bot: # if the user is a bot, return\n            return\n        if message is None: # if the message is empty, return\n            return\n        settings = await db.sp2yt.find_one({'guildid':event.message.guild.id}) # get the settings for the guild from the database\n        if settings is None: # if there are no settings for the guild, insert default settings\n            return await db.sp2yt(guildid=event.message.guild.id).insert()\n        if not user.has_permission(Permissions.ADMINISTRATOR): # if the user is not an administrator\n            if settings.ignored_users is not None: # if there are ignored users in the settings\n                if user.id in settings.ignored_users: # if the user is in the ignored users list, return\n                    return\n            if settings.ignored_roles is not None: # if there are ignored roles in the settings\n                if any(role for role in user.roles if role.id in settings.ignored_roles): # if the user has an ignored role, return\n                    return\n        if settings.music_channels is not None: # if there are music channels in the settings\n            if event.message.channel.id not in settings.music_channels: # if the message is not in a music channel, return\n                return\n        spotify_url = get_spotify_url(message) # get the Spotify URL from the message\n        if spotify_url is not None: # if there is a Spotify URL in the message\n            if \"track\" in spotify_url: # if the URL is for a track\n                song = spotify.track(spotify_url) # get the track information from the Spotify API\n                query_type = 'songs'\n            if \"album\" in spotify_url: # if the URL is for an album\n                song = spotify.album(spotify_url) # get the album information from the Spotify API\n                query_type = 'albums'\n            youtube_search = ytmusic.search(f\"{song['artists'][0]['name']} {song['name']}\", query_type) # search for the song on YouTube Music\n            if query_type == 'songs': # if the search is for a song\n                url = f\"https://music.youtube.com/watch?v={youtube_search[0]['videoId']}\" # get the URL for the song on YouTube Music\n            elif query_type == 'albums': # if the search is for an album\n                albumsearch = ytmusic.get_album(youtube_search[0]['browseId']) # get the album information from YouTube Music\n                url = f\"https://music.youtube.com/playlist?list={albumsearch['audioPlaylistId']}\" # get the URL for the album on YouTube Music\n            await event.message.reply(url, allowed_mentions=AllowedMentions(replied_user=False)) # reply to the message with the YouTube Music URL\n\n    @slash_command(name='sp2yt', description='Translate Spotify links to YouTube Music links')\n    @slash_option(name='url', description='Spotify URL to translate', opt_type=OptionType.STRING, required=True)\n    async def sp2yt(self, ctx:SlashContext, url: str):\n\"\"\"/sp2yt\n        Description:\n            The sp2yt function takes a Spotify URL and converts it to a YouTube Music URL.\n            It does this by first checking if the url is valid, then checks if it's either an album or song.\n            If it's an album, we search for the album on YTMusic and get its playlist ID. We then send that playlist ID as a link to the user in chat.\n            If it's not an album but instead is a song, we search for that song on YTMusic and get its videoId (the unique identifier of each video). We then send that videoId as a link to the user in chat\n\n        Args:\n            url: The spotify URL\n        \"\"\"\n        settings = await db.sp2yt.find_one({'guildid':ctx.guild.id})\n        if settings is None:\n            return await db.sp2yt(guildid=ctx.guild.id).insert()\n        spotify_url = get_spotify_url(url)\n        if spotify_url is not None:\n            if \"track\" in spotify_url:\n                song = spotify.track(spotify_url)\n                query_type = 'songs'\n            if \"album\" in spotify_url:\n                song = spotify.album(spotify_url)\n                query_type = 'albums'\n            # print(song[\"artists\"][0][\"name\"], song['name'])\n            youtube_search = ytmusic.search(f\"{song['artists'][0]['name']} {song['name']}\", query_type)\n            # print(youtube_search[0])\n            if query_type == 'songs':\n                url = f\"https://music.youtube.com/watch?v={youtube_search[0]['videoId']}\"\n            elif query_type == 'albums':\n                albumsearch = ytmusic.get_album(youtube_search[0]['browseId'])\n                url = f\"https://music.youtube.com/playlist?list={albumsearch['audioPlaylistId']}\"\n            await ctx.send(url)\n        else:\n            await ctx.send(\"This is either not a Spotify URL or this Spotify URL is not supported. I only support Spotify Track and Album URLs.\")\n\n    sp2yt_manage = SlashCommand(name='sp2yt_manage', default_member_permissions=Permissions.ADMINISTRATOR, description='Manage the Spotify to YouTube settings.')\n\n    @sp2yt_manage.subcommand('music_channel', 'add', 'Add a channel to music channels.')\n    @channel()\n    async def add_music_channel(self, ctx:InteractionContext, channel: OptionType.CHANNEL=None):\n\"\"\"/sp2yt_manage music_channel add\n        Description:\n            Add a channel to the list of music channels. The bot will listen to spotify links in these channels.\n\n        Args:\n            channel (OptionType.CHANNEL): Specify the channel you want to add to the music channels list\n        \"\"\"\n        await ctx.defer(ephemeral=True)\n        if channel is None:\n            channel = ctx.channel\n        settings = await db.sp2yt.find_one({\"guildid\":ctx.guild.id})\n        if settings is None:\n            await db.sp2yt(guildid=ctx.guild.id).insert()\n            settings = await db.sp2yt.find_one({\"guildid\":ctx.guild.id})\n        music_channels = settings.music_channels\n        if music_channels is None:\n            music_channels = list()\n        if channel.id in music_channels:\n            await ctx.send(f'{channel.mention} is already a music channel..', ephemeral=True)\n        music_channels.append(channel.id)\n        await settings.save()\n        channel_mentions = [ctx.guild.get_channel(id) for id in music_channels]\n        channel_mentions = [ch.mention for ch in channel_mentions if ch is not None]\n        channel_mentions = ' '.join(channel_mentions)\n        embed = Embed(description=f\"Channel {channel.mention} set as a music channel.\")\n        embed.add_field('Music Channels', channel_mentions)\n        await ctx.send(embed=embed, ephemeral=True)\n\n    @sp2yt_manage.subcommand('music_channel', 'remove', 'Remove a channel from music channels.')\n    @channel()\n    async def remove_music_channel(self, ctx:InteractionContext, channel: OptionType.CHANNEL=None):\n\"\"\"/sp2yt_manage music_channel remove\n        description:\n            Remove a channel from the list of music channels.\n            If no channel is specified, it will remove the current channel.\n\n        Args:\n            channel (OptionType.CHANNEL): Specify the channel that is being removed from the music channels list\n        \"\"\"\n        await ctx.defer(ephemeral=True)\n        if channel is None:\n            channel = ctx.channel\n        settings = await db.sp2yt.find_one({\"guildid\":ctx.guild.id})\n        if settings is None:\n            await db.sp2yt(guildid=ctx.guild.id).insert()\n        music_channels = settings.music_channels\n        if music_channels is None:\n            music_channels = list()\n        if channel.id not in music_channels:\n            await ctx.send(f'{channel.mention} is not a music channel.', ephemeral=True)\n        music_channels.remove(channel.id)\n        await settings.save()\n        channel_mentions = [ctx.guild.get_channel(id) for id in music_channels]\n        channel_mentions = [ch.mention for ch in channel_mentions if ch is not None]\n        channel_mentions = ' '.join(channel_mentions)\n        embed = Embed(description=f\"Channel {channel.mention} removed from being a music channel.\")\n        embed.add_field('Music Channels', channel_mentions)\n        await ctx.send(embed=embed, ephemeral=True)\n\n    @sp2yt_manage.subcommand('ignored_role', 'add', 'Make a role to be ignored in music channels.')\n    @role()\n    async def MusicAddIgnoredRoles(self, ctx:InteractionContext, role: OptionType.ROLE):\n\"\"\"/sp2yt_manage ignored_role add\n        Description:\n            Add a role to the list of roles ignored in music channels.\n\n        Args:\n            role (OptionType.ROLE): Get the role that is being ignored\n        \"\"\"\n        await ctx.defer(ephemeral=True)\n        settings = await db.sp2yt.find_one({\"guildid\":ctx.guild.id})\n        if settings is None:\n            await db.sp2yt(guildid=ctx.guild.id).insert()\n        ignored_roles = settings.ignored_roles\n        if ignored_roles is None:\n            ignored_roles = list()\n        if role.id in ignored_roles:\n            await ctx.send(f'{role.mention} is already ignored in music channels.', ephemeral=True)\n        ignored_roles.append(role.id)\n        await settings.save()\n        role_mentions = [ctx.guild.get_role(id) for id in ignored_roles]\n        role_mentions = [r.mention for r in role_mentions if r is not None]\n        role_mentions = ' '.join(role_mentions)\n        embed = Embed(description=f\"Role {role.mention} was added to roles ignored in music channels.\")\n        embed.add_field('Ignored Roles', role_mentions)\n        await ctx.send(embed=embed, ephemeral=True)\n\n    @sp2yt_manage.subcommand('ignored_role', 'remove', 'Remove a role from being ignored in music channels.')\n    @role()\n    async def MusicRemoveIgnoredRoles(self, ctx:InteractionContext, role: OptionType.ROLE):\n\"\"\"/sp2yt_manage ignored_role remove\n        Remove a role from the list of roles that are ignored in music channels.\n\n        Args:\n            role (OptionType.ROLE): Role that is gonna be ignored\n        \"\"\"\n        await ctx.defer(ephemeral=True)\n        settings = await db.sp2yt.find_one({\"guildid\":ctx.guild.id})\n        if settings is None:\n            await db.sp2yt(guildid=ctx.guild.id).insert()\n        ignored_roles = settings.ignored_roles\n        if ignored_roles is None:\n            ignored_roles = list()\n        if role.id not in ignored_roles:\n            await ctx.send(f'{role.mention} is not being ignored in music channels.', ephemeral=True)\n        ignored_roles.remove(role.id)\n        await settings.save()\n        role_mentions = [ctx.guild.get_role(id) for id in ignored_roles]\n        role_mentions = [r.mention for r in role_mentions if r is not None]\n        role_mentions = ' '.join(role_mentions)\n        embed = Embed(description=f\"Role {role.mention} was removed from being ignored in music channels.\")\n        embed.add_field('Ignored Roles', role_mentions)\n        await ctx.send(embed=embed, ephemeral=True)\n\n    @sp2yt_manage.subcommand('ignored_member', 'add', 'Make a member to be ignored in music channels.')\n    @user()\n    async def MusicAddIgnoredMember(self, ctx:InteractionContext, user: OptionType.USER):\n\"\"\"/sp2yt_manage ignored_member add\n        Description:\n            Add a user to the list of ignored users in music channels.\n            This means that they will not be able to use any commands in music channels.\n\n        Args:\n            user (OptionType.USER): User to add to the ignored list\n        \"\"\"\n        await ctx.defer(ephemeral=True)\n        settings = await db.sp2yt.find_one({\"guildid\":ctx.guild.id})\n        if settings is None:\n            await db.sp2yt(guildid=ctx.guild.id).insert()\n        ignored_users = settings.ignored_users\n        if ignored_users is None:\n            ignored_users = list()\n        if user.id in ignored_users:\n            await ctx.send(f'{user}|{user.id} is already ignored in music channels.', ephemeral=True)\n        ignored_users.append(user.id)\n        await settings.save()\n        users = [ctx.guild.get_member(id) for id in ignored_users]\n        users = [f'{r}({r.id})' for r in users if r is not None]\n        users = ' '.join(users)\n        embed = Embed(description=f\"Member {user}({user.id}) was added to members ignored in music channels.\")\n        embed.add_field('Ignored Members', users)\n        await ctx.send(embed=embed, ephemeral=True)\n\n\n    @sp2yt_manage.subcommand('ignored_member', 'remove', 'Remove a member from being ignored in music channels.')\n    @user()\n    async def MusicRemoveIgnoredMember(self, ctx:InteractionContext, user: OptionType.USER):\n\"\"\"/sp2yt_manage ignored_member remove\n        Description:\n            Remove a user from the ignored list for music channels.\n\n\n        Args:\n            user (OptionType.USER): Specify the user to be removed from the ignored list\n        \"\"\"\n        await ctx.defer(ephemeral=True)\n        settings = await db.sp2yt.find_one({\"guildid\":ctx.guild.id})\n        if settings is None:\n           await db.sp2yt(guildid=ctx.guild.id).insert()\n        ignored_users = settings.ignored_users\n        if ignored_users is None:\n            ignored_users = list()\n        if user.id not in ignored_users:\n            await ctx.send(f'{user}|{user.id} is not being ignored in music channels.', ephemeral=True)\n        ignored_users.remove(user.id)\n        await settings.save()\n        users = [ctx.guild.get_member(id) for id in ignored_users]\n        users = [f'{r}({r.id})' for r in users if r is not None]\n        users = ' '.join(users)\n        embed = Embed(description=f\"Member {user}({user.id}) was removed from being ignored in music channels.\")\n        embed.add_field('Ignored Members', users)\n        await ctx.send(embed=embed, ephemeral=True)\n</code></pre>"},{"location":"sp2yt/#extentions.sp2yt.SpotifyToYoutube.sp2yt","title":"<code>sp2yt(ctx, url)</code>  <code>async</code>","text":"<p>/sp2yt</p> Description <p>The sp2yt function takes a Spotify URL and converts it to a YouTube Music URL. It does this by first checking if the url is valid, then checks if it's either an album or song. If it's an album, we search for the album on YTMusic and get its playlist ID. We then send that playlist ID as a link to the user in chat. If it's not an album but instead is a song, we search for that song on YTMusic and get its videoId (the unique identifier of each video). We then send that videoId as a link to the user in chat</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The spotify URL</p> required Source code in <code>extentions/sp2yt.py</code> <pre><code>@slash_command(name='sp2yt', description='Translate Spotify links to YouTube Music links')\n@slash_option(name='url', description='Spotify URL to translate', opt_type=OptionType.STRING, required=True)\nasync def sp2yt(self, ctx:SlashContext, url: str):\n\"\"\"/sp2yt\n    Description:\n        The sp2yt function takes a Spotify URL and converts it to a YouTube Music URL.\n        It does this by first checking if the url is valid, then checks if it's either an album or song.\n        If it's an album, we search for the album on YTMusic and get its playlist ID. We then send that playlist ID as a link to the user in chat.\n        If it's not an album but instead is a song, we search for that song on YTMusic and get its videoId (the unique identifier of each video). We then send that videoId as a link to the user in chat\n\n    Args:\n        url: The spotify URL\n    \"\"\"\n    settings = await db.sp2yt.find_one({'guildid':ctx.guild.id})\n    if settings is None:\n        return await db.sp2yt(guildid=ctx.guild.id).insert()\n    spotify_url = get_spotify_url(url)\n    if spotify_url is not None:\n        if \"track\" in spotify_url:\n            song = spotify.track(spotify_url)\n            query_type = 'songs'\n        if \"album\" in spotify_url:\n            song = spotify.album(spotify_url)\n            query_type = 'albums'\n        # print(song[\"artists\"][0][\"name\"], song['name'])\n        youtube_search = ytmusic.search(f\"{song['artists'][0]['name']} {song['name']}\", query_type)\n        # print(youtube_search[0])\n        if query_type == 'songs':\n            url = f\"https://music.youtube.com/watch?v={youtube_search[0]['videoId']}\"\n        elif query_type == 'albums':\n            albumsearch = ytmusic.get_album(youtube_search[0]['browseId'])\n            url = f\"https://music.youtube.com/playlist?list={albumsearch['audioPlaylistId']}\"\n        await ctx.send(url)\n    else:\n        await ctx.send(\"This is either not a Spotify URL or this Spotify URL is not supported. I only support Spotify Track and Album URLs.\")\n</code></pre>"},{"location":"sp2yt/#extentions.sp2yt.SpotifyToYoutube.add_music_channel","title":"<code>add_music_channel(ctx, channel=None)</code>  <code>async</code>","text":"<p>/sp2yt_manage music_channel add</p> Description <p>Add a channel to the list of music channels. The bot will listen to spotify links in these channels.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>OptionType.CHANNEL</code> <p>Specify the channel you want to add to the music channels list</p> <code>None</code> Source code in <code>extentions/sp2yt.py</code> <pre><code>@sp2yt_manage.subcommand('music_channel', 'add', 'Add a channel to music channels.')\n@channel()\nasync def add_music_channel(self, ctx:InteractionContext, channel: OptionType.CHANNEL=None):\n\"\"\"/sp2yt_manage music_channel add\n    Description:\n        Add a channel to the list of music channels. The bot will listen to spotify links in these channels.\n\n    Args:\n        channel (OptionType.CHANNEL): Specify the channel you want to add to the music channels list\n    \"\"\"\n    await ctx.defer(ephemeral=True)\n    if channel is None:\n        channel = ctx.channel\n    settings = await db.sp2yt.find_one({\"guildid\":ctx.guild.id})\n    if settings is None:\n        await db.sp2yt(guildid=ctx.guild.id).insert()\n        settings = await db.sp2yt.find_one({\"guildid\":ctx.guild.id})\n    music_channels = settings.music_channels\n    if music_channels is None:\n        music_channels = list()\n    if channel.id in music_channels:\n        await ctx.send(f'{channel.mention} is already a music channel..', ephemeral=True)\n    music_channels.append(channel.id)\n    await settings.save()\n    channel_mentions = [ctx.guild.get_channel(id) for id in music_channels]\n    channel_mentions = [ch.mention for ch in channel_mentions if ch is not None]\n    channel_mentions = ' '.join(channel_mentions)\n    embed = Embed(description=f\"Channel {channel.mention} set as a music channel.\")\n    embed.add_field('Music Channels', channel_mentions)\n    await ctx.send(embed=embed, ephemeral=True)\n</code></pre>"},{"location":"sp2yt/#extentions.sp2yt.SpotifyToYoutube.remove_music_channel","title":"<code>remove_music_channel(ctx, channel=None)</code>  <code>async</code>","text":"<p>/sp2yt_manage music_channel remove</p> description <p>Remove a channel from the list of music channels. If no channel is specified, it will remove the current channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>OptionType.CHANNEL</code> <p>Specify the channel that is being removed from the music channels list</p> <code>None</code> Source code in <code>extentions/sp2yt.py</code> <pre><code>@sp2yt_manage.subcommand('music_channel', 'remove', 'Remove a channel from music channels.')\n@channel()\nasync def remove_music_channel(self, ctx:InteractionContext, channel: OptionType.CHANNEL=None):\n\"\"\"/sp2yt_manage music_channel remove\n    description:\n        Remove a channel from the list of music channels.\n        If no channel is specified, it will remove the current channel.\n\n    Args:\n        channel (OptionType.CHANNEL): Specify the channel that is being removed from the music channels list\n    \"\"\"\n    await ctx.defer(ephemeral=True)\n    if channel is None:\n        channel = ctx.channel\n    settings = await db.sp2yt.find_one({\"guildid\":ctx.guild.id})\n    if settings is None:\n        await db.sp2yt(guildid=ctx.guild.id).insert()\n    music_channels = settings.music_channels\n    if music_channels is None:\n        music_channels = list()\n    if channel.id not in music_channels:\n        await ctx.send(f'{channel.mention} is not a music channel.', ephemeral=True)\n    music_channels.remove(channel.id)\n    await settings.save()\n    channel_mentions = [ctx.guild.get_channel(id) for id in music_channels]\n    channel_mentions = [ch.mention for ch in channel_mentions if ch is not None]\n    channel_mentions = ' '.join(channel_mentions)\n    embed = Embed(description=f\"Channel {channel.mention} removed from being a music channel.\")\n    embed.add_field('Music Channels', channel_mentions)\n    await ctx.send(embed=embed, ephemeral=True)\n</code></pre>"},{"location":"sp2yt/#extentions.sp2yt.SpotifyToYoutube.MusicAddIgnoredRoles","title":"<code>MusicAddIgnoredRoles(ctx, role)</code>  <code>async</code>","text":"<p>/sp2yt_manage ignored_role add</p> Description <p>Add a role to the list of roles ignored in music channels.</p> <p>Parameters:</p> Name Type Description Default <code>role</code> <code>OptionType.ROLE</code> <p>Get the role that is being ignored</p> required Source code in <code>extentions/sp2yt.py</code> <pre><code>@sp2yt_manage.subcommand('ignored_role', 'add', 'Make a role to be ignored in music channels.')\n@role()\nasync def MusicAddIgnoredRoles(self, ctx:InteractionContext, role: OptionType.ROLE):\n\"\"\"/sp2yt_manage ignored_role add\n    Description:\n        Add a role to the list of roles ignored in music channels.\n\n    Args:\n        role (OptionType.ROLE): Get the role that is being ignored\n    \"\"\"\n    await ctx.defer(ephemeral=True)\n    settings = await db.sp2yt.find_one({\"guildid\":ctx.guild.id})\n    if settings is None:\n        await db.sp2yt(guildid=ctx.guild.id).insert()\n    ignored_roles = settings.ignored_roles\n    if ignored_roles is None:\n        ignored_roles = list()\n    if role.id in ignored_roles:\n        await ctx.send(f'{role.mention} is already ignored in music channels.', ephemeral=True)\n    ignored_roles.append(role.id)\n    await settings.save()\n    role_mentions = [ctx.guild.get_role(id) for id in ignored_roles]\n    role_mentions = [r.mention for r in role_mentions if r is not None]\n    role_mentions = ' '.join(role_mentions)\n    embed = Embed(description=f\"Role {role.mention} was added to roles ignored in music channels.\")\n    embed.add_field('Ignored Roles', role_mentions)\n    await ctx.send(embed=embed, ephemeral=True)\n</code></pre>"},{"location":"sp2yt/#extentions.sp2yt.SpotifyToYoutube.MusicRemoveIgnoredRoles","title":"<code>MusicRemoveIgnoredRoles(ctx, role)</code>  <code>async</code>","text":"<p>/sp2yt_manage ignored_role remove Remove a role from the list of roles that are ignored in music channels.</p> <p>Parameters:</p> Name Type Description Default <code>role</code> <code>OptionType.ROLE</code> <p>Role that is gonna be ignored</p> required Source code in <code>extentions/sp2yt.py</code> <pre><code>@sp2yt_manage.subcommand('ignored_role', 'remove', 'Remove a role from being ignored in music channels.')\n@role()\nasync def MusicRemoveIgnoredRoles(self, ctx:InteractionContext, role: OptionType.ROLE):\n\"\"\"/sp2yt_manage ignored_role remove\n    Remove a role from the list of roles that are ignored in music channels.\n\n    Args:\n        role (OptionType.ROLE): Role that is gonna be ignored\n    \"\"\"\n    await ctx.defer(ephemeral=True)\n    settings = await db.sp2yt.find_one({\"guildid\":ctx.guild.id})\n    if settings is None:\n        await db.sp2yt(guildid=ctx.guild.id).insert()\n    ignored_roles = settings.ignored_roles\n    if ignored_roles is None:\n        ignored_roles = list()\n    if role.id not in ignored_roles:\n        await ctx.send(f'{role.mention} is not being ignored in music channels.', ephemeral=True)\n    ignored_roles.remove(role.id)\n    await settings.save()\n    role_mentions = [ctx.guild.get_role(id) for id in ignored_roles]\n    role_mentions = [r.mention for r in role_mentions if r is not None]\n    role_mentions = ' '.join(role_mentions)\n    embed = Embed(description=f\"Role {role.mention} was removed from being ignored in music channels.\")\n    embed.add_field('Ignored Roles', role_mentions)\n    await ctx.send(embed=embed, ephemeral=True)\n</code></pre>"},{"location":"sp2yt/#extentions.sp2yt.SpotifyToYoutube.MusicAddIgnoredMember","title":"<code>MusicAddIgnoredMember(ctx, user)</code>  <code>async</code>","text":"<p>/sp2yt_manage ignored_member add</p> Description <p>Add a user to the list of ignored users in music channels. This means that they will not be able to use any commands in music channels.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>OptionType.USER</code> <p>User to add to the ignored list</p> required Source code in <code>extentions/sp2yt.py</code> <pre><code>@sp2yt_manage.subcommand('ignored_member', 'add', 'Make a member to be ignored in music channels.')\n@user()\nasync def MusicAddIgnoredMember(self, ctx:InteractionContext, user: OptionType.USER):\n\"\"\"/sp2yt_manage ignored_member add\n    Description:\n        Add a user to the list of ignored users in music channels.\n        This means that they will not be able to use any commands in music channels.\n\n    Args:\n        user (OptionType.USER): User to add to the ignored list\n    \"\"\"\n    await ctx.defer(ephemeral=True)\n    settings = await db.sp2yt.find_one({\"guildid\":ctx.guild.id})\n    if settings is None:\n        await db.sp2yt(guildid=ctx.guild.id).insert()\n    ignored_users = settings.ignored_users\n    if ignored_users is None:\n        ignored_users = list()\n    if user.id in ignored_users:\n        await ctx.send(f'{user}|{user.id} is already ignored in music channels.', ephemeral=True)\n    ignored_users.append(user.id)\n    await settings.save()\n    users = [ctx.guild.get_member(id) for id in ignored_users]\n    users = [f'{r}({r.id})' for r in users if r is not None]\n    users = ' '.join(users)\n    embed = Embed(description=f\"Member {user}({user.id}) was added to members ignored in music channels.\")\n    embed.add_field('Ignored Members', users)\n    await ctx.send(embed=embed, ephemeral=True)\n</code></pre>"},{"location":"sp2yt/#extentions.sp2yt.SpotifyToYoutube.MusicRemoveIgnoredMember","title":"<code>MusicRemoveIgnoredMember(ctx, user)</code>  <code>async</code>","text":"<p>/sp2yt_manage ignored_member remove</p> Description <p>Remove a user from the ignored list for music channels.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>OptionType.USER</code> <p>Specify the user to be removed from the ignored list</p> required Source code in <code>extentions/sp2yt.py</code> <pre><code>@sp2yt_manage.subcommand('ignored_member', 'remove', 'Remove a member from being ignored in music channels.')\n@user()\nasync def MusicRemoveIgnoredMember(self, ctx:InteractionContext, user: OptionType.USER):\n\"\"\"/sp2yt_manage ignored_member remove\n    Description:\n        Remove a user from the ignored list for music channels.\n\n\n    Args:\n        user (OptionType.USER): Specify the user to be removed from the ignored list\n    \"\"\"\n    await ctx.defer(ephemeral=True)\n    settings = await db.sp2yt.find_one({\"guildid\":ctx.guild.id})\n    if settings is None:\n       await db.sp2yt(guildid=ctx.guild.id).insert()\n    ignored_users = settings.ignored_users\n    if ignored_users is None:\n        ignored_users = list()\n    if user.id not in ignored_users:\n        await ctx.send(f'{user}|{user.id} is not being ignored in music channels.', ephemeral=True)\n    ignored_users.remove(user.id)\n    await settings.save()\n    users = [ctx.guild.get_member(id) for id in ignored_users]\n    users = [f'{r}({r.id})' for r in users if r is not None]\n    users = ' '.join(users)\n    embed = Embed(description=f\"Member {user}({user.id}) was removed from being ignored in music channels.\")\n    embed.add_field('Ignored Members', users)\n    await ctx.send(embed=embed, ephemeral=True)\n</code></pre>"},{"location":"tags/","title":"Tags","text":"<p>         Bases: <code>Extension</code></p> Source code in <code>extentions/tags.py</code> <pre><code>class Tags(Extension):\n    def __init__(self, bot: Client):\n        self.bot = bot\n\n    @slash_command(name='t', description=\"allow's me to recall tags\", scopes=[435038183231848449, 149167686159564800])\n    @tagname()\n    async def t(self, ctx:InteractionContext, tagname:str):\n        await ctx.defer()\n        tags = await db.tag.find_one({\"names\":tagname, \"guild_id\":ctx.guild_id})\n        if tags is None:\n            embed = Embed(\n                description=f\":x: `{tagname}` is not a tag\",\n                color=0xDD2222)\n            await ctx.send(embed=embed, ephemeral=True)\n        else:\n            if tags.attachment_url is not None:\n                if (tags.content is not None) and (tags.content != tags.attachment_url):\n                    await ctx.send(f'{tags.content}\\n{tags.attachment_url}')\n                else:\n                    await ctx.send(f'{tags.attachment_url}')\n            else:\n                await ctx.send(f'{tags.content}')\n            uses = tags.no_of_times_used\n            if uses is None:\n                uses = 0\n            else:\n                uses = tags.no_of_times_used\n            tags.no_of_times_used = uses + 1\n            await tags.save()\n\n    @t.autocomplete('tagname')\n    async def t_autocomplete(self, ctx: AutocompleteContext):\n        tagname = ctx.input_text\n        choices = []\n        tags = db.tag.find({\"guild_id\":ctx.guild_id})\n        tagnames = [tag.names async for tag in tags]\n        if tagname:\n            result = process.extract(tagname, tagnames, scorer=fuzz.partial_token_sort_ratio, limit=25)\n            choices = [{'name':f'{t[0]}', 'value':f'{t[0]}'} for t in result if t[1] &gt; 50]\n        else:\n            choices = [{'name':f'{name}', 'value':f'{name}'} for name in tagnames[:25]]\n        await ctx.send(choices=choices)\n\n    tag = SlashCommand(name='tag', description='manage tags')\n\n    @tag.subcommand(sub_cmd_name='recall', sub_cmd_description=\"allow's me to recall tags\")\n    @tagname()\n    async def tag(self, ctx:InteractionContext, tagname:str):\n\"\"\"/tag recall\n        Description:\n            Send the content of a tag.\n\n        Args:\n            tagname: the tag name\n        \"\"\"\n        await ctx.defer()\n        tags = await db.tag.find_one({\"names\":tagname, \"guild_id\":ctx.guild_id})\n        if tags is None:\n            embed = Embed(\n                description=f\":x: `{tagname}` is not a tag\",\n                color=0xDD2222)\n            await ctx.send(embed=embed, ephemeral=True)\n        else:\n            if tags.attachment_url is not None:\n                if (tags.content is not None) and (tags.content != tags.attachment_url):\n                    await ctx.send(f'{tags.content}\\n{tags.attachment_url}')\n                else:\n                    await ctx.send(f'{tags.attachment_url}')\n            else:\n                await ctx.send(f'{tags.content}')\n            uses = tags.no_of_times_used\n            if uses is None:\n                uses = 0\n            else:\n                uses = tags.no_of_times_used\n            tags.no_of_times_used = uses + 1\n            await tags.save()\n\n    @tag.subcommand(sub_cmd_name='create', sub_cmd_description=\"allow's me to store tags\")\n    @slash_option(name='tagname', description='Type a name of a tag', opt_type=OptionType.STRING, required=True, autocomplete=False)\n    @content()\n    @attachment()\n    async def tag_create(self, ctx:InteractionContext, tagname:str=None, content:str=None, attachment:OptionType.ATTACHMENT=None):\n\"\"\"/tag create\n        Description:\n            Create tags.\n\n        Args:\n            tagname: The tag's name\n            content: The content of the tag\n            attachment: The attachment from the message\n        \"\"\"\n        await ctx.defer()\n        if tagname is None:\n            embed = Embed(description=f\":x: You must include tag's name\",\n                        color=0xDD2222)\n            await ctx.send(embed=embed, ephemeral=True)\n            return\n        elif (content is None) and (attachment is None):\n            embed = Embed(description=f\":x: You must include tag's content\",\n                        color=0xDD2222)\n            await ctx.send(embed=embed, ephemeral=True)\n            return\n        elif (tagname is None) and (content is None):\n            embed = Embed(description=f\":x: You must include tag's name and content\",\n                        color=0xDD2222)\n            await ctx.send(embed=embed, ephemeral=True)\n            return\n\n        tagname_regx = {'$regex':f'^{re.escape(tagname)}$', '$options':'i'}\n        check = await db.tag.find_one({'guild_id':ctx.guild_id, 'names':tagname_regx})\n        if check==None:\n            if attachment is not None:\n                for at in ['exe', 'scr', 'cpl', 'doc', 'jar']:\n                    if at in attachment.content_type:\n                        return await ctx.send(f'`{at}` attachment file type is not allowed to be uploaded to our host site')\n                if content is None:\n                    if (attachment.content_type == 'image/png') or (attachment.content_type == 'image/jpg') or (attachment.content_type == 'image/jpeg') or (attachment.content_type == 'image/gif'):\n                        image_url = catbox.url_upload(attachment.url)\n                        await db.tag(guild_id=ctx.guild_id, author_id=ctx.author.id, owner_id=ctx.author.id, names=tagname, content=content, attachment_url=image_url, creation_date=datetime.utcnow()).insert()\n                        embed = Embed(description=f\"__**Tag created!**__ \\n\\n**Tag's name:** {tagname}\",\n                                color=0xffcc50)\n                        embed.set_image(url=image_url)\n                        return await ctx.send(embed=embed)\n                    else:\n                        await db.tag(guild_id=ctx.guild_id, author_id=ctx.author.id, owner_id=ctx.author.id, names=tagname, content=content, attachment_url=catbox.url_upload(attachment.url), creation_date=datetime.utcnow()).insert()\n                        embed = Embed(description=f\"__**Tag created!**__ \\n\\n**Tag's name:** {tagname}\\n**Attachment:** {catbox.url_upload(attachment.url)}\",\n                                color=0xffcc50)\n                        return await ctx.send(embed=embed)\n                else:\n                    if (attachment.content_type == 'image/png') or (attachment.content_type == 'image/jpg') or (attachment.content_type == 'image/jpeg') or (attachment.content_type == 'image/gif'):\n                        image_url = catbox.url_upload(attachment.url)\n                        await db.tag(guild_id=ctx.guild_id, author_id=ctx.author.id, owner_id=ctx.author.id, names=tagname, content=content, attachment_url=image_url, creation_date=datetime.utcnow()).insert()\n                        embed = Embed(description=f\"__**Tag created!**__ \\n\\n**Tag's name:** {tagname}\\n**Content:** {content}\",\n                                color=0xffcc50)\n                        embed.set_image(url=image_url)\n                        return await ctx.send(embed=embed)\n                    else:\n                        await db.tag(guild_id=ctx.guild_id, author_id=ctx.author.id, owner_id=ctx.author.id, names=tagname, content=content, attachment_url=catbox.url_upload(attachment.url), creation_date=datetime.utcnow()).insert()\n                        embed = Embed(description=f\"__**Tag created!**__ \\n\\n**Tag's name:** {tagname}\\n**Content:** {content}\\n**Attachment:** {catbox.url_upload(attachment.url)}\",\n                                color=0xffcc50)\n                        return await ctx.send(embed=embed)\n            else:\n                if content is not None:\n                    url = geturl(content)\n                    for url in url:\n                        url = url\n                    if url:\n                        for at in ['.exe', '.scr', '.cpl', '.doc', '.jar']:\n                            if url.endswith(at):\n                                return await ctx.send(f'`{at}` url file type is not allowed to be stored in my database')\n                        if url.endswith('.png') or url.endswith('.apng') or url.endswith('.jpg') or url.endswith('.jpeg') or url.endswith('.gif'):\n                            await db.tag(guild_id=ctx.guild_id, author_id=ctx.author.id, owner_id=ctx.author.id, names=tagname, content=content, attachment_url=url, creation_date=datetime.utcnow()).insert()\n                            embed = Embed(description=f\"__**Tag created!**__ \\n\\n**Tag's name:** {tagname} \\n**Tag's content:**{content}\",\n                                        color=0xffcc50)\n                            embed.set_image(url=url)\n                            return await ctx.send(embed=embed)\n                        else:\n                            await db.tag(guild_id=ctx.guild_id, author_id=ctx.author.id, owner_id=ctx.author.id, names=tagname, content=content, attachment_url=url, creation_date=datetime.utcnow()).insert()\n                            embed = Embed(description=f\"__**Tag created!**__ \\n\\n**Tag's name:** {tagname} \\n**Tag's content:** \\n{content}\",\n                                        color=0xffcc50)\n                            return await ctx.send(embed=embed)\n                    else:\n                        await db.tag(guild_id=ctx.guild_id, author_id=ctx.author.id, owner_id=ctx.author.id, names=tagname, content=content, attachment_url=None, creation_date=datetime.utcnow()).insert()\n                        embed = Embed(description=f\"__**Tag created!**__ \\n\\n**Tag's name:** {tagname} \\n**Tag's content:** \\n{content}\",\n                                    color=0xffcc50)\n                        return await ctx.send(embed=embed)\n        else:\n            embed = Embed(description=f\":x: The tag `{tagname}` already exists\",\n                        color=0xDD2222)\n            await ctx.send(embed=embed, ephemeral=True)\n\n    @tag.subcommand(sub_cmd_name='delete', sub_cmd_description=\"allow's me to delete tags that you own\")\n    @tagname()\n    async def tag_delete(self, ctx:InteractionContext, tagname:str=None):\n\"\"\"/tag delete\n        Description:\n            Delete tags.\n\n        Args:\n            tagname: The tag's name\n        \"\"\"\n        await ctx.defer()\n        if tagname is None:\n            embed = Embed(description=f\":x: You must include tag's name\",\n                        color=0xDD2222)\n            await ctx.send(embed=embed, ephemeral=True)\n            return\n\n        tagname_regx = {'$regex':f'^{re.escape(tagname)}$', '$options':'i'}\n        tag_to_delete = await db.tag.find_one({'guild_id':ctx.guild_id, 'names':tagname_regx, 'author_id':ctx.author.id})\n        if tag_to_delete is None:\n            tag_to_delete = await db.tag.find_one({'guild_id':ctx.guild_id, 'names':tagname_regx, 'owner_id':ctx.author.id})\n            if tag_to_delete is None:\n                embed = Embed(description=f\":x: You don't own a tag called  `{tagname}`\",\n                            color=0xDD2222)\n                await ctx.send(embed=embed, ephemeral=True)\n                return\n        content = ''\n        if tag_to_delete.content is None:\n            if tag_to_delete.attachment_url is not None:\n                content = content + f'{tag_to_delete.attachment_url}'\n        elif tag_to_delete.content is not None:\n            content = content + f'{tag_to_delete.content}'\n            if tag_to_delete.attachment_url is not None:\n                content = content + f'\\n{tag_to_delete.attachment_url}'\n        embed = Embed(description=f\"__**Tag deleted!**__ \\n\\n**Tag's name:** {tag_to_delete.names} \\n**Tag's content:**{content}\",\n                    color=0xffcc50)\n        await ctx.send(embed=embed)\n        await tag_to_delete.delete()\n\n    @tag.subcommand(sub_cmd_name='admindelete', sub_cmd_description=\"[ADMIN ONLY]allow's me to delete any tag\")\n    @tagname()\n    @check(member_permissions(Permissions.ADMINISTRATOR))\n    async def tag_admin_delete(self, ctx:InteractionContext, tagname:str=None):\n\"\"\"/tag admindelete\n        Description:\n            Delete any tags. Requires admin permission.\n\n        Args:\n            tagname: The tag's name\n        \"\"\"\n        await ctx.defer()\n        if tagname is None:\n            embed = Embed(description=f\":x: You must include tag's name\",\n                        color=0xDD2222)\n            await ctx.send(embed=embed, ephemeral=True)\n            return\n\n        tagname_regx = {'$regex':f'^{re.escape(tagname)}$', '$options':'i'}\n        tag_to_delete = await db.tag.find_one({'guild_id':ctx.guild_id, 'names':tagname_regx})\n        if tag_to_delete is None:\n            embed = Embed(description=f\":x: There's not a tag with the name `{tagname}`\",\n                        color=0xDD2222)\n            await ctx.send(embed=embed, ephemeral=True)\n            return\n\n        content = ''\n        if tag_to_delete.content is None:\n            if tag_to_delete.attachment_url is not None:\n                content = content + f'{tag_to_delete.attachment_url}'\n        elif tag_to_delete.content is not None:\n            content = content + f'{tag_to_delete.content}'\n            if tag_to_delete.attachment_url is not None:\n                content = content + f'\\n{tag_to_delete.attachment_url}'\n        embed = Embed(description=f\"__**Tag deleted!**__ \\n\\n**Tag's name:** {tag_to_delete.names} \\n**Tag's content:**{content}\",\n                    color=0xffcc50)\n        await ctx.send(embed=embed)\n        await tag_to_delete.delete()\n\n    @tag.subcommand(sub_cmd_name='edit', sub_cmd_description=\"allow's me to delete tags that you own\")\n    @tagname()\n    @content()\n    @attachment()\n    async def tag_edit(self, ctx:InteractionContext, tagname:str=None, content:str=None, attachment:OptionType.ATTACHMENT=None):\n\"\"\"/tag edit\n        Description:\n            Edit tags.\n\n        Args:\n            tagname: The tag's name\n            content: The content of the tag\n            attachment: The attachment from the message\n        \"\"\"\n        await ctx.defer()\n        if tagname is None:\n            embed = Embed(description=f\":x: You must include tag's name\",\n                        color=0xDD2222)\n            await ctx.send(embed=embed, ephemeral=True)\n            return\n        elif (content is None) and (attachment is None):\n            embed = Embed(description=f\":x: You must include tag's content\",\n                        color=0xDD2222)\n            await ctx.send(embed=embed, ephemeral=True)\n            return\n        elif (tagname is None) and (content is None):\n            embed = Embed(description=f\":x: You must include tag's name and content\",\n                        color=0xDD2222)\n            await ctx.send(embed=embed, ephemeral=True)\n            return\n\n        tagname_regx = {'$regex':f'^{re.escape(tagname)}$', '$options':'i'}\n        tag_to_edit = await db.tag.find_one({'guild_id':ctx.guild_id, 'names':tagname_regx, 'author_id':ctx.author.id})\n        if tag_to_edit is None:\n            tag_to_edit = await db.tag.find_one({'guild_id':ctx.guild_id, 'names':tagname_regx, 'owner_id':ctx.author.id})\n            if tag_to_edit is None:\n                embed = Embed(description=f\":x: You don't own a tag called  `{tagname}`\",\n                            color=0xDD2222)\n                await ctx.send(embed=embed, ephemeral=True)\n                return\n\n        if attachment is not None:\n            for at in ['exe', 'scr', 'cpl', 'doc', 'jar']:\n                if at in attachment.content_type:\n                    return await ctx.send(f'`{at}` attachment file type is not allowed to be uploaded to our host site')\n            if content is None:\n                if (attachment.content_type == 'image/png') or (attachment.content_type == 'image/jpg') or (attachment.content_type == 'image/jpeg') or (attachment.content_type == 'image/gif'):\n                    image_url = catbox.url_upload(attachment.url)\n                    tag_to_edit.attachment_url = catbox.url_upload(attachment.url)\n                    tag_to_edit.content = content\n                    await tag_to_edit.save()\n                    embed = Embed(description=f\"__**Tag edited!**__ \\n\\n**Tag's name:** {tagname}\",\n                            color=0xffcc50)\n                    embed.set_image(url=image_url)\n                    return await ctx.send(embed=embed)\n                else:\n                    tag_to_edit.attachment_url = catbox.url_upload(attachment.url)\n                    tag_to_edit.content = content\n                    await tag_to_edit.save()\n                    embed = Embed(description=f\"__**Tag edited!**__ \\n\\n**Tag's name:** {tagname}\\n**Attachment:** {catbox.url_upload(attachment.url)}\",\n                            color=0xffcc50)\n                    return await ctx.send(embed=embed)\n            else:\n                if (attachment.content_type == 'image/png') or (attachment.content_type == 'image/jpg') or (attachment.content_type == 'image/jpeg') or (attachment.content_type == 'image/gif'):\n                    image_url = catbox.url_upload(attachment.url)\n                    tag_to_edit.attachment_url = catbox.url_upload(attachment.url)\n                    tag_to_edit.content = content\n                    await tag_to_edit.save()\n                    embed = Embed(description=f\"__**Tag edited!**__ \\n\\n**Tag's name:** {tagname}\\n**Content:** {content}\",\n                            color=0xffcc50)\n                    embed.set_image(url=image_url)\n                    return await ctx.send(embed=embed)\n                else:\n                    tag_to_edit.attachment_url = catbox.url_upload(attachment.url)\n                    tag_to_edit.content = content\n                    await tag_to_edit.save()\n                    embed = Embed(description=f\"__**Tag created!**__ \\n\\n**Tag's name:** {tagname}\\n**Content:** {content}\\n**Attachment:** {catbox.url_upload(attachment.url)}\",\n                            color=0xffcc50)\n                    return await ctx.send(embed=embed)\n        else:\n            if content is not None:\n                url = geturl(content)\n                for url in url:\n                    url = url\n                if url:\n                    for at in ['.exe', '.scr', '.cpl', '.doc', '.jar']:\n                            if url.endswith(at):\n                                return await ctx.send(f'`{at}` url file type is not allowed to be stored in my database')\n                    if url.endswith('.png') or url.endswith('.apng') or url.endswith('.jpg') or url.endswith('.jpeg') or url.endswith('.gif'):\n                        tag_to_edit.attachment_url = None\n                        tag_to_edit.content = content\n                        await tag_to_edit.save()\n                        embed = Embed(description=f\"__**Tag created!**__ \\n\\n**Tag's name:** {tagname} \\n**Tag's content:**{content}\",\n                                    color=0xffcc50)\n                        embed.set_image(url=url)\n                        return await ctx.send(embed=embed)\n                    else:\n                        tag_to_edit.attachment_url = None\n                        tag_to_edit.content = content\n                        await tag_to_edit.save()\n                        embed = Embed(description=f\"__**Tag created!**__ \\n\\n**Tag's name:** {tagname} \\n**Tag's content:** \\n{content}\",\n                                    color=0xffcc50)\n                        return await ctx.send(embed=embed)\n                else:\n                    tag_to_edit.attachment_url = None\n                    tag_to_edit.content = content\n                    await tag_to_edit.save()\n                    embed = Embed(description=f\"__**Tag created!**__ \\n\\n**Tag's name:** {tagname} \\n**Tag's content:** \\n{content}\",\n                                color=0xffcc50)\n                    return await ctx.send(embed=embed)\n\n    @tag.subcommand(sub_cmd_name='info', sub_cmd_description=\"allow's me to see information about a tag\")\n    @tagname()\n    async def tag_info(self, ctx:InteractionContext, tagname:str=None):\n\"\"\"/tag info\n        Description:\n            See info about tags\n\n        Args:\n            tagname: The tag's name\n        \"\"\"\n        await ctx.defer()\n        if tagname is None:\n            embed = Embed(description=f\":x: You must include tag's name\",\n                        color=0xDD2222)\n            await ctx.send(embed=embed, ephemeral=True)\n            return\n\n        tagname_regx = {'$regex':f'^{re.escape(tagname)}$', '$options':'i'}\n        tag_to_view = await db.tag.find_one({'guild_id':ctx.guild_id, 'names':tagname_regx})\n        if tag_to_view is None:\n            embed = Embed(description=f\":x: I couldn't find a tag called `{tagname}`\",\n                        color=0xDD2222)\n            await ctx.send(embed=embed, ephemeral=True)\n            return\n\n        if tag_to_view.owner_id is None:\n            owner_id = tag_to_view.author_id\n        else:\n            owner_id = tag_to_view.owner_id\n\n        tag_owner = ctx.guild.get_member(owner_id)         \n        if tag_owner is None:\n            tag_owner = tag_to_view.owner_id\n            current_owner = 'Currently Orphaned'\n            last_owner = f'Last owner: {tag_owner}'\n        else:\n            current_owner = 'Current owner'\n            last_owner = tag_owner\n\n\n        total_uses = tag_to_view.no_of_times_used\n        if total_uses is None:\n            uses = 'UNKNOWN'\n        else:\n            uses = total_uses\n\n        creation_date = tag_to_view.creation_date\n        if creation_date is None:\n            date = 'UNKNOWN'\n        else:\n            date = f'&lt;t:{math.ceil(tag_to_view.creation_date.replace(tzinfo=timezone.utc).timestamp())}:R&gt;'\n\n        if tag_to_view.attachment_url is not None:\n            if tag_to_view.content is not None:\n                content = f'{tag_to_view.content}\\n{tag_to_view.attachment_url}'\n            else:\n                content = f'{tag_to_view.attachment_url}'\n        else:\n            content = f'{tag_to_view.content}'\n\n        embed = Embed(title=f\"Info about [{tag_to_view.names}] tag\",\n                    color=0xffcc50)\n        embed.add_field(name=current_owner, value=last_owner)\n        embed.add_field(name=\"Total uses\", value=uses)\n        embed.add_field(name=\"Created\", value=date)\n        embed.add_field(name=\"Content\", value=content)\n        await ctx.send(embed=embed)\n\n    @tag.subcommand(sub_cmd_name='list', sub_cmd_description=\"allow's me to see all tags for this server\")\n    async def tag_list(self, ctx:InteractionContext):\n\"\"\"/tag list\n        Description:\n            Lists all tags\n        \"\"\"\n        await ctx.defer()\n        from interactions.ext.paginators import Paginator\n        def chunks(l, n):\n            n = max(1, n)\n            return (l[i:i+n] for i in range(0, len(l), n))\n\n        def mlis(lst, s, e):\n            nc = list(chunks(lst, 20))\n            mc = ''\n            for testlist in nc[s:e]:\n                for m in testlist:\n                    mc = mc + m\n            return mc\n\n        def newpage(title, names):\n            embed = Embed(title=title,\n            color=0xffcc50)\n            embed.add_field(name='Tag Names', value=names, inline=True)\n            return embed\n\n\n        tag_names = db.tag.find({\"guild_id\":ctx.guild_id})\n        names = []\n        async for t in tag_names:\n            names.append(f\"{t.names}\\n\")\n        if names == []:\n            embed = Embed(description=f\"There are no tags for {ctx.guild.name}.\",\n                        color=0xffcc50)\n            await ctx.send(embed=embed)\n            return\n\n        s = -1\n        e = 0\n        embedcount = 1\n        nc = list(chunks(names, 20))\n\n        embeds = []\n        while embedcount &lt;= len(nc):\n            s = s+1\n            e = e+1\n            embeds.append(newpage(f'List of tags for {ctx.guild.name}', mlis(names, s, e)))\n            embedcount = embedcount+1\n\n        paginator = Paginator(\n            client=self.bot, \n            pages=embeds,\n            timeout_interval=80,\n            show_select_menu=False,\n            wrong_user_message=\"You're not the one destined for this list.\")\n        await paginator.send(ctx)\n\n\n    @tag.subcommand(sub_cmd_name='claim', sub_cmd_description=\"claim orphaned tags\")\n    @tagname()\n    async def tag_claim(self, ctx:InteractionContext, tagname:str=None):\n\"\"\"/tag claim\n        Description:\n            Claim orphaned tags\n\n        Args:\n            tagname: The tag's name\n        \"\"\"\n        await ctx.defer()\n        if tagname is None:\n            embed = Embed(description=f\":x: You must include tag's name\",\n                        color=0xDD2222)\n            await ctx.send(embed=embed, ephemeral=True)\n            return\n\n        tagname_regx = {'$regex':f'^{re.escape(tagname)}$', '$options':'i'}\n        tag_to_claim = await db.tag.find_one({'guild_id':ctx.guild_id, 'names':tagname_regx})\n        if tag_to_claim is None:\n            embed = Embed(description=f\":x: I couldn't find a tag called `{tagname}`\",\n                        color=0xDD2222)\n            await ctx.send(embed=embed, ephemeral=True)\n            return\n        if tag_to_claim.owner_id is None:\n            current_owner = tag_to_claim.author_id\n        else:\n            current_owner = tag_to_claim.owner_id\n        if (current_owner == ctx.author.id):\n            embed = Embed(description=f\":x: You can't claim a tag you already own\",\n                        color=0xDD2222)\n            await ctx.send(embed=embed, ephemeral=True)\n            return\n        if (tag_to_claim.author_id == ctx.author.id) and (current_owner != ctx.author.id):\n            mf = ctx.guild.get_member(current_owner)\n            if mf is None:\n                thief = current_owner\n            else:\n                thief = mf.mention\n\n            embed = Embed(description=f\"{ctx.author.mention} You took back your tag {tag_to_claim.names} from {thief}\",\n                        color=0xffcc50)\n            await ctx.send(embed=embed)\n            current_owner = ctx.author.id\n            await tag_to_claim.save()\n            return\n\n        if ctx.guild.get_member(current_owner) is None:\n            tag_to_claim.owner_id = ctx.author.id\n            await tag_to_claim.save()\n            embed = Embed(description=f\"{ctx.author.mention} You are now owner of {tag_to_claim.names}\",\n                        color=0xffcc50)\n            await ctx.send(embed=embed)\n        else:\n            embed = Embed(description=f\":x: You can't claim a tag that's not orphaned\",\n                        color=0xDD2222)\n            await ctx.send(embed=embed, ephemeral=True)\n\n    @tag.subcommand(sub_cmd_name='gift', sub_cmd_description=\"gift your tags\")\n    @tagname()\n    @member()\n    async def tag_gift(self, ctx:InteractionContext, tagname:str=None, member:OptionType.USER=None):\n\"\"\"/tag gift\n        Description:\n            Gidt tags you own\n\n        Args:\n            tagname: The tag's name\n            member: Member to gift to\n        \"\"\"\n        await ctx.defer()\n        if tagname is None:\n            embed = Embed(description=f\":x: You must include tag's name\",\n                        color=0xDD2222)\n            await ctx.send(embed=embed, ephemeral=True)\n            return\n\n        if member is None:\n            embed = Embed(description=f\":x: You must include a member\",\n                        color=0xDD2222)\n            await ctx.send(embed=embed, ephemeral=True)\n            return\n\n        if member == ctx.author:\n            embed = Embed(description=f\":x: You can't gift to yourself, egomaniac...\",\n                        color=0xDD2222)\n            await ctx.send(embed=embed, ephemeral=True)\n            return\n\n        tagname_regx = {'$regex':f'^{re.escape(tagname)}$', '$options':'i'}\n        tag_to_claim = await db.tag.find_one({'guild_id':ctx.guild_id, 'names':tagname_regx, 'owner_id':ctx.author.id})\n        if tag_to_claim is None:\n            embed = Embed(description=f\":x: You don't own a tag with that name\",\n                        color=0xDD2222)\n            await ctx.send(embed=embed, ephemeral=True)\n            return\n        aceept_button_id = f'{member.id}_accept_tag_gift_button'\n        cancel_button_id = f'{ctx.author.id}_accept_tag_gift_button'\n        accept_button: list[ActionRow] = spread_to_rows(\n            Button(\n                style=ButtonStyle.GREEN,\n                label=\"GIMME!\",\n                custom_id=aceept_button_id\n            ),\n            Button(\n                style=ButtonStyle.RED,\n                label=\"Cancel!\",\n                custom_id=cancel_button_id\n            )\n        )\n        def check(component: Button) -&gt; bool:\n            return (component.context.author == ctx.author) or (component.context.author == member)\n\n        gift_question = await ctx.send(f'Hey {member.mention}! {ctx.author.mention} is gifting you a {tag_to_claim.names}, do you accept the gift?', components=accept_button)\n        while True:\n            try:\n                reaction = await self.bot.wait_for_component(components=accept_button, timeout=30)\n            except asyncio.TimeoutError:\n                accept_button[0].components[0].disabled = True\n                accept_button[0].components[1].disabled = True\n                await gift_question.edit('Time ran out to accept the gift.', components=accept_button)\n                return\n            if (reaction.context.custom_id == aceept_button_id) and (member == reaction.context.author):\n                tag_to_claim.owner_id = member.id\n                await tag_to_claim.save()\n                accept_button[0].components[0].disabled = True\n                accept_button[0].components[1].disabled = True\n                await gift_question.edit(f'Gift for a tag {tag_to_claim.names} accepted!', components=accept_button)\n                return\n            elif (reaction.context.custom_id == aceept_button_id) and (member != reaction.context.author):\n                await ctx.send(f\"{reaction.context.author.mention} You can't accept gifts not menat for you!\", ephemeral=True)\n\n            if (reaction.context.custom_id == cancel_button_id) and (ctx.author == reaction.context.author):\n                accept_button[0].components[0].disabled = True\n                accept_button[0].components[1].disabled = True\n                await gift_question.edit(f'Gift for a tag {tag_to_claim.names} cancelled!', components=accept_button)\n                return\n            elif (reaction.context.custom_id == cancel_button_id) and (ctx.author != reaction.context.author):\n                await ctx.send(f\"{reaction.context.author.mention} Only owners can cancel gifting!\", ephemeral=True)\n\n    @tag.autocomplete('tagname')\n    async def tag_autocomplete(self, ctx: AutocompleteContext):\n        tagname = ctx.input_text\n        choices = []\n        regx = {'$regex':f'{re.escape(tagname)}', '$options':'igm'}\n        tags = db.tag.find({\"guild_id\":ctx.guild_id, 'names': regx}).limit(25)\n        async for tag in tags:\n            tag_name = tag.names\n            choices.append({'name':f'{tag_name}', 'value':f'{tag.names}'})\n        await ctx.send(choices=choices)\n\n    @tag_admin_delete.autocomplete('tagname')\n    async def tag_admin_delete_autocomplete(self, ctx: AutocompleteContext):\n        tagname = ctx.input_text\n        choices = []\n        regx = {'$regex':f'{re.escape(tagname)}', '$options':'igm'}\n        tags = db.tag.find({\"guild_id\":ctx.guild_id, 'names': regx}).limit(25)\n        async for tag in tags:\n            tag_name = tag.names\n            choices.append({'name':f'{tag_name}', 'value':f'{tag.names}'})\n        await ctx.send(choices=choices)\n\n    @tag_claim.autocomplete('tagname')\n    async def tag_claim_autocomplete(self, ctx: AutocompleteContext):\n        tagname = ctx.input_text\n        choices = []\n        regx = {'$regex':f'{re.escape(tagname)}', '$options':'igm'}\n        tags = db.tag.find({\"guild_id\":ctx.guild_id, 'names': regx}).limit(25)\n        async for tag in tags:\n            tag_name = tag.names\n            choices.append({'name':f'{tag_name}', 'value':f'{tag.names}'})\n        await ctx.send(choices=choices)\n\n    @tag_gift.autocomplete('tagname')\n    async def tag_gift_autocomplete(self, ctx: AutocompleteContext):\n        tagname = ctx.input_text\n        choices = []\n        regx = {'$regex':f'{re.escape(tagname)}', '$options':'igm'}\n        tags = db.tag.find({\"guild_id\":ctx.guild_id, 'names': regx}).limit(25)\n        async for tag in tags:\n            tag_name = tag.names\n            choices.append({'name':f'{tag_name}', 'value':f'{tag.names}'})\n        await ctx.send(choices=choices)\n\n    @tag_info.autocomplete('tagname')\n    async def tag_info_autocomplete(self, ctx: AutocompleteContext):\n        tagname = ctx.input_text\n        choices = []\n        regx = {'$regex':f'{re.escape(tagname)}', '$options':'igm'}\n        tags = db.tag.find({\"guild_id\":ctx.guild_id, 'names': regx}).limit(25)\n        async for tag in tags:\n            tag_name = tag.names\n            choices.append({'name':f'{tag_name}', 'value':f'{tag.names}'})\n        await ctx.send(choices=choices)\n\n    @tag_edit.autocomplete('tagname')\n    async def tag_edit_autocomplete(self, ctx: AutocompleteContext):\n        tagname = ctx.input_text\n        choices = []\n        regx = {'$regex':f'{re.escape(tagname)}', '$options':'igm'}\n        tags = db.tag.find({\"guild_id\":ctx.guild_id, 'names': regx}).limit(25)\n        async for tag in tags:\n            tag_name = tag.names\n            choices.append({'name':f'{tag_name}', 'value':f'{tag.names}'})\n        await ctx.send(choices=choices)\n\n    @tag_delete.autocomplete('tagname')\n    async def tag_delete_autocomplete(self, ctx: AutocompleteContext):\n        tagname = ctx.input_text\n        choices = []\n        regx = {'$regex':f'{re.escape(tagname)}', '$options':'igm'}\n        tags = db.tag.find({\"guild_id\":ctx.guild_id, 'names': regx}).limit(25)\n        async for tag in tags:\n            tag_name = tag.names\n            choices.append({'name':f'{tag_name}', 'value':f'{tag.names}'})\n        await ctx.send(choices=choices)\n</code></pre>"},{"location":"tags/#extentions.tags.Tags.tag","title":"<code>tag(ctx, tagname)</code>  <code>async</code>","text":"<p>/tag recall</p> Description <p>Send the content of a tag.</p> <p>Parameters:</p> Name Type Description Default <code>tagname</code> <code>str</code> <p>the tag name</p> required Source code in <code>extentions/tags.py</code> <pre><code>@tag.subcommand(sub_cmd_name='recall', sub_cmd_description=\"allow's me to recall tags\")\n@tagname()\nasync def tag(self, ctx:InteractionContext, tagname:str):\n\"\"\"/tag recall\n    Description:\n        Send the content of a tag.\n\n    Args:\n        tagname: the tag name\n    \"\"\"\n    await ctx.defer()\n    tags = await db.tag.find_one({\"names\":tagname, \"guild_id\":ctx.guild_id})\n    if tags is None:\n        embed = Embed(\n            description=f\":x: `{tagname}` is not a tag\",\n            color=0xDD2222)\n        await ctx.send(embed=embed, ephemeral=True)\n    else:\n        if tags.attachment_url is not None:\n            if (tags.content is not None) and (tags.content != tags.attachment_url):\n                await ctx.send(f'{tags.content}\\n{tags.attachment_url}')\n            else:\n                await ctx.send(f'{tags.attachment_url}')\n        else:\n            await ctx.send(f'{tags.content}')\n        uses = tags.no_of_times_used\n        if uses is None:\n            uses = 0\n        else:\n            uses = tags.no_of_times_used\n        tags.no_of_times_used = uses + 1\n        await tags.save()\n</code></pre>"},{"location":"tags/#extentions.tags.Tags.tag_create","title":"<code>tag_create(ctx, tagname=None, content=None, attachment=None)</code>  <code>async</code>","text":"<p>/tag create</p> Description <p>Create tags.</p> <p>Parameters:</p> Name Type Description Default <code>tagname</code> <code>str</code> <p>The tag's name</p> <code>None</code> <code>content</code> <code>str</code> <p>The content of the tag</p> <code>None</code> <code>attachment</code> <code>OptionType.ATTACHMENT</code> <p>The attachment from the message</p> <code>None</code> Source code in <code>extentions/tags.py</code> <pre><code>@tag.subcommand(sub_cmd_name='create', sub_cmd_description=\"allow's me to store tags\")\n@slash_option(name='tagname', description='Type a name of a tag', opt_type=OptionType.STRING, required=True, autocomplete=False)\n@content()\n@attachment()\nasync def tag_create(self, ctx:InteractionContext, tagname:str=None, content:str=None, attachment:OptionType.ATTACHMENT=None):\n\"\"\"/tag create\n    Description:\n        Create tags.\n\n    Args:\n        tagname: The tag's name\n        content: The content of the tag\n        attachment: The attachment from the message\n    \"\"\"\n    await ctx.defer()\n    if tagname is None:\n        embed = Embed(description=f\":x: You must include tag's name\",\n                    color=0xDD2222)\n        await ctx.send(embed=embed, ephemeral=True)\n        return\n    elif (content is None) and (attachment is None):\n        embed = Embed(description=f\":x: You must include tag's content\",\n                    color=0xDD2222)\n        await ctx.send(embed=embed, ephemeral=True)\n        return\n    elif (tagname is None) and (content is None):\n        embed = Embed(description=f\":x: You must include tag's name and content\",\n                    color=0xDD2222)\n        await ctx.send(embed=embed, ephemeral=True)\n        return\n\n    tagname_regx = {'$regex':f'^{re.escape(tagname)}$', '$options':'i'}\n    check = await db.tag.find_one({'guild_id':ctx.guild_id, 'names':tagname_regx})\n    if check==None:\n        if attachment is not None:\n            for at in ['exe', 'scr', 'cpl', 'doc', 'jar']:\n                if at in attachment.content_type:\n                    return await ctx.send(f'`{at}` attachment file type is not allowed to be uploaded to our host site')\n            if content is None:\n                if (attachment.content_type == 'image/png') or (attachment.content_type == 'image/jpg') or (attachment.content_type == 'image/jpeg') or (attachment.content_type == 'image/gif'):\n                    image_url = catbox.url_upload(attachment.url)\n                    await db.tag(guild_id=ctx.guild_id, author_id=ctx.author.id, owner_id=ctx.author.id, names=tagname, content=content, attachment_url=image_url, creation_date=datetime.utcnow()).insert()\n                    embed = Embed(description=f\"__**Tag created!**__ \\n\\n**Tag's name:** {tagname}\",\n                            color=0xffcc50)\n                    embed.set_image(url=image_url)\n                    return await ctx.send(embed=embed)\n                else:\n                    await db.tag(guild_id=ctx.guild_id, author_id=ctx.author.id, owner_id=ctx.author.id, names=tagname, content=content, attachment_url=catbox.url_upload(attachment.url), creation_date=datetime.utcnow()).insert()\n                    embed = Embed(description=f\"__**Tag created!**__ \\n\\n**Tag's name:** {tagname}\\n**Attachment:** {catbox.url_upload(attachment.url)}\",\n                            color=0xffcc50)\n                    return await ctx.send(embed=embed)\n            else:\n                if (attachment.content_type == 'image/png') or (attachment.content_type == 'image/jpg') or (attachment.content_type == 'image/jpeg') or (attachment.content_type == 'image/gif'):\n                    image_url = catbox.url_upload(attachment.url)\n                    await db.tag(guild_id=ctx.guild_id, author_id=ctx.author.id, owner_id=ctx.author.id, names=tagname, content=content, attachment_url=image_url, creation_date=datetime.utcnow()).insert()\n                    embed = Embed(description=f\"__**Tag created!**__ \\n\\n**Tag's name:** {tagname}\\n**Content:** {content}\",\n                            color=0xffcc50)\n                    embed.set_image(url=image_url)\n                    return await ctx.send(embed=embed)\n                else:\n                    await db.tag(guild_id=ctx.guild_id, author_id=ctx.author.id, owner_id=ctx.author.id, names=tagname, content=content, attachment_url=catbox.url_upload(attachment.url), creation_date=datetime.utcnow()).insert()\n                    embed = Embed(description=f\"__**Tag created!**__ \\n\\n**Tag's name:** {tagname}\\n**Content:** {content}\\n**Attachment:** {catbox.url_upload(attachment.url)}\",\n                            color=0xffcc50)\n                    return await ctx.send(embed=embed)\n        else:\n            if content is not None:\n                url = geturl(content)\n                for url in url:\n                    url = url\n                if url:\n                    for at in ['.exe', '.scr', '.cpl', '.doc', '.jar']:\n                        if url.endswith(at):\n                            return await ctx.send(f'`{at}` url file type is not allowed to be stored in my database')\n                    if url.endswith('.png') or url.endswith('.apng') or url.endswith('.jpg') or url.endswith('.jpeg') or url.endswith('.gif'):\n                        await db.tag(guild_id=ctx.guild_id, author_id=ctx.author.id, owner_id=ctx.author.id, names=tagname, content=content, attachment_url=url, creation_date=datetime.utcnow()).insert()\n                        embed = Embed(description=f\"__**Tag created!**__ \\n\\n**Tag's name:** {tagname} \\n**Tag's content:**{content}\",\n                                    color=0xffcc50)\n                        embed.set_image(url=url)\n                        return await ctx.send(embed=embed)\n                    else:\n                        await db.tag(guild_id=ctx.guild_id, author_id=ctx.author.id, owner_id=ctx.author.id, names=tagname, content=content, attachment_url=url, creation_date=datetime.utcnow()).insert()\n                        embed = Embed(description=f\"__**Tag created!**__ \\n\\n**Tag's name:** {tagname} \\n**Tag's content:** \\n{content}\",\n                                    color=0xffcc50)\n                        return await ctx.send(embed=embed)\n                else:\n                    await db.tag(guild_id=ctx.guild_id, author_id=ctx.author.id, owner_id=ctx.author.id, names=tagname, content=content, attachment_url=None, creation_date=datetime.utcnow()).insert()\n                    embed = Embed(description=f\"__**Tag created!**__ \\n\\n**Tag's name:** {tagname} \\n**Tag's content:** \\n{content}\",\n                                color=0xffcc50)\n                    return await ctx.send(embed=embed)\n    else:\n        embed = Embed(description=f\":x: The tag `{tagname}` already exists\",\n                    color=0xDD2222)\n        await ctx.send(embed=embed, ephemeral=True)\n</code></pre>"},{"location":"tags/#extentions.tags.Tags.tag_delete","title":"<code>tag_delete(ctx, tagname=None)</code>  <code>async</code>","text":"<p>/tag delete</p> Description <p>Delete tags.</p> <p>Parameters:</p> Name Type Description Default <code>tagname</code> <code>str</code> <p>The tag's name</p> <code>None</code> Source code in <code>extentions/tags.py</code> <pre><code>@tag.subcommand(sub_cmd_name='delete', sub_cmd_description=\"allow's me to delete tags that you own\")\n@tagname()\nasync def tag_delete(self, ctx:InteractionContext, tagname:str=None):\n\"\"\"/tag delete\n    Description:\n        Delete tags.\n\n    Args:\n        tagname: The tag's name\n    \"\"\"\n    await ctx.defer()\n    if tagname is None:\n        embed = Embed(description=f\":x: You must include tag's name\",\n                    color=0xDD2222)\n        await ctx.send(embed=embed, ephemeral=True)\n        return\n\n    tagname_regx = {'$regex':f'^{re.escape(tagname)}$', '$options':'i'}\n    tag_to_delete = await db.tag.find_one({'guild_id':ctx.guild_id, 'names':tagname_regx, 'author_id':ctx.author.id})\n    if tag_to_delete is None:\n        tag_to_delete = await db.tag.find_one({'guild_id':ctx.guild_id, 'names':tagname_regx, 'owner_id':ctx.author.id})\n        if tag_to_delete is None:\n            embed = Embed(description=f\":x: You don't own a tag called  `{tagname}`\",\n                        color=0xDD2222)\n            await ctx.send(embed=embed, ephemeral=True)\n            return\n    content = ''\n    if tag_to_delete.content is None:\n        if tag_to_delete.attachment_url is not None:\n            content = content + f'{tag_to_delete.attachment_url}'\n    elif tag_to_delete.content is not None:\n        content = content + f'{tag_to_delete.content}'\n        if tag_to_delete.attachment_url is not None:\n            content = content + f'\\n{tag_to_delete.attachment_url}'\n    embed = Embed(description=f\"__**Tag deleted!**__ \\n\\n**Tag's name:** {tag_to_delete.names} \\n**Tag's content:**{content}\",\n                color=0xffcc50)\n    await ctx.send(embed=embed)\n    await tag_to_delete.delete()\n</code></pre>"},{"location":"tags/#extentions.tags.Tags.tag_admin_delete","title":"<code>tag_admin_delete(ctx, tagname=None)</code>  <code>async</code>","text":"<p>/tag admindelete</p> Description <p>Delete any tags. Requires admin permission.</p> <p>Parameters:</p> Name Type Description Default <code>tagname</code> <code>str</code> <p>The tag's name</p> <code>None</code> Source code in <code>extentions/tags.py</code> <pre><code>@tag.subcommand(sub_cmd_name='admindelete', sub_cmd_description=\"[ADMIN ONLY]allow's me to delete any tag\")\n@tagname()\n@check(member_permissions(Permissions.ADMINISTRATOR))\nasync def tag_admin_delete(self, ctx:InteractionContext, tagname:str=None):\n\"\"\"/tag admindelete\n    Description:\n        Delete any tags. Requires admin permission.\n\n    Args:\n        tagname: The tag's name\n    \"\"\"\n    await ctx.defer()\n    if tagname is None:\n        embed = Embed(description=f\":x: You must include tag's name\",\n                    color=0xDD2222)\n        await ctx.send(embed=embed, ephemeral=True)\n        return\n\n    tagname_regx = {'$regex':f'^{re.escape(tagname)}$', '$options':'i'}\n    tag_to_delete = await db.tag.find_one({'guild_id':ctx.guild_id, 'names':tagname_regx})\n    if tag_to_delete is None:\n        embed = Embed(description=f\":x: There's not a tag with the name `{tagname}`\",\n                    color=0xDD2222)\n        await ctx.send(embed=embed, ephemeral=True)\n        return\n\n    content = ''\n    if tag_to_delete.content is None:\n        if tag_to_delete.attachment_url is not None:\n            content = content + f'{tag_to_delete.attachment_url}'\n    elif tag_to_delete.content is not None:\n        content = content + f'{tag_to_delete.content}'\n        if tag_to_delete.attachment_url is not None:\n            content = content + f'\\n{tag_to_delete.attachment_url}'\n    embed = Embed(description=f\"__**Tag deleted!**__ \\n\\n**Tag's name:** {tag_to_delete.names} \\n**Tag's content:**{content}\",\n                color=0xffcc50)\n    await ctx.send(embed=embed)\n    await tag_to_delete.delete()\n</code></pre>"},{"location":"tags/#extentions.tags.Tags.tag_edit","title":"<code>tag_edit(ctx, tagname=None, content=None, attachment=None)</code>  <code>async</code>","text":"<p>/tag edit</p> Description <p>Edit tags.</p> <p>Parameters:</p> Name Type Description Default <code>tagname</code> <code>str</code> <p>The tag's name</p> <code>None</code> <code>content</code> <code>str</code> <p>The content of the tag</p> <code>None</code> <code>attachment</code> <code>OptionType.ATTACHMENT</code> <p>The attachment from the message</p> <code>None</code> Source code in <code>extentions/tags.py</code> <pre><code>@tag.subcommand(sub_cmd_name='edit', sub_cmd_description=\"allow's me to delete tags that you own\")\n@tagname()\n@content()\n@attachment()\nasync def tag_edit(self, ctx:InteractionContext, tagname:str=None, content:str=None, attachment:OptionType.ATTACHMENT=None):\n\"\"\"/tag edit\n    Description:\n        Edit tags.\n\n    Args:\n        tagname: The tag's name\n        content: The content of the tag\n        attachment: The attachment from the message\n    \"\"\"\n    await ctx.defer()\n    if tagname is None:\n        embed = Embed(description=f\":x: You must include tag's name\",\n                    color=0xDD2222)\n        await ctx.send(embed=embed, ephemeral=True)\n        return\n    elif (content is None) and (attachment is None):\n        embed = Embed(description=f\":x: You must include tag's content\",\n                    color=0xDD2222)\n        await ctx.send(embed=embed, ephemeral=True)\n        return\n    elif (tagname is None) and (content is None):\n        embed = Embed(description=f\":x: You must include tag's name and content\",\n                    color=0xDD2222)\n        await ctx.send(embed=embed, ephemeral=True)\n        return\n\n    tagname_regx = {'$regex':f'^{re.escape(tagname)}$', '$options':'i'}\n    tag_to_edit = await db.tag.find_one({'guild_id':ctx.guild_id, 'names':tagname_regx, 'author_id':ctx.author.id})\n    if tag_to_edit is None:\n        tag_to_edit = await db.tag.find_one({'guild_id':ctx.guild_id, 'names':tagname_regx, 'owner_id':ctx.author.id})\n        if tag_to_edit is None:\n            embed = Embed(description=f\":x: You don't own a tag called  `{tagname}`\",\n                        color=0xDD2222)\n            await ctx.send(embed=embed, ephemeral=True)\n            return\n\n    if attachment is not None:\n        for at in ['exe', 'scr', 'cpl', 'doc', 'jar']:\n            if at in attachment.content_type:\n                return await ctx.send(f'`{at}` attachment file type is not allowed to be uploaded to our host site')\n        if content is None:\n            if (attachment.content_type == 'image/png') or (attachment.content_type == 'image/jpg') or (attachment.content_type == 'image/jpeg') or (attachment.content_type == 'image/gif'):\n                image_url = catbox.url_upload(attachment.url)\n                tag_to_edit.attachment_url = catbox.url_upload(attachment.url)\n                tag_to_edit.content = content\n                await tag_to_edit.save()\n                embed = Embed(description=f\"__**Tag edited!**__ \\n\\n**Tag's name:** {tagname}\",\n                        color=0xffcc50)\n                embed.set_image(url=image_url)\n                return await ctx.send(embed=embed)\n            else:\n                tag_to_edit.attachment_url = catbox.url_upload(attachment.url)\n                tag_to_edit.content = content\n                await tag_to_edit.save()\n                embed = Embed(description=f\"__**Tag edited!**__ \\n\\n**Tag's name:** {tagname}\\n**Attachment:** {catbox.url_upload(attachment.url)}\",\n                        color=0xffcc50)\n                return await ctx.send(embed=embed)\n        else:\n            if (attachment.content_type == 'image/png') or (attachment.content_type == 'image/jpg') or (attachment.content_type == 'image/jpeg') or (attachment.content_type == 'image/gif'):\n                image_url = catbox.url_upload(attachment.url)\n                tag_to_edit.attachment_url = catbox.url_upload(attachment.url)\n                tag_to_edit.content = content\n                await tag_to_edit.save()\n                embed = Embed(description=f\"__**Tag edited!**__ \\n\\n**Tag's name:** {tagname}\\n**Content:** {content}\",\n                        color=0xffcc50)\n                embed.set_image(url=image_url)\n                return await ctx.send(embed=embed)\n            else:\n                tag_to_edit.attachment_url = catbox.url_upload(attachment.url)\n                tag_to_edit.content = content\n                await tag_to_edit.save()\n                embed = Embed(description=f\"__**Tag created!**__ \\n\\n**Tag's name:** {tagname}\\n**Content:** {content}\\n**Attachment:** {catbox.url_upload(attachment.url)}\",\n                        color=0xffcc50)\n                return await ctx.send(embed=embed)\n    else:\n        if content is not None:\n            url = geturl(content)\n            for url in url:\n                url = url\n            if url:\n                for at in ['.exe', '.scr', '.cpl', '.doc', '.jar']:\n                        if url.endswith(at):\n                            return await ctx.send(f'`{at}` url file type is not allowed to be stored in my database')\n                if url.endswith('.png') or url.endswith('.apng') or url.endswith('.jpg') or url.endswith('.jpeg') or url.endswith('.gif'):\n                    tag_to_edit.attachment_url = None\n                    tag_to_edit.content = content\n                    await tag_to_edit.save()\n                    embed = Embed(description=f\"__**Tag created!**__ \\n\\n**Tag's name:** {tagname} \\n**Tag's content:**{content}\",\n                                color=0xffcc50)\n                    embed.set_image(url=url)\n                    return await ctx.send(embed=embed)\n                else:\n                    tag_to_edit.attachment_url = None\n                    tag_to_edit.content = content\n                    await tag_to_edit.save()\n                    embed = Embed(description=f\"__**Tag created!**__ \\n\\n**Tag's name:** {tagname} \\n**Tag's content:** \\n{content}\",\n                                color=0xffcc50)\n                    return await ctx.send(embed=embed)\n            else:\n                tag_to_edit.attachment_url = None\n                tag_to_edit.content = content\n                await tag_to_edit.save()\n                embed = Embed(description=f\"__**Tag created!**__ \\n\\n**Tag's name:** {tagname} \\n**Tag's content:** \\n{content}\",\n                            color=0xffcc50)\n                return await ctx.send(embed=embed)\n</code></pre>"},{"location":"tags/#extentions.tags.Tags.tag_info","title":"<code>tag_info(ctx, tagname=None)</code>  <code>async</code>","text":"<p>/tag info</p> Description <p>See info about tags</p> <p>Parameters:</p> Name Type Description Default <code>tagname</code> <code>str</code> <p>The tag's name</p> <code>None</code> Source code in <code>extentions/tags.py</code> <pre><code>@tag.subcommand(sub_cmd_name='info', sub_cmd_description=\"allow's me to see information about a tag\")\n@tagname()\nasync def tag_info(self, ctx:InteractionContext, tagname:str=None):\n\"\"\"/tag info\n    Description:\n        See info about tags\n\n    Args:\n        tagname: The tag's name\n    \"\"\"\n    await ctx.defer()\n    if tagname is None:\n        embed = Embed(description=f\":x: You must include tag's name\",\n                    color=0xDD2222)\n        await ctx.send(embed=embed, ephemeral=True)\n        return\n\n    tagname_regx = {'$regex':f'^{re.escape(tagname)}$', '$options':'i'}\n    tag_to_view = await db.tag.find_one({'guild_id':ctx.guild_id, 'names':tagname_regx})\n    if tag_to_view is None:\n        embed = Embed(description=f\":x: I couldn't find a tag called `{tagname}`\",\n                    color=0xDD2222)\n        await ctx.send(embed=embed, ephemeral=True)\n        return\n\n    if tag_to_view.owner_id is None:\n        owner_id = tag_to_view.author_id\n    else:\n        owner_id = tag_to_view.owner_id\n\n    tag_owner = ctx.guild.get_member(owner_id)         \n    if tag_owner is None:\n        tag_owner = tag_to_view.owner_id\n        current_owner = 'Currently Orphaned'\n        last_owner = f'Last owner: {tag_owner}'\n    else:\n        current_owner = 'Current owner'\n        last_owner = tag_owner\n\n\n    total_uses = tag_to_view.no_of_times_used\n    if total_uses is None:\n        uses = 'UNKNOWN'\n    else:\n        uses = total_uses\n\n    creation_date = tag_to_view.creation_date\n    if creation_date is None:\n        date = 'UNKNOWN'\n    else:\n        date = f'&lt;t:{math.ceil(tag_to_view.creation_date.replace(tzinfo=timezone.utc).timestamp())}:R&gt;'\n\n    if tag_to_view.attachment_url is not None:\n        if tag_to_view.content is not None:\n            content = f'{tag_to_view.content}\\n{tag_to_view.attachment_url}'\n        else:\n            content = f'{tag_to_view.attachment_url}'\n    else:\n        content = f'{tag_to_view.content}'\n\n    embed = Embed(title=f\"Info about [{tag_to_view.names}] tag\",\n                color=0xffcc50)\n    embed.add_field(name=current_owner, value=last_owner)\n    embed.add_field(name=\"Total uses\", value=uses)\n    embed.add_field(name=\"Created\", value=date)\n    embed.add_field(name=\"Content\", value=content)\n    await ctx.send(embed=embed)\n</code></pre>"},{"location":"tags/#extentions.tags.Tags.tag_list","title":"<code>tag_list(ctx)</code>  <code>async</code>","text":"<p>/tag list</p> Description <p>Lists all tags</p> Source code in <code>extentions/tags.py</code> <pre><code>@tag.subcommand(sub_cmd_name='list', sub_cmd_description=\"allow's me to see all tags for this server\")\nasync def tag_list(self, ctx:InteractionContext):\n\"\"\"/tag list\n    Description:\n        Lists all tags\n    \"\"\"\n    await ctx.defer()\n    from interactions.ext.paginators import Paginator\n    def chunks(l, n):\n        n = max(1, n)\n        return (l[i:i+n] for i in range(0, len(l), n))\n\n    def mlis(lst, s, e):\n        nc = list(chunks(lst, 20))\n        mc = ''\n        for testlist in nc[s:e]:\n            for m in testlist:\n                mc = mc + m\n        return mc\n\n    def newpage(title, names):\n        embed = Embed(title=title,\n        color=0xffcc50)\n        embed.add_field(name='Tag Names', value=names, inline=True)\n        return embed\n\n\n    tag_names = db.tag.find({\"guild_id\":ctx.guild_id})\n    names = []\n    async for t in tag_names:\n        names.append(f\"{t.names}\\n\")\n    if names == []:\n        embed = Embed(description=f\"There are no tags for {ctx.guild.name}.\",\n                    color=0xffcc50)\n        await ctx.send(embed=embed)\n        return\n\n    s = -1\n    e = 0\n    embedcount = 1\n    nc = list(chunks(names, 20))\n\n    embeds = []\n    while embedcount &lt;= len(nc):\n        s = s+1\n        e = e+1\n        embeds.append(newpage(f'List of tags for {ctx.guild.name}', mlis(names, s, e)))\n        embedcount = embedcount+1\n\n    paginator = Paginator(\n        client=self.bot, \n        pages=embeds,\n        timeout_interval=80,\n        show_select_menu=False,\n        wrong_user_message=\"You're not the one destined for this list.\")\n    await paginator.send(ctx)\n</code></pre>"},{"location":"tags/#extentions.tags.Tags.tag_claim","title":"<code>tag_claim(ctx, tagname=None)</code>  <code>async</code>","text":"<p>/tag claim</p> Description <p>Claim orphaned tags</p> <p>Parameters:</p> Name Type Description Default <code>tagname</code> <code>str</code> <p>The tag's name</p> <code>None</code> Source code in <code>extentions/tags.py</code> <pre><code>@tag.subcommand(sub_cmd_name='claim', sub_cmd_description=\"claim orphaned tags\")\n@tagname()\nasync def tag_claim(self, ctx:InteractionContext, tagname:str=None):\n\"\"\"/tag claim\n    Description:\n        Claim orphaned tags\n\n    Args:\n        tagname: The tag's name\n    \"\"\"\n    await ctx.defer()\n    if tagname is None:\n        embed = Embed(description=f\":x: You must include tag's name\",\n                    color=0xDD2222)\n        await ctx.send(embed=embed, ephemeral=True)\n        return\n\n    tagname_regx = {'$regex':f'^{re.escape(tagname)}$', '$options':'i'}\n    tag_to_claim = await db.tag.find_one({'guild_id':ctx.guild_id, 'names':tagname_regx})\n    if tag_to_claim is None:\n        embed = Embed(description=f\":x: I couldn't find a tag called `{tagname}`\",\n                    color=0xDD2222)\n        await ctx.send(embed=embed, ephemeral=True)\n        return\n    if tag_to_claim.owner_id is None:\n        current_owner = tag_to_claim.author_id\n    else:\n        current_owner = tag_to_claim.owner_id\n    if (current_owner == ctx.author.id):\n        embed = Embed(description=f\":x: You can't claim a tag you already own\",\n                    color=0xDD2222)\n        await ctx.send(embed=embed, ephemeral=True)\n        return\n    if (tag_to_claim.author_id == ctx.author.id) and (current_owner != ctx.author.id):\n        mf = ctx.guild.get_member(current_owner)\n        if mf is None:\n            thief = current_owner\n        else:\n            thief = mf.mention\n\n        embed = Embed(description=f\"{ctx.author.mention} You took back your tag {tag_to_claim.names} from {thief}\",\n                    color=0xffcc50)\n        await ctx.send(embed=embed)\n        current_owner = ctx.author.id\n        await tag_to_claim.save()\n        return\n\n    if ctx.guild.get_member(current_owner) is None:\n        tag_to_claim.owner_id = ctx.author.id\n        await tag_to_claim.save()\n        embed = Embed(description=f\"{ctx.author.mention} You are now owner of {tag_to_claim.names}\",\n                    color=0xffcc50)\n        await ctx.send(embed=embed)\n    else:\n        embed = Embed(description=f\":x: You can't claim a tag that's not orphaned\",\n                    color=0xDD2222)\n        await ctx.send(embed=embed, ephemeral=True)\n</code></pre>"},{"location":"tags/#extentions.tags.Tags.tag_gift","title":"<code>tag_gift(ctx, tagname=None, member=None)</code>  <code>async</code>","text":"<p>/tag gift</p> Description <p>Gidt tags you own</p> <p>Parameters:</p> Name Type Description Default <code>tagname</code> <code>str</code> <p>The tag's name</p> <code>None</code> <code>member</code> <code>OptionType.USER</code> <p>Member to gift to</p> <code>None</code> Source code in <code>extentions/tags.py</code> <pre><code>@tag.subcommand(sub_cmd_name='gift', sub_cmd_description=\"gift your tags\")\n@tagname()\n@member()\nasync def tag_gift(self, ctx:InteractionContext, tagname:str=None, member:OptionType.USER=None):\n\"\"\"/tag gift\n    Description:\n        Gidt tags you own\n\n    Args:\n        tagname: The tag's name\n        member: Member to gift to\n    \"\"\"\n    await ctx.defer()\n    if tagname is None:\n        embed = Embed(description=f\":x: You must include tag's name\",\n                    color=0xDD2222)\n        await ctx.send(embed=embed, ephemeral=True)\n        return\n\n    if member is None:\n        embed = Embed(description=f\":x: You must include a member\",\n                    color=0xDD2222)\n        await ctx.send(embed=embed, ephemeral=True)\n        return\n\n    if member == ctx.author:\n        embed = Embed(description=f\":x: You can't gift to yourself, egomaniac...\",\n                    color=0xDD2222)\n        await ctx.send(embed=embed, ephemeral=True)\n        return\n\n    tagname_regx = {'$regex':f'^{re.escape(tagname)}$', '$options':'i'}\n    tag_to_claim = await db.tag.find_one({'guild_id':ctx.guild_id, 'names':tagname_regx, 'owner_id':ctx.author.id})\n    if tag_to_claim is None:\n        embed = Embed(description=f\":x: You don't own a tag with that name\",\n                    color=0xDD2222)\n        await ctx.send(embed=embed, ephemeral=True)\n        return\n    aceept_button_id = f'{member.id}_accept_tag_gift_button'\n    cancel_button_id = f'{ctx.author.id}_accept_tag_gift_button'\n    accept_button: list[ActionRow] = spread_to_rows(\n        Button(\n            style=ButtonStyle.GREEN,\n            label=\"GIMME!\",\n            custom_id=aceept_button_id\n        ),\n        Button(\n            style=ButtonStyle.RED,\n            label=\"Cancel!\",\n            custom_id=cancel_button_id\n        )\n    )\n    def check(component: Button) -&gt; bool:\n        return (component.context.author == ctx.author) or (component.context.author == member)\n\n    gift_question = await ctx.send(f'Hey {member.mention}! {ctx.author.mention} is gifting you a {tag_to_claim.names}, do you accept the gift?', components=accept_button)\n    while True:\n        try:\n            reaction = await self.bot.wait_for_component(components=accept_button, timeout=30)\n        except asyncio.TimeoutError:\n            accept_button[0].components[0].disabled = True\n            accept_button[0].components[1].disabled = True\n            await gift_question.edit('Time ran out to accept the gift.', components=accept_button)\n            return\n        if (reaction.context.custom_id == aceept_button_id) and (member == reaction.context.author):\n            tag_to_claim.owner_id = member.id\n            await tag_to_claim.save()\n            accept_button[0].components[0].disabled = True\n            accept_button[0].components[1].disabled = True\n            await gift_question.edit(f'Gift for a tag {tag_to_claim.names} accepted!', components=accept_button)\n            return\n        elif (reaction.context.custom_id == aceept_button_id) and (member != reaction.context.author):\n            await ctx.send(f\"{reaction.context.author.mention} You can't accept gifts not menat for you!\", ephemeral=True)\n\n        if (reaction.context.custom_id == cancel_button_id) and (ctx.author == reaction.context.author):\n            accept_button[0].components[0].disabled = True\n            accept_button[0].components[1].disabled = True\n            await gift_question.edit(f'Gift for a tag {tag_to_claim.names} cancelled!', components=accept_button)\n            return\n        elif (reaction.context.custom_id == cancel_button_id) and (ctx.author != reaction.context.author):\n            await ctx.send(f\"{reaction.context.author.mention} Only owners can cancel gifting!\", ephemeral=True)\n</code></pre>"}]}